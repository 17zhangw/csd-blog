<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>CMU CSD PhD Blog</title>
	<link href="https://www.cs.cmu.edu/~csd-phd-blog/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://www.cs.cmu.edu/~csd-phd-blog/"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2024-04-09T00:00:00+00:00</updated>
	<id>https://www.cs.cmu.edu/~csd-phd-blog/atom.xml</id>
	<entry xml:lang="en">
		<title>Measuring and Exploiting Network Usable Information</title>
		<published>2024-04-09T00:00:00+00:00</published>
		<updated>2024-04-09T00:00:00+00:00</updated>
		<link href="https://www.cs.cmu.edu/~csd-phd-blog/2024/network-usable-information/" type="text/html"/>
		<id>https://www.cs.cmu.edu/~csd-phd-blog/2024/network-usable-information/</id>
		<content type="html">&lt;p&gt;In large cloud service providers such as AWS, the customer provides an attributed graph and would like to perform tasks like recommendations using message-passing methods within restricted budgets.
An attributed graph consists of both the graph structure and the node features.
As one of the message-passing methods, Graph Neural Networks (GNNs) are commonly used for graph tasks by propagating node features through the graph structure.
However, it is possible that not all the information in the provided graph is usable for solving the task.
Training a GNN would thus be a waste of time and resources for the customer.
Therefore, we aim to answer two questions:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Given a graph with node features, how can we tell whether utilizing both graph structure and node features, will yield better performance than utilizing either of them separately?&lt;&#x2F;li&gt;
&lt;li&gt;How can we know what information in the graph (if any) is usable to solve the tasks, namely, node classification and link prediction? &lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Our goal is to design a metric for measuring how informative the graph structure and node features are for the task at hand, which we call network usable information (NUI).&lt;&#x2F;p&gt;
&lt;!-- However, in real-world scenarios, it is possible that neither the graph structure nor the node features are usable for solving the task.
In these scenarios, training a GNN will be a waste of time and resources, especially for large cloud service providers like AWS, whose customers would like to perform the tasks with restricted budgets in a short time.  --&gt;
&lt;p&gt;In this blog post, we introduce how to measure the information in the graph, and to exploit it for solving the graph tasks. This blog post is based on our research paper, “NetInfoF Framework: Measuring and Exploiting Network Usable Information” [1], presented at ICLR 2024.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-is-an-attributed-graph&quot;&gt;What is an attributed graph?&lt;&#x2F;h2&gt;
&lt;figure&gt;
&lt;img src=&quot;.&#x2F;figure1.png&quot; alt=&quot;attributed graph&quot; width=&quot;500&quot;&#x2F;&gt;
&lt;figcaption&gt;
Figure 1. An example of an attributed social network graph, where the nodes denote the users, and the edges denote whether two users are friends.
&lt;&#x2F;figcaption&gt;
&lt;&#x2F;figure&gt;
&lt;p&gt;A graph is a data structure that includes nodes and edges, representing the connections between nodes.
An attributed graph indicates that each node in the graph has a set of features.
For example, Figure 1 shows the attributed graph for a social network.
The nodes represent the users, illustrated as circles with school icons.
The edges indicate whether two users are friends, illustrated as black lines connecting circles.
A node might also contain additional information:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Node ID&lt;&#x2F;strong&gt;: is illustrated as a thumbnail image of the user along with the user’s text name.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Node attributes&#x2F;features&lt;&#x2F;strong&gt;: represent whether the user is located in the US and whether the user likes to bike, illustrated as a \( 2 \times 2 \) table. &lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Node label&lt;&#x2F;strong&gt;: signify the user’s respective college, categorized into two groups represented by blue and red colors with logos: CMU or NCTU. &lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;In fact, node labels are similar to node features, but they often contain missing values, which we are interested in predicting.&lt;&#x2F;p&gt;
&lt;!-- The nodes (circles with school icons) represent the users, and the edges (black lines connecting circles) indicate whether two users are friends.
The node IDs are represented by the thumbnail person images and the text names.
The node attributes&#x2F;features of users (\\( 2 \times 2 \\) tables) are whether they are located in the US and whether they like to bike. 
The node labels of users, classified into two categories represented by blue and red colors, signify their respective colleges, CMU or NCTU.
In fact, node labels are similar to node features, but they are the ones with missing values and we are interested in predicting them. --&gt;
&lt;figure&gt;
&lt;img src=&quot;.&#x2F;figure2.png&quot; alt=&quot;mathematical representation of graph&quot; width=&quot;500&quot;&#x2F;&gt;
&lt;figcaption&gt;
Figure 2. The mathematical representation of the attributed graph, including an adjacency matrix, node features, and node labels. The red question mark denotes unknown.
&lt;&#x2F;figcaption&gt;
&lt;&#x2F;figure&gt;
&lt;p&gt;In Figure 2, the graph structure can be represented by an adjacency matrix, where 1 denotes the presence of an edge between two nodes, and 0 denotes no edge. 
The node features are also represented by a matrix, where each feature is binary in the example, but it can also be continuous.
The node labels are represented by a matrix with one-hot encoding of the class label.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-are-the-common-graph-tasks&quot;&gt;What are the common graph tasks?&lt;&#x2F;h2&gt;
&lt;p&gt;We consider the two common graph tasks:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Node Classification&lt;&#x2F;strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Goal:&lt;&#x2F;em&gt; Predict the classes of the unlabeled nodes, while some labeled nodes are given.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;em&gt;Example:&lt;&#x2F;em&gt; Given a social network with features, can we guess which college Bob goes to, i.e., the label of the gray node in Figure 1?&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Link Prediction&lt;&#x2F;strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Goal:&lt;&#x2F;em&gt; Predict the potential additional edges in the graph.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;em&gt;Example:&lt;&#x2F;em&gt; Given a social network with features, can we guess whether David and Grace could become friends, i.e., the potential additional red-dash line in Figure 1? &lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;what-are-message-passing-methods&quot;&gt;What are message-passing methods?&lt;&#x2F;h2&gt;
&lt;!-- | U&lt;sub&gt;[n×r]&lt;&#x2F;sub&gt; | Left singular vectors of adjacency matrix | --&gt;
&lt;!-- | r | Rank for matrix decomposition | --&gt;
&lt;figure&gt;
&lt;img src=&quot;.&#x2F;figure3.png&quot; alt=&quot;node embedding&quot; width=&quot;500&quot;&#x2F;&gt;
&lt;figcaption&gt;
Figure 3. Illustration of how the nodes in a given graph projected into low-dimensional embedding space. The nodes that are more similar in the graph are closer in the embedding space.
&lt;&#x2F;figcaption&gt;
&lt;&#x2F;figure&gt;
&lt;p&gt;Message-passing methods utilize the graph structure to propagate information from the neighbors of a node to the node itself. 
Known as sum-product message-passing, belief propagation methods [2, 3] directly perform inference on the graph through several propagation iterations. 
Although they are fast and effective because they require neither parameters nor training, belief propagation methods are mainly designed to solve node classification problems based solely on the graph structure and usually do not consider node features.&lt;&#x2F;p&gt;
&lt;!-- To properly handle the interaction between node classes, Günnemann et al. [2] assumes that a \\( c \times c \\) compatibility matrix is given by the domain expert, while Lee et al. [3] estimates it with the given graph data.  --&gt;
&lt;p&gt;Another variety of message-passing methods, Graph Neural Networks (GNNs) [4], are a class of deep learning models. 
They are commonly used to generate low-dimensional embeddings of nodes to perform graph tasks by learning end-to-end with a training objective.
As shown in Figure 3, the nodes that are better connected in the graph are expected to have closer embeddings in the low-dimensional space.&lt;&#x2F;p&gt;
&lt;p&gt;Some studies remove the non-linear functions in GNNs, and still achieve good performance, which we call linear GNNs [5, 6].
One of the many advantages of linear GNNs is that their node embeddings are available prior to model training. 
A comprehensive study on linear GNNs can be found in [6].&lt;&#x2F;p&gt;
&lt;!-- The function of a two-layer Graph Convolutional Network (GCN) [4] can be written as:
\\[ \hat{Y} = A\sigma(AXW_{1})W_{2}, \\]
where \\( A \\) is the normalized adjacency matrix with self-loop, \\( X \\) is the node features, \\( W_i \\) is the learnable matrix for the \\( i \\)-th layer, and \\( \sigma \\) is the non-linear activation function, typically a sigmoid or a ReLU.
By removing &amp;sigma; from the above equation, it reduces to:
\\[ \hat{Y} = A^{2}XW, \\]
which is a linear model with a node embedding \\( A^{2}X \\) that can be precomputed. This particular model is Simple Graph Convolution (SGC) [5], which is the first linear GNN model. One of the many advantages of linear GNNs is that their node embeddings are available prior to model training. A comprehensive study on linear GNNs can be found in [6]. --&gt;
&lt;!-- | Symbol | Definition |
| -------- | -------- |
| \\( A_{[n \times n]} \\) | Adjacency matrix |
| \\( X_{[n \times f]} \\) | Node feature matrix |
| \\( W_{[f \times c]} \\) | Learnable parameter matrix in linear GNNs |
| \\( \hat{Y}_{[n \times c]} \\) | Predicted node label matrix |
| \\( n \\) | Number of nodes |
| \\( f \\) | Number of features |
| \\( c \\) | Number of classes | --&gt;
&lt;h2 id=&quot;measuring-nui-would-a-message-passing-method-work-in-a-given-setting&quot;&gt;&lt;em&gt;Measuring NUI:&lt;&#x2F;em&gt; Would a message-passing method work in a given setting?&lt;&#x2F;h2&gt;
&lt;figure&gt;
&lt;img src=&quot;.&#x2F;figure4.png&quot; alt=&quot;scenarios&quot; width=&quot;400&quot;&#x2F;&gt;
&lt;figcaption&gt;
Figure 4. Scenarios in which the message-passing method may not work well. (a): The graph structure exhibits no network effects. (b): Node features are not correlated with node labels.
&lt;&#x2F;figcaption&gt;
&lt;&#x2F;figure&gt;
&lt;p&gt;Given an attributed graph, how can we measure the network usable information (NUI)? The message-passing method may not work well in the following scenarios:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;No network effects:&lt;&#x2F;strong&gt; means that the graph structure is not useful to solve the graph task. In Figure 4(a), since every labeled node has one blue and one red neighbor, we cannot infer the label for Bob by examining its neighbors.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Useless node features:&lt;&#x2F;strong&gt; means that the node features are not useful to solve the graph task. In Figure 4(b), we can see that whether a user likes to bike is not correlated with the user’s university.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;If any of these scenarios is present, a message-passing method is likely to fail in inferring the unknown node label, i.e., Bob’s college.&lt;&#x2F;p&gt;
&lt;figure&gt;
&lt;img src=&quot;.&#x2F;figure5.png&quot; alt=&quot;structural and neighbors&#x27; feature embedding&quot; width=&quot;800&quot;&#x2F;&gt;
&lt;figcaption&gt;
Figure 5. Illustration of structural embedding (left) and neighbors&#x27; feature embedding (right). (a): SVD is conducted on the adjacency matrix to extract structural embedding. (b): Messages passed from a node&#x27;s neighbors are aggregated to generate its node embedding.
&lt;&#x2F;figcaption&gt;
&lt;&#x2F;figure&gt;
&lt;p&gt;We focus on analyzing whether GNNs will perform well in a given setting, which is an important problem in the industry. 
The reason is that, for large cloud service providers, the customer provides them with an attributed graph and requests them to solve the graph task (e.g., recommendation) using GNNs within restricted budgets. 
However, if the given graph lacks network usable information (NUI), the resources spent on training GNNs will be wasted. 
Therefore, our method serves as a preliminary tool to determine whether resources should be allocated for training expensive deep models.&lt;&#x2F;p&gt;
&lt;p&gt;A straightforward way is to analyze the node embedding of the given graph generated by GNNs, but this is only available after training, which is expensive and time-consuming. 
For this reason, we propose to analyze the derived node embedding in linear GNNs, which can be precomputed before model training. 
More specifically, we derive three types of node embedding that can comprehensively represent the information of the given graph, namely:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Structural embedding (\( U \)):&lt;&#x2F;strong&gt; for the information of the graph structure. It is extracted by decomposing the adjacency matrix with singular value decomposition (SVD). Intuitively, the left singular vectors U give the information of the node community. For example, in Figure 5(a), U identifies that the first three users belong to the blue community, while the last four belong to the red community. This is useful when the node features are not useful to solve the graph task.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Feature embedding (\( F \)):&lt;&#x2F;strong&gt; for the information of the node features. It consists of the original node features after dimensional reduction. This is useful when there are no network effects, i.e. the graph structure is not useful to solve the graph task.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Neighbors’ feature embedding (\( S \)):&lt;&#x2F;strong&gt; for the information of the features aggregated from the neighbors. As shown in Figure 5(b), the messages are passed and aggregated from the neighbors for two steps. The intuition is that, in addition to the information from the user, the user’s neighbors also provide useful information to the task. Leveraging their information leads to better performance on the graph task. This is useful when both the graph structure and the node features are useful to solve the graph task.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Once we have the embedding that can represent the information of the nodes of the graph, we propose NetInfoF_Score, and link the metrics of graph information and task performance with the following proposed theorem:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Definition 1&lt;&#x2F;strong&gt; (NetInfoF_Score of \( Y \) given \( X \)). 
&lt;em&gt;Given two discrete random variables \( X \) and \( Y \), NetInfoF_Score \( s \) of \( Y \) given \( X \) is defined as:&lt;&#x2F;em&gt;
\[ s = 2^{-H(Y|X)} \]
&lt;em&gt;where \( H(\cdot | \cdot) \) denotes the conditional entropy [7].&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We prove that NetInfoF_Score low-bounds the accuracy:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Theorem 1&lt;&#x2F;strong&gt; (NetInfoF_Score). 
&lt;em&gt;Given two discrete random variables \( X \) and \( Y \), NetInfoF_Score \( s \) of \( Y \) given \( X \) lower-bounds the accuracy:&lt;&#x2F;em&gt;
\[ s = 2^{-H(Y|X)} \leq accuracy(Y|X) = \sum_{x \in X}{\max_{y \in Y}{p_{x, y}}} \]
&lt;em&gt;where \( p_{x, y} \) is the joint probability of \( x \) and \( y \).&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;!-- &lt;figure&gt;
&lt;img src=&quot;.&#x2F;eqn1.png&quot; alt=&quot;Definition and theorem&quot; width=&quot;800&quot;&#x2F;&gt;
&lt;&#x2F;figure&gt; --&gt;
&lt;p&gt;The proof is in [1].
The intuition behind this theorem is that the conditional entropy of \( Y \) (e.g. labels) given \( X \) (e.g. “like biking”), is a strong indicator of how good of a predictor \( X \) is, to guess the target \( Y \).
It provides an advantage to NetInfoF_Score by giving it an intuitive interpretation, which is the lower-bound of the accuracy. When there is little usable information for the task, the value of NetInfoF_Score is close to random guessing.&lt;&#x2F;p&gt;
&lt;figure&gt;
&lt;img src=&quot;.&#x2F;figure6.png&quot; alt=&quot;Emperical study&quot; width=&quot;500&quot;&#x2F;&gt;
&lt;figcaption&gt;
Figure 6. Our theorem holds, where NetInfoF_Score is always less than or equal to validation accuracy.
&lt;&#x2F;figcaption&gt;
&lt;&#x2F;figure&gt;
&lt;p&gt;In Figure 6, each point represents the accuracy and NetInfoF_Score obtained by solving graph tasks using one type of node embedding. 
We find that NetInfoF_Score lower-bounds the accuracy of the given graph task, as expected. 
If an embedding has no usable information to solve the given task, NetInfoF_Score gives a score close to random guessing (see lower left corner in Figure 6).
The details of the experiment can be found in [1].&lt;&#x2F;p&gt;
&lt;h2 id=&quot;exploiting-nui-how-to-solve-graph-tasks&quot;&gt;&lt;em&gt;Exploiting NUI:&lt;&#x2F;em&gt; How to solve graph tasks?&lt;&#x2F;h2&gt;
&lt;p&gt;In this blog, we focus on explaining how to solve node classification. How to solve link prediction is more complicated, and the details can be found in [1].&lt;&#x2F;p&gt;
&lt;p&gt;To solve node classification, we concatenate different types of embedding, and the input of the classifier is as follows:
\[ U \parallel F \parallel S , \]
where \( \parallel \) is concatenation, \( U \) is the structural embedding, \( F \) is the feature embedding, and \( S \) is the neighbors’ feature embedding. Among all the choices, we use logistic regression as the node classifier, as it is fast and interpretable.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;how-well-does-our-proposed-method-perform&quot;&gt;How well does our proposed method perform?&lt;&#x2F;h2&gt;
&lt;figure&gt;
&lt;img src=&quot;.&#x2F;table1.png&quot; alt=&quot;Node classification&quot; width=&quot;1000&quot;&#x2F;&gt;
&lt;&#x2F;figure&gt;
&lt;p&gt;As shown in Table 1, applied on 12 real-world graphs, NetInfoF outperforms GNN baselines in 7 out of 12 datasets on node classification.&lt;&#x2F;p&gt;
&lt;figure&gt;
&lt;img src=&quot;.&#x2F;figure7.png&quot; alt=&quot;NetInfoF_Score on real-world datasets&quot; width=&quot;250&quot;&#x2F;&gt;
&lt;figcaption&gt;
Figure 7. NetInfoF_Score highly correlates to test performance in real-world datasets. Each point denotes the result of one type of embedding in each dataset.
&lt;&#x2F;figcaption&gt;
&lt;&#x2F;figure&gt;
&lt;p&gt;In Figure 7, NetInfoF_Score is highly correlated with test performance on node classification. 
This indicates that NetInfoF_Score is a reliable measure for deciding whether to use a GNN on the given graph or not in a short time, without any model training.
Noting that although our theorem proves that NetInfoF_Score low-bounds &lt;em&gt;training&lt;&#x2F;em&gt; accuracy, it is possible for &lt;em&gt;testing&lt;&#x2F;em&gt; accuracy to be lower than the NetInfoF_Score (blue points below 45 degree line in Figure 7).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In this blog post, we investigate the problem of identifying whether a message-passing method would work well on a given graph. 
To solve this problem, we introduce NetInfoF, to measure and exploit the network usable information (NUI). 
Applied on real-world graphs, NetInfoF not only correctly mesures NUI with NetInfoF_Score, but also wins 7 out of 12 times on node classification.&lt;&#x2F;p&gt;
&lt;p&gt;Please find more details in our paper [1].&lt;&#x2F;p&gt;
&lt;h2 id=&quot;references&quot;&gt;References&lt;&#x2F;h2&gt;
&lt;p&gt;[1] Lee, M. C., Yu, H., Zhang, J., Ioannidis, V. N., Song, X., Adeshina, S., … &amp;amp; Faloutsos, C. NetInfoF Framework: Measuring and Exploiting Network Usable Information. International Conference on Learning Representations (ICLR), 2024.&lt;&#x2F;p&gt;
&lt;p&gt;[2] Koutra, D., Ke, T. Y., Kang, U., Chau, D. H., Pao, H. K. K., &amp;amp; Faloutsos, C. Unifying guilt-by-association approaches: Theorems and fast algorithms. Machine Learning and Knowledge Discovery in Databases: European Conference (ECML PKDD), 2011&lt;&#x2F;p&gt;
&lt;p&gt;[3] Günnemann, W. G. S., Koutra, D., &amp;amp; Faloutsos, C. Linearized and Single-Pass Belief Propagation. VLDB Endowment, 2015.&lt;&#x2F;p&gt;
&lt;p&gt;[4] Kipf, T. N., &amp;amp; Welling, M. Semi-Supervised Classification with Graph Convolutional Networks. International Conference on Learning Representations (ICLR), 2017.&lt;&#x2F;p&gt;
&lt;p&gt;[5] Wu, F., Souza, A., Zhang, T., Fifty, C., Yu, T., &amp;amp; Weinberger, K. Simplifying Graph Convolutional Networks. PMLR International Conference on Machine Learning (ICML), 2019.&lt;&#x2F;p&gt;
&lt;p&gt;[6] Yoo, J., Lee, M. C., Shekhar, S., &amp;amp; Faloutsos, C. Less is More: SlimG for Accurate, Robust, and Interpretable Graph Mining. ACM SIGKDD Conference on Knowledge Discovery and Data Mining (KDD), 2023.&lt;&#x2F;p&gt;
&lt;p&gt;[7] Conditional entropy. In Wikipedia. &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Conditional_entropy&quot;&gt;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Conditional_entropy&lt;&#x2F;a&gt;, 2024.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Baleen: ML admission &amp; prefetching for flash caches</title>
		<published>2024-01-12T00:00:00+00:00</published>
		<updated>2024-01-12T00:00:00+00:00</updated>
		<link href="https://www.cs.cmu.edu/~csd-phd-blog/2023/baleen-ml-flash-caching/" type="text/html"/>
		<id>https://www.cs.cmu.edu/~csd-phd-blog/2023/baleen-ml-flash-caching/</id>
		<content type="html">&lt;!-- After filling in the above &quot;top-matter&quot;, as per instructions provided
in the `.md` file, you can write the main body of the blogpost here
onwards. Commonly used examples of syntax are shown below.

You can run `.&#x2F;local_server.sh` at the root of the repository to see
how the final blogpost looks in action. --&gt;
&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h1&gt;
&lt;p&gt;Large-scale storage is still dominated by hard disks (HDDs) as they are cost-effective. However, HDDs are limited to ~100 IOs per second. Thus, modern storage systems in datacenters widely rely on flash caches to absorb backend load and reduce the number of HDDs required to satisfy the IO workload.&lt;&#x2F;p&gt;
&lt;p&gt;While flash has orders of magnitude higher IOPS, it suffers from wearout as it is written to. 
Flash drives lifetime projections assume relatively low average write rates such as “three drive-writes per day (DWPD)”, meaning 3N TB of writes to a N TB flash drive each day. Flash drives with even lower write endurance (e.g., 1 DWPD) are priced correspondingly lower. Given that traditional cache management policies designed for dynamic random-access memory (DRAM) can incur writes exceeding 100 DWPD, there is a need for smart flash admission policies to filter the right items to be written into cache.&lt;&#x2F;p&gt;
&lt;p&gt;Machine learning (ML) policies have been proposed to improve upon historically popular policies, which include random admission and history-based policies that reject items without sufficient recent usage. However, caching is a challenging problem for ML to get right&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;pdl.cmu.edu&#x2F;PDL-FTP&#x2F;BigLearning&#x2F;2018MachineLearningCDNcache_HOTNETS.pdf&quot;&gt;[3]&lt;&#x2F;a&gt;. Furthermore, systems practitioners desire that policies also be understandable in addition to being performant&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;atc22-yang-tzu-wei.pdf&quot;&gt;[4]&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We decompose the flash caching problem into admission, prefetching, and eviction. This helps us align policy decisions to well-understood supervised ML techniques. We also co-design these components, as we show that a policy can have synergistic or antagonistic effects on other parts of the system.&lt;&#x2F;p&gt;
&lt;p&gt;The Baleen flash cache exploits a new cache residency model (which we call episodes) to improve ML training effectiveness. The episodes model also enables a new useful comparison point (OPT). Baleen focuses on optimizing for an end-to-end metric (HDD disk-head time) that balances IOPS and bandwidth, rather than hit rate. We find that a combination of ML-guided admission and ML-guided prefetching works best in reducing peak backend load.&lt;&#x2F;p&gt;
&lt;p&gt;Baleen reduces HDD peak load by 11.8% over state-of-the-art policies on seven recent real-world storage cluster traces collected over 3 years. This work is under submission.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;background-bulk-storage-systems&quot;&gt;Background: Bulk storage systems&lt;&#x2F;h1&gt;
&lt;p&gt;Bulk storage systems are relied on by hyperscalars to aggregate persistent
storage needs in data centers including blob storage and data warehouses
(such as HDFS&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;hadoop.apache.org&quot;&gt;[7]&lt;&#x2F;a&gt;). Users might not
even know they are using one, as such systems function quietly behind the scenes
at cloud computing platforms like Amazon Web Services, Google Cloud Platform and
Microsoft Azure. In this paper, we use Meta’s Tectonic&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;fast21-pan.pdf&quot;&gt;[2]&lt;&#x2F;a&gt; as an important
and representative example of a bulk storage system. Many other systems have a
similar design (e.g., Google’s Colossus&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;atc22-yang-tzu-wei.pdf&quot;&gt;[4]&lt;&#x2F;a&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;cloud.google.com&#x2F;blog&#x2F;products&#x2F;storage-data-transfer&#x2F;a-peek-behind-colossus-googles-file-system&quot;&gt;[5]&lt;&#x2F;a&gt;, YouTube&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;nsdi23-song-zhenyu.pdf&quot;&gt;[6]&lt;&#x2F;a&gt;). In Tectonic, as in other systems&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;cloud.google.com&#x2F;blog&#x2F;products&#x2F;storage-data-transfer&#x2F;a-peek-behind-colossus-googles-file-system&quot;&gt;[5]&lt;&#x2F;a&gt;[6], flash caches are used to reduce load on the backing HDDs and meet throughput requirements.&lt;&#x2F;p&gt;
&lt;p&gt;Accesses are made to byte ranges within blocks. Blocks are mapped to a location on backing HDDs, and subdivided into many smaller units called segments that can be individually cached (Tectonic has 8 MB blocks and 128 KB segments). Upon an access, the cache is checked for all segments needed to cover the request byte range. If any are missing, an IO is made to the backing store to fetch them, at which point they can be admitted into the cache.&lt;&#x2F;p&gt;
&lt;p&gt;The storage system has 10,000s of storage nodes independently serving requests. The ratio of backing HDD space : flash cache : DRAM cache is 37,800 : 40 : 1. We focus on the scope of an individual node.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bulk-storage-limited-by-disk-head-time&quot;&gt;Bulk storage limited by disk-head time&lt;&#x2F;h2&gt;
&lt;p&gt;At scale, hard disks (HDDs) remain the choice of backing store as they are cheaper by an order of magnitude per GB than SSDs&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20221004225419&#x2F;https:&#x2F;&#x2F;blocksandfiles.com&#x2F;2020&#x2F;08&#x2F;24&#x2F;10x-enterprise-ssd-price-premium-over-nearline-disk-drives&quot;&gt;[8]&lt;&#x2F;a&gt;. Newer HDDs offer increased storage density, resulting in shrinking IO capacity (IOPS and bandwidth) per GB as more GBs are served by the same disk head.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;baleen-ml-flash-caching&#x2F;disk-head-time_vs_access-size_simple.png&quot; alt=&quot;Fig 1: Disk-head Time consists of a seek &amp;amp; transfer time. This reflects disk-head times on our testbed.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;em&gt;Fig 1: &lt;b&gt;Disk-head Time&lt;&#x2F;b&gt; consists of a seek &amp; transfer time. This reflects disk-head times on our testbed.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Disk-head time on backing HDDs is a premium resource. The mechanical nature of HDDs results in a high, size-independent access time penalty (e.g., 10 ms) for positioning the read&#x2F;write head. With a high read rate (e.g., 5.5 ms per MB) and a maximum block size of 8 MB, a request could take 10 to 70 ms. In provisioning bulk storage, peak demand for disk-head time matters most.  If the system has insufficient IO capacity, requests queue up, and slowdowns occur. If sustained, clients retry requests and failures occur, affecting user experience. Thus, bulk storage IO requirements are defined by peak load, which in turn affects storage costs.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;flash-caches-absorb-backend-load-but-have-limited-write-endurance&quot;&gt;Flash caches absorb backend load but have limited write endurance&lt;&#x2F;h2&gt;
&lt;p&gt;Flash caching plays an important role in absorbing backend load, compensating for disk-head time limitations of the underlying HDDs. This setup enables resource-efficient storage for workloads that exceed the throughput requirements of HDDs but which are infeasible to store using flash alone. With the trends towards higher density HDDs and fewer bytes per HDD spindle, flash caches unlock more usable bytes per spindle.&lt;&#x2F;p&gt;
&lt;p&gt;Flash does not have access setup penalties, but does have wearout that translates into long-term average-write-rate limits. SSD manufacturers rate their drives’ endurance in terms of drive-writes per day (DWPD) over their warranty period.&lt;&#x2F;p&gt;
&lt;p&gt;Caching is an especially challenging workload for flash, since items will have widely varying lifetimes, resulting in a usage pattern closer to random I&#x2F;Os than large sequential writes. Items admitted together may not be evicted at the same time, worsening write amplification. Writing every miss into flash would cause it to wear out prematurely.&lt;&#x2F;p&gt;
&lt;p&gt;Flash caches leverage &lt;strong&gt;admission policies&lt;&#x2F;strong&gt; (APs) to decide if items should be inserted into the flash cache or discarded, and have simple eviction policies (Least Recently Used, First-In First-Out) to minimize write amplification&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;osdi20-berg.pdf&quot;&gt;[1]&lt;&#x2F;a&gt;. Like eviction policies, admission policies weigh the benefit of hits from new items against lost hits from evicted items. They must also weigh the write cost of admitting the new item against other past or future items. Policies have an admission threshold that can be varied to achieve the target flash write rate. We provide some examples.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CoinFlip (baseline)&lt;&#x2F;strong&gt; On a miss, segments for an access are either all admitted, or not at all, with probability 𝑝. This simple policy does not need tracking of past items seen.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;RejectX (baseline)&lt;&#x2F;strong&gt; rejects a segment the first &lt;em&gt;X&lt;&#x2F;em&gt; times it is seen. Past accesses are tracked using probabilistic data structures similar to Bloom filters. We use X = 1 and vary the window size of past accesses to achieve the desired write rate. Both Meta &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;osdi20-berg.pdf&quot;&gt;[1]&lt;&#x2F;a&gt; and Google &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;atc22-yang-tzu-wei.pdf&quot;&gt;[4]&lt;&#x2F;a&gt; used this prior to switching to more complex policies.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;ML admission policies&lt;&#x2F;strong&gt; use offline features to make decisions in addition to online features such as past access counts. A ML model can be trained offline based on a trace (as we do), or online using reinforcement learning.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;baleen-design&quot;&gt;Baleen Design&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;optimize-for-disk-head-time-not-hits-or-bandwidth&quot;&gt;Optimize for Disk-head time, not hits or bandwidth&lt;&#x2F;h2&gt;
&lt;p&gt;We propose that backing store load be measured using disk-head time (DT), which is a throughput metric that balances IOPS and bandwidth.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Definition&lt;&#x2F;strong&gt;: Disk-Head Time (DT) is the cost of serving a single request to the backend. For a single IO that fetches &lt;em&gt;n&lt;&#x2F;em&gt; bytes:&lt;&#x2F;p&gt;
&lt;p&gt;$$ DT(n) = SeekTime + TransferTime * n $$&lt;&#x2F;p&gt;
&lt;p&gt;Policies are then assessed in terms of Disk-Head Time saved, rather than
object-level hits (corresponding to IOPS) or byte-level hits (corresponding to 
bandwidth). Disk-Head Time can also be seen as a weighted sum of object-level
hits and byte-level hits.
We use Disk-Head Time to score episodes for OPT (our approximate optimal online
admission policy) and ultimately generate labels for training Baleen’s ML
admission policy. In training Baleen’s prefetcher, we use Disk-Head Time to
assess the benefit of prefetching for a particular episode.&lt;&#x2F;p&gt;
&lt;p&gt;System capacity, such as the number of backend servers, is provisioned to handle peak load in systems that need to meet realtime demand. Therefore, to reduce the backend size, one should minimize peak disk-head time. This introduces the need for scheduling (i.e., when to spend the flash write rate budget) to prioritize the admission of items that contribute to peak disk-head time. As explicitly optimizing for the peak introduces significant complexity, we leave that for future work. For Baleen, we design our methods to minimize average disk-head time, but show that they are successful in reducing peak disk-head time as well.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;decomposing-caching-into-admission-prefetching-and-eviction&quot;&gt;Decomposing caching into admission, prefetching and eviction&lt;&#x2F;h2&gt;
&lt;p&gt;We define the caching problem as determining which times we should fetch, admit and evict each segment in order to minimize the backend’s DT given a flash write rate limit.&lt;&#x2F;p&gt;
&lt;p&gt;We propose a heuristic decomposition of this problem into three sub-problems: admission, prefetching, and eviction. This makes it easier to reason about the optimal solutions to each sub-problem and the training and behavior of ML solutions for each part.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Admission:&lt;&#x2F;strong&gt; Whether to admit something into cache in anticipation of future hits that reduce disk-head time. We trade off the disk-head time saved against the write rate used from caching an item. We model admission as a binary classifier, where misses are admitted if the outout probability exceeds the policy threshold.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Prefetching:&lt;&#x2F;strong&gt; Whether to prefetch extra segments outside the current access range (which was a miss). We trade off disk-head time saved from hits on the first accesses against the additional time spent in cache, and for incorrect prefetches, the disk-head time wasted and the opportunity cost of the wasted flash write rate. We further decompose the prefetching problem into a) deciding what segments to prefetch and b) when to prefetch (whether the expected benefit exceeds the cost, taking into account the possibility of mispredictions)&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Eviction:&lt;&#x2F;strong&gt; Which segment in the cache to pick for eviction upon an admission. One can employ existing approaches for non-flash caches, including ML-based policies. We employ a simple eviction policy (in our case, Least Recently Used) as is used in production systems, leaving ML-based flash-aware eviction policies for future work.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;introducing-episodes-an-offline-model-for-flash-caching&quot;&gt;Introducing episodes: an offline model for flash caching&lt;&#x2F;h2&gt;
&lt;p&gt;We devised an offline model for flash caching for efficient evaluation of flash caching improvements, and to facilitate the training of ML-based policies. This model revolves around episodes, which are defined as:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Definition&lt;&#x2F;strong&gt; An &lt;strong&gt;episode&lt;&#x2F;strong&gt; is a sequence of accesses that would be hits (apart from the first access) if the corresponding item was admitted. It is defined on a block, and may span multiple segments. As shown in Fig 2, an episode’s size is the number of segments needed to cache it, and its timespan is the length of time between the first access of any segment and the last eviction of a segment.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;baleen-ml-flash-caching&#x2F;episode_with_segments.png&quot; alt=&quot;Fig 2: Episodes span space (measured in segments) in addition to time. An episode’s size is the smallest number of segments required to be admitted to get all possible hits within an episode. OPT-Range is (1,3) and (2,3) respectively.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;em&gt;Fig 2: Episodes span space (measured in segments) in addition to time. An episode’s size is the smallest number of segments required to be admitted to get all possible hits within an episode. OPT-Range is (1,3) and (2,3) respectively.&lt;&#x2F;p&gt;&lt;&#x2F;em&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;baleen-ml-flash-caching&#x2F;episode.png&quot; alt=&quot;Fig 3: An episode is a group of accesses corresponding to a block’s residency. Accesses (in blue) are grouped into two episodes as the interarrival time (in red) exceeds the assumed eviction age.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;em&gt;Fig 3: An episode is a group of accesses corresponding to a block’s residency. Accesses (in blue) are grouped into two episodes as the interarrival time (in red) exceeds the assumed eviction age.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We generate episodes by exploiting the model of a LRU (Least Recently Used) cache as evicting items a constant logical time (eviction age) after the last access. In a LRU cache, the eviction age is the logical time between an item’s last access &amp;amp; eviction. As shown in Fig 3, we group accesses into episodes such that all inter-arrival times within episodes are no larger than the assumed eviction age.&lt;&#x2F;p&gt;
&lt;p&gt;Episodes provide a direct mapping to the costs and benefits associated with an admission, and which corresponds directly to the decisions actually being made by admission policies. These benefits and costs are associated with a item’s entire lifespan in cache, and are not obvious from looking at a stream of individual accesses. Moreover, with flash caching, it is optimal to admit as early as possible in the episode, given that the flash writes required are a fixed cost. By shifting the mental model from interdependent accesses to independent episodes, we can reason about decisions more easily.&lt;&#x2F;p&gt;
&lt;p&gt;Decisions on episodes can be made independent by assuming a constant eviction age. This also allows decisions to be made in parallel. The added pressure on cache space via an admission is accounted for via downwards pressure on the eviction age. We determine an appropriate eviction age using simulations that measure the average eviction age.&lt;&#x2F;p&gt;
&lt;p&gt;The episode model also allows for an efficient offline analytical analysis of policies via Little’s Law. Given the arrival rate and assumed eviction age, we can estimate the cache size required, and set eviction age such that the analytical cache size is equal to the cache size constraint. While this is much more efficient than an online simulation and is useful to explore a greater range of parameters than is possible with online simulation, the numbers will differ from simulated ones as the cache size constraint is not enforced all the time, only as a long-term average.&lt;&#x2F;p&gt;
&lt;p&gt;Admission policies can be viewed as partitioning these episodes into those admitted and discarded. This can be done via scoring episodes and ranking them by score.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;baleen-system-architecture&quot;&gt;Baleen System Architecture&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;baleen-ml-flash-caching&#x2F;architecture.png&quot; alt=&quot;Fig 4: Baleen System Architecture.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;em&gt;Fig 4: Baleen System Architecture.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We describe Baleen’s architecture in terms of what happens at training time and when deployed with a CacheLib[&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;osdi20-berg.pdf&quot;&gt;[1]&lt;&#x2F;a&gt; implementation. At training time, episodes are generated and used to train Baleen’s ML admission and ML prefetching policies. At deployment time, the trained models are supplied to CacheLib which uses them to make decisions on the fly.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;opt-approximates-optimal-online-admission-policy&quot;&gt;OPT approximates optimal online admission policy&lt;&#x2F;h2&gt;
&lt;p&gt;We devise an online admission policy, &lt;strong&gt;OPT&lt;&#x2F;strong&gt;, that we train Baleen’s ML policy to imitate. In OPT, first, each block’s accesses are grouped into episodes using an assumed eviction age. Second, all episodes are scored using the equation below and sorted. Last, the maximum number of episodes are admitted such that the total flash writes required do not exceed the write rate budget. During online simulation, accesses will be admitted if they belong to episodes that were marked as admitted during the offline process.&lt;&#x2F;p&gt;
&lt;p&gt;$$ Score(Episode)= \frac{DTSaved(Episode)}{Size(Episode)} $$&lt;&#x2F;p&gt;
&lt;h2 id=&quot;training-baleen-to-imitate-opt&quot;&gt;Training Baleen to imitate OPT&lt;&#x2F;h2&gt;
&lt;p&gt;We use OPT’s decisions as binary labels for training Baleen. Training examples are added for the first k (k = 6) accesses of each episode (to avoid biasing the training set towards popular but easy episodes). Features include offline metadata provided by the bulk storage system (which help identify which application the request originates from) and online history-based counts (how many hits the object has received in the last 1,2,3,4,5,6 hours).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;training-baleen-to-predict-what-and-when-to-prefetch&quot;&gt;Training Baleen to predict what and when to prefetch&lt;&#x2F;h2&gt;
&lt;p&gt;By default, on a miss, the smallest IO that covers all missed segments is made, i.e., no prefetching occurs. It is possible to extend this IO and preemptively admit more segments. If done correctly, this reduces the total no of IOs needed and thus reduces Disk-head Time.&lt;&#x2F;p&gt;
&lt;p&gt;Baleen has two prefetching models: ML-Range, and ML-When.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;learning-what-to-prefetch-ml-range-learns-from-opt-range&quot;&gt;Learning what to prefetch: ML-Range learns from OPT-Range&lt;&#x2F;h2&gt;
&lt;p&gt;OPT-Range is the minimal range of segments that will cover all accesses in an episode. Using the episodes model, we generate OPT-Range for each episode and use these as labels for ML-Range.&lt;&#x2F;p&gt;
&lt;p&gt;ML-Range is a ML model that predicts a range of segments for prefetching. We use the same features as the ML admission model, but add size-related features (access start index, access end index, access size). We train two regression models to predict the episode range start and end. Each episode is represented once in the training data, with only episodes that meet the score cutoff for the target write rate included&lt;&#x2F;p&gt;
&lt;h2 id=&quot;learning-when-to-prefetch-ml-when&quot;&gt;Learning when to prefetch: ML-When&lt;&#x2F;h2&gt;
&lt;p&gt;Fetching insufficient segments results in minimal or no Disk-head Time reduction. On the other hand, fetching excess segments results in a high write rate. To balance these tradeoffs, we need to know our confidence in our range prediction.&lt;&#x2F;p&gt;
&lt;p&gt;Mispredictions by the ML admission policy and in ML-Range can easily cause prefetching to hurt instead of help. In reality, the expected benefit will be lower than OPT prefetching and the cost can only be higher. The disk-head time saved from prefetching ML-Range may not be realized. Moreover, prefetching mispredictions are costly in terms of disk-head time consumed to fetch unused segments and the opportunity cost of flash writes used to store them. ML-When aims to address this and exclude epsiodes that do not have a high probability of benefiting from prefetching. 
The exact equations are provided in our paper.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;evaluation&quot;&gt;Evaluation&lt;&#x2F;h1&gt;
&lt;p&gt;We evaluate Baleen using a testbed and a simulator. We validate both with counters from production deployments. Each node in our testbed has a 400 GB flash drive and 2 4TB HDDs.&lt;&#x2F;p&gt;
&lt;p&gt;We report results on 7 Meta production traces collected in 2019, 2021 and 2023 and take an average across the traces.
These traces show week-long workloads on 7 Tectonic clusters from 3 different years,
with each cluster serving the storage needs of an entire data center&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;fast21-pan.pdf&quot;&gt;[2]&lt;&#x2F;a&gt;.
Each trace represents 7 days of production traffic from a single
cluster (except for Region3, which has 3 days), with traffic sampled at every
node (each cluster has thousands of nodes) and later aggregated into a trace.
The Region1 and Region2 traces were recorded from different clusters over the same 7 days in Oct 2019, while the Region3 trace was recorded from another cluster over 3 days in Sep 2019. Region4 was recorded over 7 days in Oct 2021, and the remaining traces (Region5, Region6, Region7) were collected in Mar 2023.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;baleen-ml-flash-caching&#x2F;peak-st-ratio_wr-34-01.png&quot; alt=&quot;Fig 5: Baleen reduces Peak Disk-head Time (DT) by an average of 11.8% over the best non-ML policy (RejectX), and 18.6% over random admission on 7 production traces from Meta under flash write rate constraints.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;em&gt;Fig 5: Baleen reduces Peak Disk-head Time (DT) by an average of 11.8% over the best non-ML policy (RejectX), and 18.6% over random admission on 7 production traces from Meta under flash write rate constraints.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Fig 5 shows Baleen reduces Peak DT over RejectX by an average of 11.8% across all traces.
In our paper, we show this ranges from 4.8% to 22.6% across the 7 traces,
with 3 regions deriving most of their gains from prefetching.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;baleen-ml-flash-caching&#x2F;peak-st-ratio_csize.png&quot; alt=&quot;Fig 6a: Baleen delivers improvements at higher cache sizes.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;em&gt;6a) Cache Sizes&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;baleen-ml-flash-caching&#x2F;peak-st-ratio_wr.png&quot; alt=&quot;Fig 6b: Baleen delivers improvements at higher cache sizes.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;em&gt;6b) Write Rates&lt;&#x2F;em&gt;&lt;br&gt;
&lt;em&gt;Fig 6: Baleen continues to deliver improvements at higher cache sizes and write rates.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Fig 6 shows that the benefits of Baleen are consistent at higher cache sizes and write rates, with Baleen enabling a reduction in cache size by 55% while keeping
the same Peak DT as RejectX, or alternatively a reduction in Peak DT equivalent
to a 4X increase in cache size. As expected, increasing write rate or cache size has diminishing returns in reducing Peak DT. Also, the different admission policies (without prefetching) start to converge, indicating that admission by itself is insufficient to drive further reductions in Peak DT. We provide graphs for all 7 traces in our
paper.&lt;&#x2F;p&gt;
&lt;p&gt;Further results are available in our paper, such as:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Prefetching should be selective and in tandem with admission&lt;&#x2F;strong&gt;
We show both ML-Range and ML-When are effective in reducing Peak DT over static baselines, and contribute to Baleen’s robustness across the multiple traces.
We also show that prefetching must be paired with a good admission policy; if not, the same prefetching policy can hurt rather than help.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Optimizing the right metric: Peak DT&lt;&#x2F;strong&gt; We show how optimizing for IO
hit ratio can be misleading, as doing so is optimal for reducing seeks, not
Disk-head Time.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Validation of simulator and testbed.&lt;&#x2F;strong&gt; We validated Baleen on our simulator
against Baleen on our testbed. We took the additional step of showing that our
testbed is consistent with production counters.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Trace analysis&lt;&#x2F;strong&gt; We show distributions for block popularity, interarrival times, access sizes and the compulsory miss trace, one-hit-wonder trace (fractions of blocks
with no reuse) and Admit-All flash write rate.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;In our paper, we described a few lessons gleaned from 3 years of deploying ML
in production caches at Meta. These lessons were that 1) optimizing the wrong metric is an easy misstep, 2) ML model performance does not always translate to production system performance, 3) to rethink the use of DRAM in flash caching, and that 4) ML-based caching should aim for encapsulation of ML, caching, and storage.
To read more, please see Section 6 (Lessons from deploying ML in production) of our paper.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h1&gt;
&lt;p&gt;Baleen is a flash cache that uses ML to guide both prefetching and cache admission, reducing peak storage backend load on real workload traces from Meta. Baleen’s design arose from a number of false-step lessons and a cache residency (episodes) formulation that improves training effectiveness, provides an ideal (OPT) target, and exposed the particular value of ML-guided prefetching. As such, Baleen is an important step forward in flash caching for disk-based storage systems.&lt;&#x2F;p&gt;
&lt;p&gt;More details are available in our paper, which &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;conference&#x2F;fast24&#x2F;presentation&#x2F;wong&quot;&gt;has been accepted to FAST 2024&lt;&#x2F;a&gt;. Please
direct any correspondence to &lt;a href=&quot;mailto:wonglkd@cmu.edu&quot;&gt;Daniel Wong&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;acknowledgements&quot;&gt;Acknowledgements&lt;&#x2F;h1&gt;
&lt;p&gt;This post is based on the paper &lt;em&gt;Baleen: ML Admission &amp;amp; Prefetching for Flash Caches&lt;&#x2F;em&gt;. I would like to thank my collaborators and the CacheLib and Tectonic teams at Meta: Hao Wu (Meta), Carson Molder (UT Austin), Sathya Gunasekar (Meta), Jimmy Lu (Meta), Snehal Khandkar (Meta), Abhinav Sharma (Meta), Daniel S. Berger (Microsoft Research &amp;amp; University of Washington), Nathan Beckmann (CMU), and Greg Ganger (CMU).
I would also like to thank the reviewers of this post: George Amvrosiadis, Rashmi Vinayak, and Thomas Kim.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;references&quot;&gt;References&lt;&#x2F;h1&gt;
&lt;ol&gt;
&lt;li&gt;Benjamin Berg, Daniel S Berger, Sara McAllister, Isaac Grosof, Sathya Gunasekar, Jimmy Lu, Michael Uhlar, Jim Carrig, Nathan Beckmann, Mor Harchol-Balter, et al. &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;osdi20-berg.pdf&quot;&gt;The CacheLib caching engine: Design and experiences at scale.&lt;&#x2F;a&gt; In 14th USENIX Symposium on Operating Systems Design and Implementation (OSDI 20), 2020.&lt;&#x2F;li&gt;
&lt;li&gt;Satadru Pan, Theano Stavrinos, Yunqiao Zhang, Atul Sikaria, Pavel Zakharov, Abhinav Sharma, Mike Shuey, Richard Wareing, Monika Gangapuram, Guanglei Cao, et al. &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;fast21-pan.pdf&quot;&gt;Facebook’s Tectonic filesystem: Efficiency from exascale.&lt;&#x2F;a&gt; In 19th USENIX Conference on File and Storage Technologies (FAST 21), 2021&lt;&#x2F;li&gt;
&lt;li&gt;Daniel S Berger. &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;pdl.cmu.edu&#x2F;PDL-FTP&#x2F;BigLearning&#x2F;2018MachineLearningCDNcache_HOTNETS.pdf&quot;&gt;Towards lightweight and robust machine learning for CDN caching.&lt;&#x2F;a&gt; In Proceedings of the 17th ACM Workshop on Hot Topics in Networks (HotNets), 2018.&lt;&#x2F;li&gt;
&lt;li&gt;Tzu-Wei Yang, Seth Pollen, Mustafa Uysal, Arif Merchant, and Homer Wolfmeister. &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;atc22-yang-tzu-wei.pdf&quot;&gt;CacheSack: Admission optimization for google datacenter flash caches.&lt;&#x2F;a&gt; In USENIX Annual Technical Conference (USENIX ATC 22), 2022.&lt;&#x2F;li&gt;
&lt;li&gt;Dean Hildebrand and Denis Serenyi. &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;cloud.google.com&#x2F;blog&#x2F;products&#x2F;storage-data-transfer&#x2F;a-peek-behind-colossus-googles-file-system&quot;&gt;Colossus under the hood: a peek into google’s scalable storage system&lt;&#x2F;a&gt;, 2021&lt;&#x2F;li&gt;
&lt;li&gt;Zhenyu Song, Kevin Chen, Nikhil Sarda, Deniz Altınbüken, Eugene Brevdo, Jimmy Coleman, Xiao Ju, Pawel Jurczyk, Richard Schooler, and Ramki Gummadi. &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;nsdi23-song-zhenyu.pdf&quot;&gt;Halp: Heuristic aided learned preference eviction policy for youtube content delivery network.&lt;&#x2F;a&gt; In 20th USENIX Symposium on Networked Systems Design and Implementation (NSDI 23), 2023.&lt;&#x2F;li&gt;
&lt;li&gt;Apache Software Foundation. (2010). &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;hadoop.apache.org&quot;&gt;Hadoop&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20221004225419&#x2F;https:&#x2F;&#x2F;blocksandfiles.com&#x2F;2020&#x2F;08&#x2F;24&#x2F;10x-enterprise-ssd-price-premium-over-nearline-disk-drives&quot;&gt;Chris Mellor. Enterprise ssds cost ten times more than nearline disk drives.&lt;&#x2F;a&gt; Accessed: 2022-10-04.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Mimir: Finding cost-efficient storage configurations in the public cloud</title>
		<published>2023-12-15T00:00:00+00:00</published>
		<updated>2023-12-15T00:00:00+00:00</updated>
		<link href="https://www.cs.cmu.edu/~csd-phd-blog/2023/mimir/" type="text/html"/>
		<id>https://www.cs.cmu.edu/~csd-phd-blog/2023/mimir/</id>
		<content type="html">&lt;p&gt;In today’s landscape of diverse public cloud providers like AWS, Microsoft Azure, and Google Cloud Platform, organizations are increasingly turning to cloud computing with pay-as-you-go pricing models. &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.cloudzero.com&#x2F;blog&#x2F;cloud-computing-statistics&quot;&gt;Many businesses&lt;&#x2F;a&gt; are adopting public cloud services to simplify data center management or leverage the scalability and elasticity offered by these providers.&lt;&#x2F;p&gt;
&lt;p&gt;A pressing question that accompanies this shift to public cloud adoption is how to optimize the overall cost of utilizing cloud resources. While researchers have recently delved into cost optimization for virtual machine (VM) instances used in computational workloads, there has been limited focus on optimizing storage choices. Frequently, companies require high-performance storage clusters to efficiently operate their workloads in public clouds. However, the costs associated with these storage clusters cannot be underestimated, given that VMs and block storage options can strain budgets.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Thus, companies need to carefully select resources for storage clusters to reduce their Total Cost of Ownership.&lt;&#x2F;strong&gt; If organizations opt for only inexpensive resources to minimize costs, their storage clusters may fail to meet performance requirements. Conversely, selecting solely high-performance Virtual Machines and storage types can lead to substantial spending compared to an optimized resource selection approach.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Nonetheless, choosing the cost-efficient set of resources for storage clusters in public clouds remains a challenging task and there is no existing system that helps this provisioning decision.&lt;&#x2F;strong&gt; The multitude of available VM and storage types adds complexity. For instance, AWS alone offers over a &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.amazonaws.cn&#x2F;en&#x2F;ec2&#x2F;instance-types&#x2F;&quot;&gt;hundred different instance types&lt;&#x2F;a&gt; and various block storage options, including &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;AWSEC2&#x2F;latest&#x2F;UserGuide&#x2F;storage-optimized-instances.html&quot;&gt;locally attached (LocalSSD)&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;AWSEC2&#x2F;latest&#x2F;UserGuide&#x2F;ebs-volume-types.html&quot;&gt;remotely disaggregated (EBS)&lt;&#x2F;a&gt;. Each resource option comes with &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;AWSEC2&#x2F;latest&#x2F;UserGuide&#x2F;ebs-volume-types.html&quot;&gt;distinct pricing and performance models&lt;&#x2F;a&gt;, and the performance also varies based on workload characteristics. This necessitates a deep understanding of both cloud resource attributes and workload characteristics to make informed selections. If we factor in the potential use of heterogeneous storage cluster configurations, the problem’s search space becomes significantly larger and more intricate.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;To address these challenges, we introduce Mimir, a resource auto-selection tool designed to identify the most cost-efficient set of resources for storage clusters in public clouds, all while meeting specified performance requirements.&lt;&#x2F;strong&gt; Our system assesses all available VM types, block storage options, and even combinations of these options (heterogeneous configurations) to determine the optimal solution. &lt;strong&gt;As a result, Mimir can yield storage cluster configurations up to 81% cheaper than those generated by the current state-of-the-art resource auto-selection tools.&lt;&#x2F;strong&gt; In our evaluations, we demonstrate that Mimir can also serve as a resource selector for mixed workloads (comprising multiple workloads with distinct characteristics) and dynamic workloads, efficiently identifying cost-effective cluster configurations within a reasonable time.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;challenges-navigating-diverse-resource-options-and-heterogeneity&quot;&gt;&lt;strong&gt;Challenges: navigating diverse resource options and heterogeneity&lt;&#x2F;strong&gt;&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;challenge-1-diverse-storage-options-characteristics&quot;&gt;&lt;strong&gt;Challenge 1: diverse storage options’ characteristics&lt;&#x2F;strong&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Public cloud providers have established unique performance characteristics for their block storage options, setting them apart from traditional solutions like SSDs and HDDs. Workload attributes such as access pattern (random&#x2F;sequential), read ratio, and I&#x2F;O unit size can exert significant influence on the performance of cloud block storage. Overlooking these factors or assuming that cloud storage behaves analogously to traditional storage can result in erroneous storage cluster configurations. To illustrate this, we present two examples showcasing how workload characteristics impact storage performance.&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;center&quot;&gt;&lt;img src=&quot;.&#x2F;storage-io.png&quot; alt=&quot;alt text&quot; &#x2F;&gt;&lt;&#x2F;th&gt;&lt;th align=&quot;center&quot;&gt;&lt;img src=&quot;.&#x2F;storage-rw.png&quot; alt=&quot;alt text&quot; &#x2F;&gt;&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;(a) by I&#x2F;O unit size&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;(b) by read ratio&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;&lt;strong&gt;Fig. 1:&lt;&#x2F;strong&gt; Performance characteristics of public cloud storage volume types by (a) I&#x2F;O unit size and (b) workload read ratio. In (a), both volume types have throughput limits defined by AWS (horizontal lines).&lt;&#x2F;p&gt;
&lt;p&gt;In our tests, we employed the &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;fio.readthedocs.io&#x2F;en&#x2F;latest&#x2F;fio_doc.html&quot;&gt;fio benchmark&lt;&#x2F;a&gt; to assess cloud block storage performance on AWS, using three different storage types: local NVMe SSD, remote SSD (gp2), and remote HDD (st1). We varied access patterns, read ratios, and I&#x2F;O unit sizes. Fig. 1 provides insights into the characteristics of 1 TiB gp2 and 1 TiB st1 volumes, each having performance of 3000 IOPS and 40 MiB&#x2F;s following the performance model provided by AWS, along with local SSD attached to i3.xlarge.&lt;&#x2F;p&gt;
&lt;p&gt;Fig. 1(a) shows &lt;em&gt;how performance characteristics vary with I&#x2F;O unit size and access pattern for each storage type&lt;&#x2F;em&gt;. For gp2 performance, which is defined in IOPS, increasing the I&#x2F;O unit size results in higher throughput, eventually reaching the maximum limit set by AWS. Also, it remains consistent regardless of the access pattern. In contrast, st1’s performance, defined in MiB&#x2F;s, should ideally maintain a throughput of 40 MB&#x2F;s regardless of the I&#x2F;O unit size. However, it exhibits reduced throughput for workloads featuring random access patterns and I&#x2F;O units smaller than 1 MiB, different to the behavior observed with sequential accesses.&lt;&#x2F;p&gt;
&lt;p&gt;In Fig. 1(b), we examine the &lt;em&gt;impact of read ratios on each volume type’s throughput&lt;&#x2F;em&gt;. EBS volumes remain unaffected by the read ratio, as it lies outside their performance models. Conversely, local SSD exhibits considerably higher throughput than EBS and is notably influenced by the read ratio.&lt;&#x2F;p&gt;
&lt;p&gt;As highlighted above, in public clouds, storage performance characteristics differ from traditional storage. For instance, remote SSD throughput remains consistent regardless of read-to-write ratios, while performance of different storage options changes differently for I&#x2F;O unit size changes. This can confuse users configuring cloud storage clusters, as they may erroneously assume that cloud storage exhibit conventional storage behavior. However, by accurately considering these pricing and performance models, &lt;strong&gt;Mimir can mathematically deduce performance specifications from allocated resources, aiding in cost-efficient cloud storage configurations that meet performance needs&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;It is worth to note that local SSD’s highest throughput in Fig. 1 does not always make it the best choice. Throughput of each storage option varies with its configuration; larger gp2 and st1 volumes can outperform local SSD. st1 and gp2 come with lower per-byte costs, making them cost-efficient alternatives when high throughput is not crucial.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;challenge-2-heterogeneity-is-important-for-cost-efficiency&quot;&gt;&lt;strong&gt;Challenge 2: heterogeneity is important for cost-efficiency&lt;&#x2F;strong&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;One easy way of selecting resources for a storage cluster in the public cloud is configuring a homogeneous storage cluster by using a single storage option.
However, we found that there is no single storage option that is the most cost-efficient for every workload, and sometimes, even a mix of storage options is needed to minimize the cost.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;.&#x2F;motiv.png&quot; alt=&quot;alt text&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Fig. 2:&lt;&#x2F;strong&gt; No volume type is most cost-efficient for every workload, and a mix of volume types may be the most cost-effective option.&lt;&#x2F;p&gt;
&lt;p&gt;Fig. 2 demonstrates the need to consider various volume types and configurations for selecting a cost-efficient Virtual Storage Cluster (VSC) configuration. For each of the three workloads, it shows the cost for the best VSC configuration under three constraints: using only local SSD volume types, only remote storage (EBS) volume types, and arbitrary mixes of both.&lt;&#x2F;p&gt;
&lt;p&gt;For Workload 1, which demands high storage throughput per GB of data, opting for EBS volume types leads to over-provisioning capacity, making it an expensive choice due to the 3 IOPS per provisioned-GB limit. Conversely, Workload 2, with lower storage throughput requirements, renders local SSD an expensive option due to over-provisioning storage performance. Workload 3 combines varying performance needs, necessitating a mix of storage options to minimize costs.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Therefore, it is crucial to consider a heterogeneous VSC configuration for the cost-efficiency.&lt;&#x2F;strong&gt; However, this introduces complexity, making it impractical to explore the search space using naive methods. So users can use Mimir as a solution to efficiently navigate this complex search space by using dynamic programming and integer-linear programming.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;mimir-resource-auto-selector-for-storage-cluster-in-public-clouds&quot;&gt;&lt;strong&gt;Mimir: resource auto-selector for storage cluster in public clouds&lt;&#x2F;strong&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;To tackle these challenges, we introduce Mimir, a resource auto-selector that identifies the cost-efficient set of VMs and storage volumes for a storage cluster. Mimir takes into account workload characteristics (such as read&#x2F;write request ratio and data access locality) and user-defined requirements (including request rate and capacity). Next, we will provide an overview of Mimir’s workflow and delve into our main optimization algorithm.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;mimir-design-and-workflow&quot;&gt;&lt;strong&gt;Mimir design and workflow&lt;&#x2F;strong&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Fig. 3 outlines Mimir’s workflow, which begins by inputting characteristics from multiple workloads requiring cluster storage. Each storage cluster’s workload profiler profiles these attributes, and the Resource Profiler assesses them to determine resource needs for cost-effective cloud operations. This involves resource utilization profiling using micro-benchmarks, considering given data access patterns like request rate, access locality, and read&#x2F;write ratios. The Resource Predictor uses this resource profiling data to identify efficient container sizes (i.e., storage&#x2F;network bandwidth, CPU count, memory) for each workload, as Mimir utilizes containers to run multiple storage servers in the same VM with resource isolation. Finally, the VSC Cost Optimizer combines these insights with the public cloud’s cost model to optimize the Virtual Storage Cluster (VSC) configuration for the distributed storage system.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;.&#x2F;mimir_design.png&quot; alt=&quot;alt text&quot; &#x2F;&gt;
&lt;strong&gt;Fig. 3:&lt;&#x2F;strong&gt; Mimir’s workflow for optimizing the price of public cloud resources. Initially, Mimir profiles the provided workloads, learning the precise resource requirements (such as CPU and memory). Using this trained module and a cost model encompassing public cloud resources, the VSC Cost Optimizer then identifies the most cost-efficient Virtual Storage Cluster (VSC) configuration.&lt;&#x2F;p&gt;
&lt;p&gt;Mimir assumes that users provide or profile the workload characteristics, which the system uses as input for its optimization process. This modular approach makes Mimir adaptable to any storage system capable of profiling sufficient workload information. Next, we provide a brief overview of the optimization algorithm used by Mimir to minimize costs for the given workload characteristics. Further details regarding other components, such as the Resource Profiler and Resource Predictor, can be found in &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;abs&#x2F;10.1145&#x2F;3579370.3594776&quot;&gt;our paper&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;optimization-algorithm-dynamic-programming&quot;&gt;&lt;strong&gt;Optimization algorithm: dynamic programming&lt;&#x2F;strong&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;The VSC Cost Optimizer addresses the following question: &lt;em&gt;What resource configuration minimizes costs while meeting performance requirements and accommodating storage workload characteristics?&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In this optimization problem, we identified an optimal substructure property. This means that if Mimir determines the most cost-efficient virtual storage cluster configuration for the given workloads, then any subset of storage servers from the entire cluster (a sub-cluster) must also represent the cost-efficient configuration for the workloads running on that specific sub-cluster.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;.&#x2F;dynamic_programming.png&quot; alt=&quot;alt text&quot; &#x2F;&gt;
&lt;strong&gt;Fig. 4:&lt;&#x2F;strong&gt; Mimir’s optimization problem has an optimal substructure property. If we find the most cost-efficient configuration for the entire virtual storage cluster, then any sub-cluster of that configuration must also be cost-efficient for the portion of data stored within that sub-cluster.&lt;&#x2F;p&gt;
&lt;p&gt;Figure 4 exemplifies the optimal substructure property. Suppose Machines 1-4 represent the most cost-efficient VSC configuration for a given workload. We contend that any sub-cluster should also be the most cost-efficient for the portion of the workload it handles. To prove this, we use a proof by contradiction. Let’s assume that Machines 1 and 2 are not the most cost-efficient sub-cluster configuration for 3&#x2F;10 of the workload. This would imply the existence of another sub-cluster (in this case, Machine 5) that’s cheaper than Machines 1 and 2. However, this contradicts the fact that Machines 1-4 (total VSC cost: $28) constitute the most cost-efficient VSC configuration for the entire workload, given that a cheaper configuration involving Machines 3-5 (total VSC cost: $26) exists.&lt;&#x2F;p&gt;
&lt;p&gt;Based on the optimal substructure property, we use dynamic programming to break down a large search space into manageable segments. For a more in-depth understanding of our approach, including how we use mixed-integer programming for the base case and how Mimir integrates other components (e.g., resource profiler, resource predictor, and cost model) into its optimization algorithm, please refer to our paper.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;mimir-can-find-up-to-81-cheaper-storage-cluster-over-sota&quot;&gt;&lt;strong&gt;Mimir can find up to 81% cheaper storage cluster over SOTA&lt;&#x2F;strong&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;We evaluated Mimir using Apache BookKeeper as the distributed storage backend and six different &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;conference&#x2F;fast20&#x2F;presentation&#x2F;cao-zhichao&quot;&gt;Meta’s RocksDB (MR) key-value workloads&lt;&#x2F;a&gt;.
The results of our evaluation demonstrate significant cost savings achieved by Mimir compared to state-of-the-art solutions, showing its ability to consider a wide range of volume types. We compared Mimir to three baseline configurations, each focusing on a limited subset of instance or storage types, in contrast to Mimir’s comprehensive consideration of all instance and block storage types:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;i3.xlarge-only:&lt;&#x2F;strong&gt; The simplest way to configure a VSC is using a single instance type (storage-optimized instance, i3.xlarge) and determining the number of instances based on the storage server performance.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Mimir-LocalOnly:&lt;&#x2F;strong&gt; Another way is to use only instance types that have local SSDs, including some compute or memory optimized instance types like m5d, c5d, and r5d.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Mimir-EBSonly&#x2F;OptimusCloud-like:&lt;&#x2F;strong&gt; Yet another way of configuring VSC is using only EBS volumes that can persist data independently from the instance status, but if the workload requires high-performance, it can be more expensive
than local SSD. &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;conference&#x2F;atc20&#x2F;presentation&#x2F;mahgoub&quot;&gt;OptimusCloud&lt;&#x2F;a&gt;, the previous work we consider as the state-of-the-art, restricts the volume type to EBS volumes because of their persistent nature, but our results show that this approach is often much more costly.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;img src=&quot;.&#x2F;evaluation.png&quot; alt=&quot;alt text&quot; &#x2F;&gt;
&lt;strong&gt;Fig. 5:&lt;&#x2F;strong&gt; The cost-efficiency analysis of the optimization results of the workloads of Meta’s RocksDB key-value workloads. Throughput-intensive workloads (MR-A,C,E,F) prefer local SSD as its storage type. In contrast, other
workloads (MR-B,D) that do not require high throughput prefer EBS volume to local SSD.&lt;&#x2F;p&gt;
&lt;p&gt;Fig. 5 shows the VSC costs of the most cost-efficient VSC configurations under different resource constraints. Overall, Mimir successfully identifies the most cost-efficient VSC configuration for any workload in Fig. 5, and achieves up to 81% cost savings compared to the &lt;em&gt;OptimusCloud-like&lt;&#x2F;em&gt; baseline. We also demonstrate that depending on the workload characteristics, different workloads prefer different storage types to store data cost-efficiently.&lt;&#x2F;p&gt;
&lt;p&gt;For instance, MR-D, a capacity-intensive workload, does not require high performance. Thus, local SSD proves costly as it under-utilizes its storage bandwidth, and gp2’s throughput (3 IOPS per provisioned GiB) suffices for MR-D.&lt;&#x2F;p&gt;
&lt;p&gt;Conversely, MR-F, with the second highest throughput needs among the six workloads, benefits from local SSD, making Mimir-LocalOnly more cost-efficient than Mimir-EBSonly. Interestingly, for MR-F, compute-optimized instance types like c5d are more economical than storage-optimized i3.xlarge. This is because MR-F demands high computing power for its high data request rate. This evaluation implies that not only considering various storage options, but also selecting the right instance type is important.&lt;&#x2F;p&gt;
&lt;p&gt;Our paper also covers additional evaluations, including the optimization overhead and Mimir’s effectiveness for dynamic workloads. For comprehensive details, please refer to our research paper.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;&lt;strong&gt;Conclusion&lt;&#x2F;strong&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Mimir finds the cost-efficient virtual storage cluster configurations for distributed storage backends.
By using provided workload information and performance requirements, Mimir predicts resource requirements and explores the complex, heterogeneous set of block storage offerings to identify the lowest cost VSC configuration that satisfies the customer’s need.
Experiments show that no single allocation type is best for all workloads and that a mix of allocation types is the best choice for some workloads.
Compared to a state-of-the-art approach, Mimir finds the VSC configurations that satisfy requirements at up to 81% lower cost for Meta’s RocksDB workloads.&lt;&#x2F;p&gt;
&lt;p&gt;You can find more detailed information in our &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;abs&#x2F;10.1145&#x2F;3579370.3594776&quot;&gt;published paper&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Transfer Learning within a Heterogeneous Graph</title>
		<published>2023-10-31T00:00:00+00:00</published>
		<updated>2023-10-31T00:00:00+00:00</updated>
		<link href="https://www.cs.cmu.edu/~csd-phd-blog/2023/ktn/" type="text/html"/>
		<id>https://www.cs.cmu.edu/~csd-phd-blog/2023/ktn/</id>
		<content type="html">&lt;h3 id=&quot;can-we-transfer-knowledge-between-different-data-types-using-their-connectivity-information&quot;&gt;Can we transfer knowledge between different data types using their connectivity information?&lt;&#x2F;h3&gt;
&lt;p&gt;Ecosystems in industry are commonly composed of various data types in terms of data modalities or feature distributions. &lt;strong&gt;Heterogeneous graphs&lt;&#x2F;strong&gt; (HGs) present these multimodal data systems in a unified view by defining multiple types of nodes and edges — for instance, e-commerce networks with (&lt;em&gt;user, product, review&lt;&#x2F;em&gt;) nodes or video platforms with (&lt;em&gt;channel, user, video, comment&lt;&#x2F;em&gt;) nodes. &lt;strong&gt;Heterogeneous graph neural networks&lt;&#x2F;strong&gt; (HGNNs) learn node embeddings, which summarize each node’s heterogeneous local structure into a vector. Unfortunately, there is a &lt;strong&gt;label imbalance&lt;&#x2F;strong&gt; issue between different node types in real-world HGs. For instance, publicly available content node types such as product nodes are abundantly labeled, whereas labels for user or account nodes may not be available due to privacy restrictions. Because of this, label-scarce node types cannot exploit HGNNs, hampering the broader applicability of HGNNs.&lt;&#x2F;p&gt;
&lt;p&gt;In this blog, we introduce how to pre-train an HGNN model on label-abundant node types and then transfer the model to label-scarce node types using relational information given in HGs. You can find details of the work in our paper “&lt;em&gt;Zero-shot Transfer Learning within a Heterogeneous Graph via Knowledge Transfer Networks&lt;&#x2F;em&gt;” [1], presented at NeurIPS 2022.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-is-a-heterogeneous-graph-hg&quot;&gt;What is a heterogeneous graph (HG)?&lt;&#x2F;h2&gt;
&lt;figure&gt;
&lt;img src=&quot;.&#x2F;figure1.png&quot; alt=&quot;e-commerce heterogeneous graph&quot; width=&quot;400&quot;&#x2F;&gt;
&lt;figcaption&gt;Figure 1. E-commerce heterogeneous graph: Can we transfer knowledge from label-abundant node types (e.g., products) to zero-labeled node types (e.g., users) through relational information given in a heterogeneous graph?
&lt;&#x2F;figcaption&gt;
&lt;&#x2F;figure&gt;
&lt;p&gt;An HG is composed of multiple node and edge types. Figure 1 shows an e-commerce network presented as an HG. In e-commerce, “users” purchase “products” and write “reviews”. HG presents this ecosystem using three node types (“user”, “product”, “review”) and three edge types (“user-buy-product”, “user-write-review”, review-on-product”). Individual products, users, and reviews are then presented as nodes and their relationships as edges in the HG with the corresponding node&#x2F;edge types.&lt;&#x2F;p&gt;
&lt;p&gt;In addition to all relational information, HGs are commonly provided with &lt;em&gt;input node attributes&lt;&#x2F;em&gt; that summarize each node’s information. For instance, product nodes could have product images as input node attributes, while review nodes could have review texts as their input attributes. As in the example, input node attributes could have different modalities across different node types.  The goal is to predict &lt;em&gt;node labels&lt;&#x2F;em&gt; on each node, such as the category of each product or the category each user is most interested in.&lt;&#x2F;p&gt;
&lt;p&gt;In the following section, we introduce the main challenge we face while training HGNNs to predict labels using input node attributes and relational information from HGs.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;heterogeneous-graph-neural-networks-hgnns-and-label-scarcity-issues&quot;&gt;Heterogeneous graph neural networks (HGNNs) and label scarcity issues&lt;&#x2F;h2&gt;
&lt;p&gt;HGNNs compute node embeddings that summarize each node’s local graph structures including the node and its neighbor’s input attribute distributions. Node embeddings are then fed into a classifier to predict each node’s label. To train an HGNN model and a classifier to predict labels for a specific node type, we require a good amount of labels for the node type.&lt;&#x2F;p&gt;
&lt;p&gt;A common issue in real-world applications of deep learning is label scarcity. With their diverse node types, HGNNs are even more likely to face this challenge. For instance, publicly available content node types are abundantly labeled, whereas labels for user nodes may not be available due to privacy restrictions. This means that in most standard training settings, HGNN models can only learn to make good inferences for a few label-abundant node types and can usually not make any inferences for the remaining node types, given the absence of any labels for them.&lt;&#x2F;p&gt;
&lt;p&gt;To solve this label scarcity issue, we will use a technique called zero-shot transfer learning that improves the performance of a model on a zero-labeled domain.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;transfer-learning-on-heterogeneous-graphs&quot;&gt;Transfer Learning on Heterogeneous Graphs&lt;&#x2F;h2&gt;
&lt;p&gt;To improve the performance on a zero-labeled “target” domain, transfer learning exploits the knowledge earned from a related “source” domain, which has adequate labeled data. For instance, transfer learning on heterogeneous graphs first trains an HGNN model on the source domain using their labels, then reuses the HGNN model on the target domain.&lt;&#x2F;p&gt;
&lt;p&gt;In order to apply transfer learning on heterogeneous graphs to solve the label scarcity issue we described above, it is clear the target domain should be the zero-labeled node types. The question remained of what would be the source domain. Previous works commonly set the source domain as the same type of nodes but located in an external HG, assuming those nodes are abundantly labeled (Figure 2). For instance, the source domain is user nodes in the Yelp review graph, while the target domain is user nodes in the Amazon e-commerce graph. This approach, also known as &lt;em&gt;graph-to-graph transfer learning&lt;&#x2F;em&gt;, pre-trains an HGNN model on the external HG and then runs the model on the original label-scarce HG [2, 3].&lt;&#x2F;p&gt;
&lt;center&gt;
&lt;figure&gt;
&lt;img src=&quot;.&#x2F;figure2.png&quot; alt=&quot;graph-to-graph transfer learning&quot; width=&quot;600&quot;&#x2F;&gt;
&lt;figcaption&gt;Figure 2. Illustration of graph-to-graph transfer learning on heterogeneous graph.&lt;&#x2F;figcaption&gt;
&lt;&#x2F;figure&gt;
&lt;&#x2F;center&gt;
&lt;p&gt;However, this approach is not applicable in many real-world scenarios for three reasons. First, any external HG that could be used in a graph-to-graph transfer learning setting would almost surely be &lt;em&gt;proprietary&lt;&#x2F;em&gt;, thereby, making it hard to get access to. Second, even if practitioners could obtain access to an external HG, it is unlikely that the &lt;em&gt;distribution of the external HG&lt;&#x2F;em&gt; would match our target HG well enough to apply transfer learning. Finally, node types suffering from &lt;em&gt;label scarcity&lt;&#x2F;em&gt; are likely to suffer the same issue on other HGs. For instance, user nodes on the external HG also have scarce labels with privacy constraints.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;our-approach-transfer-learning-between-node-types-within-a-heterogeneous-graph&quot;&gt;Our approach: transfer learning between node types within a heterogeneous graph&lt;&#x2F;h2&gt;
&lt;p&gt;To overcome the limitation of usage of external HGs for transfer learning, we introduce a practical source domain, &lt;em&gt;other node types with abundant labels located on the same HG&lt;&#x2F;em&gt;. Instead of using extra HGs, we transfer knowledge across different types of nodes within a single HG assumed to be fully owned by the practitioners. More specifically, we first pre-train an HGNN model and a classifier on a label-abundant “source” node type. Then, we reuse the models on the zero-labeled “target” node types located in the same HG without additional finetuning. The one requirement for this approach is that the source and target node types share the same label set. This requirement is frequently satisfied in real-world settings. For instance, product nodes have a label set describing product categories, and user nodes share the same label set describing their favorite shopping categories in e-commerce HGs.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;main-technical-challenge&quot;&gt;Main technical challenge&lt;&#x2F;h2&gt;
&lt;p&gt;We now describe the main challenge in realizing our approach. We cannot directly reuse the pretrained HGNN and classifier on the target node type as described above because HGNN maps the source and target embeddings into the different embedding spaces.&lt;&#x2F;p&gt;
&lt;figure&gt;
&lt;img src=&quot;.&#x2F;figure3.png&quot; alt=&quot;l2 norm of gradients passed to each module in the HGNN&quot; width=&quot;450&quot;&#x2F;&gt;
&lt;figcaption&gt;
Figure 3. The L2 norm of gradients passed to each module in the HGNN while pretraining on the source node type. Green and Red lines show large amounts of gradients passed to source node type-specific modules, while blue and orange lines show little or no gradients passed to target type-specific modules.
&lt;&#x2F;figcaption&gt;
&lt;&#x2F;figure&gt;
&lt;p&gt;This happens because of one crucial characteristic of HGNNs — HGNNs are composed of modules specialized to each node type and use distinct sets of modules to compute embeddings for each node type. During pretraining HGNNs on the source node type, modules specialized to the source node type are well-trained, while modules specialized to the target node are untrained or under-trained. In Figure 3, we can observe the source modules (green and red lines) receive high L2 norms of gradients during pretraining. On the other hand, because of the specialization, the target modules (orange and blue lines) receive little or no gradients. With under-trained modules for the target node type, the pretrained HGNN model outputs poor node embeddings for the target node type, and, consequently, poor performance on the node prediction task.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ktn-trainable-cross-type-transfer-learning-for-hgnns&quot;&gt;KTN: Trainable Cross-Type Transfer Learning for HGNNs&lt;&#x2F;h2&gt;
&lt;p&gt;Now, we introduce a method to transform the under-trained poor embeddings of the target node type to follow source embeddings. This allows us to reuse the classifier that was trained on source node types. In order to derive the transformation in a principled manner, let us look into how HGNNs compute node embeddings and analyze the relationship between source and target embeddings.&lt;&#x2F;p&gt;
&lt;figure&gt;
&lt;img src=&quot;.&#x2F;figure4.png&quot; alt=&quot;HGNN structure&quot; width=&quot;600&quot;&#x2F;&gt;
&lt;figcaption&gt;
Figure 4. (left) In HGNNs, the final L-layer node embeddings for both source and target types are computed using the same input, the previous (L-1)-layer’s node embeddings. (right) The L-layer node embeddings of the source type (product, blue) can be represented by the L-layer node embeddings of the target type (user, red) using (L-1)-layer node embeddings as intermediate values.
&lt;&#x2F;figcaption&gt;
&lt;&#x2F;figure&gt;
&lt;p&gt;In each layer, HGNNs aggregate connected nodes’ embeddings from the previous layer to update each target node’s embeddings. Node embeddings for both source and target node types are updated using the same input: the previous layer’s node embeddings of any connected node types (Figure 4, left). This means that they can be represented by each other using the previous layer embeddings as intermediate values (Figure 4, right).&lt;&#x2F;p&gt;
&lt;p&gt;We prove there is a mapping matrix from the target domain to the source domain, which is defined by HGNN parameters (Theorem 1 in [1]). Based on this theorem, we introduce an auxiliary network, named Knowledge Transfer Networks (KTN), that learns the mapping matrix from scratch during pretraining HGNN on the source domain. At test time, we first compute target embeddings using the pretrained HGNN, then map the target embeddings to the source domain using our trained KTN. Finally, we can reuse the classifier with transformed target embeddings.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;experimental-results&quot;&gt;Experimental results&lt;&#x2F;h2&gt;
&lt;figure&gt;
&lt;img src=&quot;.&#x2F;figure5.png&quot; alt=&quot;zero-shot transfer learning results on OAG and Pubmed&quot; width=&quot;600&quot;&#x2F;&gt;
&lt;figcaption&gt;
Figure 5. Zero-shot transfer learning performance measured in NDCG on Open Academic Graph (OAG) and Pubmed datasets. Higher is better. Our proposed method KTN (red bar) shows the highest accuracy among all baselines.
&lt;&#x2F;figcaption&gt;
&lt;&#x2F;figure&gt;
&lt;p&gt;To examine the effectiveness of our proposed KTN, we ran 18 different zero-shot transfer learning tasks on two public heterogeneous graphs, Open Academic Graph [4] and Pubmed [5]. We compare KTN with 8 state-of-the-art transfer learning methods. We show our results in Figure 5. Our proposed method KTN consistently outperforms all baselines on all tasks by up to 73.3%. The naive approach we discussed earlier — reuse the pretrained models directly on the target domain without any transfer learning — is presented as blue bar. We see our method KTN provides relative gains of up to 340% higher than the naive approach without using any labels from the target domain.&lt;&#x2F;p&gt;
&lt;figure&gt;
&lt;img src=&quot;.&#x2F;figure6.png&quot; alt=&quot;KTN with 6 different HGNN models&quot; width=&quot;450&quot;&#x2F;&gt;
&lt;figcaption&gt;
Figure 6. KTN can be applied to 6 different HGNN models and improve their zero-shot performance on target domains. Performance is measured in NDCG. Higher is better.
&lt;&#x2F;figcaption&gt;
&lt;&#x2F;figure&gt;
&lt;p&gt;KTN can be applied to almost all HGNN models that have node&#x2F;edge type-specific modules and improve their zero-shot performance on target domains. In Figure 6, KTN improves accuracy on zero-labeled node types across 6 different HGNN models by up to 960%.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;takeaway&quot;&gt;Takeaway:&lt;&#x2F;h2&gt;
&lt;p&gt;Various real-world applications can be presented as heterogeneous graphs. Heterogeneous graph neural networks (HGNNs) are an effective technique for summarizing heterogeneous graphs into concise embeddings. However, label scarcity issues on certain types of nodes have prevented the broader application of HGNNs. In this post, we introduced KTN, the first cross-type transfer learning method designed for HGNNs. With KTN, we can fully exploit the rich relational information of heterogeneous graphs with HGNNs on any nodes regardless of their label scarcity.&lt;&#x2F;p&gt;
&lt;p&gt;For more details about KTN, check out our paper [1].&lt;&#x2F;p&gt;
&lt;p&gt;[1] Minji Yoon, John Palowitch, Dustin Zelle, Ziniu Hu, Ruslan Salakhutdinov, Bryan Perozzi. &lt;em&gt;Zero-shot Transfer Learning within a Heterogeneous Graph via Knowledge Transfer Networks&lt;&#x2F;em&gt;, Neural Information Processing Systems (NeurIPS) 2022.&lt;&#x2F;p&gt;
&lt;p&gt;[2] Tiancheng Huang, Ke Xu, and Donglin Wang. &lt;em&gt;Da-hgt: Domain adaptive heterogeneous graph transformer.&lt;&#x2F;em&gt; arXiv preprint arXiv:2012.05688, 2020.&lt;&#x2F;p&gt;
&lt;p&gt;[3] Shuwen Yang, Guojie Song, Yilun Jin, and Lun Du. &lt;em&gt;Domain adaptive classification on heterogeneous information networks.&lt;&#x2F;em&gt; International Joint Conferences on Artificial Intelligence (IJCAI) 2021.&lt;&#x2F;p&gt;
&lt;p&gt;[4] Fanjin Zhang, Xiao Liu, Jie Tang, Yuxiao Dong, Peiran Yao, Jie Zhang, Xiaotao Gu, Yan Wang, Bin Shao, Rui Li, et al. &lt;em&gt;Oag: Toward linking large-scale heterogeneous entity graphs.&lt;&#x2F;em&gt; In Proceedings of the 25th ACM SIGKDD International Conference on Knowledge Discovery &amp;amp; Data Mining 2019.&lt;&#x2F;p&gt;
&lt;p&gt;[5] Carl Yang, Yuxin Xiao, Yu Zhang, Yizhou Sun, and Jiawei Han. &lt;em&gt;Heterogeneous network representation learning: A unified framework with survey and benchmark.&lt;&#x2F;em&gt; IEEE Transactions on Knowledge and Data Engineering, 2020.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>FIFO is Better than LRU: the Power of Lazy Promotion and Quick Demotion</title>
		<published>2023-09-20T00:00:00+00:00</published>
		<updated>2023-09-20T00:00:00+00:00</updated>
		<link href="https://www.cs.cmu.edu/~csd-phd-blog/2023/fifo-lru/" type="text/html"/>
		<id>https://www.cs.cmu.edu/~csd-phd-blog/2023/fifo-lru/</id>
		<content type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;TL;DR:&lt;&#x2F;strong&gt; 
Historically FIFO-based algorithms are thought to be less efficient (having higher miss ratios) than LRU-based algorithms.
In this blog, we introduce two techniques, &lt;strong&gt;lazy promotion&lt;&#x2F;strong&gt;, which promotes objects only at eviction time, and &lt;strong&gt;quick demotion&lt;&#x2F;strong&gt;, which evicts most new objects quickly. We will show that&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Conventional-wisdom-suggested “weak LRUs”, e.g., FIFO-Reinsertion, is actually more efficient (having lower miss ratios) than LRU;&lt;&#x2F;li&gt;
&lt;li&gt;Simply evicting most new objects quickly can improve the state-of-the-art algorithm’s efficiency.&lt;&#x2F;li&gt;
&lt;li&gt;Eviction algorithms can be designed like building with LEGOs by adding &lt;strong&gt;lazy promotion&lt;&#x2F;strong&gt; and &lt;strong&gt;quick demotion&lt;&#x2F;strong&gt; on top of FIFO.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;Caching is a well-known and widely deployed technique to speed up data access, reduce repeated computation and data transfer. 
A core component of a cache is the eviction algorithm, which chooses the objects stored in the limited cache space.
Two metrics describe the performance of an eviction algorithm: efficiency measured by the miss ratio and throughput measured by the number of requests served that can be served per second.&lt;&#x2F;p&gt;
&lt;p&gt;The study of cache eviction algorithms has a long history, with a majority of the work centered around LRU (that is, to evict the least-recently-used object).
Generally, LRU maintains a doubly-linked list, promoting objects to the head of the list upon cache hits and evicting the object at the tail of the list when needed.
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;3399709&quot;&gt;Belady and others found&lt;&#x2F;a&gt; that memory access patterns often exhibit temporal locality — “the most recently used pages were most likely to be reused in the immediate future”. Thus, LRU using &lt;em&gt;recency&lt;&#x2F;em&gt; to promote objects was found to be better than FIFO.&lt;&#x2F;p&gt;
&lt;p&gt;Most eviction algorithms designed to achieve high efficiency start from LRU.
For example, many algorithms, such as &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;conference&#x2F;fast-03&#x2F;arc-self-tuning-low-overhead-replacement-cache&quot;&gt;ARC&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;research.facebook.com&#x2F;publications&#x2F;an-analysis-of-facebook-photo-caching&#x2F;&quot;&gt;SLRU&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.vldb.org&#x2F;conf&#x2F;1994&#x2F;P439.PDF&quot;&gt;2Q&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;legacy&#x2F;events&#x2F;usenix01&#x2F;full_papers&#x2F;zhou&#x2F;zhou.pdf&quot;&gt;MQ&lt;&#x2F;a&gt;, and &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;856931&#x2F;&quot;&gt;multi-generational LRU&lt;&#x2F;a&gt;, use multiple LRU queues to separate hot and cold objects. Some algorithms, e.g., &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;abs&#x2F;10.1145&#x2F;511399.511340?casa_token=x3My6rber5UAAAAA%3A7Gbpkgt2k6RMf95GUwvxrsY0-R-q5EpEN_uXRAfF4loxK2vo9yFtFh6Vo5R-30Vlkv1_3BtwnJiomlw&quot;&gt;LIRS&lt;&#x2F;a&gt;, maintain an LRU queue but use different metrics to promote objects. While other algorithms, e.g., &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.computer.org&#x2F;csdl&#x2F;journal&#x2F;tc&#x2F;2001&#x2F;12&#x2F;t1352&#x2F;13rRUxBJhES&quot;&gt;LRFU&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;301464.301486&quot;&gt;EE-LRU&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;conference&#x2F;hotstorage18&#x2F;hotstorage18-paper-vietri.pdf&quot;&gt;LeCaR&lt;&#x2F;a&gt;, and &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;fast21-rodriguez.pdf&quot;&gt;CACHEUS&lt;&#x2F;a&gt;, augment LRU’s recency with different metrics. In addition, many recent works, e.g., &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;ieeexplore.ieee.org&#x2F;abstract&#x2F;document&#x2F;7056022&quot;&gt;Talus&lt;&#x2F;a&gt;, improve LRU’s ability to handle scan and loop requests.&lt;&#x2F;p&gt;
&lt;p&gt;Besides efficiency (miss ratio), there have been fruitful studies on enhancing the cache’s execution performance and thread scalability. Each cache hit in LRU promotes an object to the head of the queue, which requires updating at least six pointers guarded by locks.
These overheads are not acceptable in many deployments that need high performance.
Thus, performance-centric systems often use FIFO-based algorithms to avoid LRU’s overheads.
For example, FIFO-Reinsertion and variants of CLOCK have been developed, which serve as LRU approximations.
&lt;em&gt;It is often perceived that these algorithms trade miss ratio for better throughput and scalability.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In this blog, I am going to show that FIFO is in-fact better than LRU not only because of higher throughput, better scalability, but also because of improved effectiveness (having lower miss ratios).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;why-fifo-and-what-it-needs&quot;&gt;Why FIFO and What it needs&lt;&#x2F;h2&gt;
&lt;p&gt;FIFO has many benefits over LRU. 
For example, FIFO has &lt;em&gt;less metadata&lt;&#x2F;em&gt; and requires no metadata update on each cache hit, and thus is &lt;em&gt;faster and more scalable&lt;&#x2F;em&gt; than LRU. In contrast, LRU requires updating six pointers on each cache hit, which is not friendly for modern computer architecture due to random memory accesses. Moreover, FIFO is always the first choice when implementing a flash cache because it does not incur write amplification. Although FIFO has throughput and scalability benefits, it is conventional wisdom that FIFO is less effective (having higher miss ratio) than LRU.&lt;&#x2F;p&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;figure class=&quot;image&quot;&gt;&lt;img src=&quot;cacheAbs.svg&quot; alt=&quot;A cache abstraction&quot; style=&quot;width:80%; display: block; margin-left: auto; margin-right: auto;&quot;&gt;
&lt;figcaption&gt;A cache can be viewed as a logically ordered queue with four operations: insertion, removal, promotion and demotion. Most eviction algorithms can be viewed as promotion algorithms because they focus on how to promote objects. &lt;&#x2F;figcaption&gt;
&lt;&#x2F;figure&gt;
&lt;&#x2F;p&gt;
&lt;p&gt;To understand the various factors that affect the miss ratio, we introduce a cache abstraction. 
A cache can be viewed as a logically total-ordered queue with four operations: &lt;span style=&quot;font-family:monaco;&quot;&gt;insertion&lt;&#x2F;span&gt;, &lt;span style=&quot;font-family:monaco;&quot;&gt;removal&lt;&#x2F;span&gt;, &lt;span style=&quot;font-family:monaco;&quot;&gt;promotion&lt;&#x2F;span&gt;, and &lt;span style=&quot;font-family:monaco;&quot;&gt;demotion&lt;&#x2F;span&gt;.
Objects in the cache can be compared and ordered based on some metric (e.g., time since the last request), and the eviction algorithm evicts the least valuable object based on the metric.
&lt;span style=&quot;font-family:monaco;&quot;&gt;Insertion&lt;&#x2F;span&gt; and &lt;span style=&quot;font-family:monaco;&quot;&gt;removal&lt;&#x2F;span&gt; are user-controlled operations, where &lt;span style=&quot;font-family:monaco;&quot;&gt;removal&lt;&#x2F;span&gt; can either be directly invoked by the user or indirectly via the use of time-to-live (TTL).
&lt;span style=&quot;font-family:monaco;&quot;&gt;Promotion&lt;&#x2F;span&gt; and &lt;span style=&quot;font-family:monaco;&quot;&gt;demotion&lt;&#x2F;span&gt; are internal operations of the cache used to maintain the logical ordering between objects.&lt;&#x2F;p&gt;
&lt;p&gt;We observe that most eviction algorithms use &lt;span style=&quot;font-family:monaco;&quot;&gt;promotion&lt;&#x2F;span&gt; to update the ordering between objects.
For example, LRU-based algorithms promote objects to the head of the queue on cache hits, which we call &lt;span style=&quot;font-family:monaco;&quot;&gt;eager promotion&lt;&#x2F;span&gt;.
Meanwhile, &lt;span style=&quot;font-family:monaco;&quot;&gt;demotion&lt;&#x2F;span&gt; is performed implicitly: when an object is promoted, other objects are passively demoted.
We call this process &lt;span style=&quot;font-family:monaco;&quot;&gt;passive demotion&lt;&#x2F;span&gt;, a slow process as objects need to traverse through the cache queue before being evicted.
However, we will show that instead of eager promotion and passive demotion, eviction algorithms should use &lt;strong&gt;lazy promotion&lt;&#x2F;strong&gt; and &lt;strong&gt;quick demotion&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;lazy-promotion&quot;&gt;Lazy Promotion&lt;&#x2F;h2&gt;
&lt;p&gt;To avoid popular objects from being evicted while not incurring much performance overhead, we propose adding &lt;strong&gt;lazy promotion&lt;&#x2F;strong&gt; on top of FIFO (called &lt;span style=&quot;font-family:arial; font-variant-cap:petite-caps&quot;&gt; LP-FIFO&lt;&#x2F;span&gt;), which &lt;em&gt;promotes objects only when they are about to be evicted&lt;&#x2F;em&gt;.
&lt;strong&gt;lazy promotion&lt;&#x2F;strong&gt; aims to retain popular objects with minimal effort.
An example is FIFO-Reinsertion (note that FIFO-Reinsertion, 1-bit CLOCK, and Second Chance are different implementations of the same eviction algorithm): an object is reinserted at eviction time if it has been requested while in the cache. &lt;&#x2F;p&gt;
&lt;p&gt;&lt;span style=&quot;font-family:arial; font-variant-cap:small-caps&quot;&gt;LP-FIFO&lt;&#x2F;span&gt; has several benefits over eager promotion (promoting on every access) used in LRU-based algorithms.
First, &lt;span style=&quot;font-family:arial; font-variant-cap:small-caps&quot;&gt;LP-FIFO&lt;&#x2F;span&gt; inherits FIFO’s throughput and scalability benefits because few metadata operations are needed when an object is requested. For example, FIFO-Reinsertion only needs to update a Boolean field upon the &lt;em&gt;first&lt;&#x2F;em&gt; request to a cached object without locking.
Second, performing promotion at eviction time allows the cache to make better decisions by accumulating more information about the objects, e.g., how many times an object has been requested.&lt;&#x2F;p&gt;
&lt;style&gt;
td,th {
  font-size: 96%;
}
&lt;&#x2F;style&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Trace&lt;&#x2F;th&gt;&lt;th&gt;approx time&lt;&#x2F;th&gt;&lt;th align=&quot;right&quot;&gt;#trace&lt;&#x2F;th&gt;&lt;th align=&quot;right&quot;&gt;cache type&lt;&#x2F;th&gt;&lt;th align=&quot;right&quot;&gt;#req (millions)&lt;&#x2F;th&gt;&lt;th align=&quot;right&quot;&gt;#obj (millions)&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;MSR&lt;&#x2F;td&gt;&lt;td&gt;2007&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;13&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;block&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;410&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;74&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;FIU&lt;&#x2F;td&gt;&lt;td&gt;2008&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;9&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;block&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;514&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;20&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Cloudphysics&lt;&#x2F;td&gt;&lt;td&gt;2015&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;106&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;block&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;2,114&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;492&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Major CDN&lt;&#x2F;td&gt;&lt;td&gt;2018&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;219&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;object&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;3,728&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;298&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Tencent Photo&lt;&#x2F;td&gt;&lt;td&gt;2018&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;2&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;object&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;5,650&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;1,038&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Wiki CDN&lt;&#x2F;td&gt;&lt;td&gt;2019&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;3&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;object&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;2,863&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;56&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Tencent CBS&lt;&#x2F;td&gt;&lt;td&gt;2020&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;4030&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;block&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;33,690&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;551&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Alibaba&lt;&#x2F;td&gt;&lt;td&gt;2020&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;652&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;block&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;19,676&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;1702&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Twitter&lt;&#x2F;td&gt;&lt;td&gt;2020&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;54&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;KV&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;195,441&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;10,650&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Social Network&lt;&#x2F;td&gt;&lt;td&gt;2020&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;219&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;KV&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;549,784&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;42,898&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;To understand &lt;span style=&quot;font-family:arial; font-variant-cap:small-caps&quot;&gt;LP-FIFO&lt;&#x2F;span&gt;’s efficiency,
we performed a large-scale simulation study on 5307 production traces from 10 data sources, which include open-source and proprietary datasets collected between 2007 and 2020.
The 10 datasets contain 814 billion (6,386 TB) requests and 55.2 billion (533 TB) objects, and cover different types of caches, including block, key-value (KV), and object caches.
We further divide the traces into block and web (including Memcached and CDN).
We choose small&#x2F;large cache size as 0.1%&#x2F;10% of the number of unique objects in the trace.&lt;&#x2F;p&gt;
&lt;p&gt;We compare the miss ratios of LRU with two &lt;span style=&quot;font-family:arial; font-variant-cap:small-caps&quot;&gt;LP-FIFO&lt;&#x2F;span&gt; algorithms:
FIFO-Reinsertion and 2-bit CLOCK.
2-bit CLOCK tracks object frequency up to three, and an object’s frequency decreases by one each time the CLOCK hand scans through it. Objects with frequency zero are evicted.&lt;&#x2F;p&gt;
&lt;p&gt;Common wisdom suggests that these two &lt;span style=&quot;font-family:arial; font-variant-cap:small-caps&quot;&gt;LP-FIFO&lt;&#x2F;span&gt; examples are LRU approximations and will exhibit higher miss ratios than LRU.
However, we found that &lt;strong&gt;&lt;span style=&quot;font-family:arial; font-variant-cap:small-caps&quot;&gt;LP-FIFO&lt;&#x2F;span&gt; often exhibits miss ratios lower than LRU&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; justify-content: space-around;&quot;&gt;
&lt;img src=&quot;multi_LRU_FIFO_Reinsertion_1.svg&quot; alt=&quot;small cache&quot; style=&quot;width:40%&quot;&gt;
&lt;img src=&quot;multi_LRU_FIFO_Reinsertion_3.svg&quot; alt=&quot;large cache&quot; style=&quot;width:40%&quot;&gt;
&lt;&#x2F;div&gt;
&lt;div style=&quot;width: 88%; margin: 0 auto;&quot;&gt;
Comparison of FIFO-Reinsertion and LRU on 10 datasets with 5307 traces. Left: small cache, right: large cache. 
&lt;&#x2F;div&gt;
&lt;div style=&quot;display: flex; justify-content: space-around;&quot;&gt;
&lt;img src=&quot;multi_LRU_Clock-2_1.svg&quot; alt=&quot;small cache&quot; style=&quot;width:40%&quot;&gt;
&lt;img src=&quot;multi_LRU_Clock-2_3.svg&quot; alt=&quot;large cache&quot; style=&quot;width:40%&quot;&gt;
&lt;&#x2F;div&gt;
&lt;div style=&quot;width: 88%; margin: 0 auto;&quot;&gt;
Comparison of 2-bit CLOCK and LRU on 10 datasets with 5307 traces. Left: small cache, right: large cache. A longer bar means the algorithm is more efficient (having lower miss ratios on more traces). Note that we do not consider the overhead of LRU metadata in these evaluations. 
&lt;&#x2F;div&gt;
&lt;p&gt;The figure above shows that FIFO-Reinsertion and 2-bit CLOCK are better than LRU on most traces.
Specifically, FIFO-Reinsertion is better than LRU on 9 and 7 of the 10 datasets using a small and large cache size, respectively.
Moreover, on half of the datasets, more than 80% of the traces in each dataset favor FIFO-Reinsertion over LRU at both sizes.
On the two social network datasets, LRU is better than FIFO-Reinsertion (especially at the large cache size). This is because most objects in these two datasets are accessed more than once, and using one bit to track object access is insufficient. Therefore, when increasing the one bit in FIFO-Reinsertion (CLOCK) to two bits (2-bit CLOCK), we observe that the number of traces favoring &lt;span style=&quot;font-family:arial; font-variant-cap:small-caps&quot;&gt;LP-FIFO&lt;&#x2F;span&gt; increases to around 70%.
Across all datasets, 2-bit CLOCK is better than FIFO on all datasets at the small cache size and 9 of the 10 datasets at the large cache size.&lt;&#x2F;p&gt;
&lt;figure class=&quot;image&quot;&gt;
&lt;img src=&quot;LP.svg&quot; alt=&quot;Lazy promotion leads to quick demotion&quot; style=&quot;width:64%&quot;&gt;
&lt;figcaption&gt;FIFO-Reinsertion demotes new objects faster than LRU because objects requested before the new object also pushes it down the queue.&lt;&#x2F;figcaption&gt;
&lt;&#x2F;figure&gt;
&lt;p&gt;Two reasons contribute to &lt;span style=&quot;font-family:arial; font-variant-cap:small-caps&quot;&gt;LP-FIFO&lt;&#x2F;span&gt;’s high effectiveness.
First, &lt;strong&gt;lazy promotion&lt;&#x2F;strong&gt; often leads to &lt;strong&gt;quick demotion&lt;&#x2F;strong&gt;. For example, under LRU, a newly-inserted object &lt;em&gt;G&lt;&#x2F;em&gt; is pushed down the queue only by (1) new objects and (2) cached objects that are requested after &lt;em&gt;G&lt;&#x2F;em&gt;. However, besides the objects requested after &lt;em&gt;G&lt;&#x2F;em&gt;, the objects requested before &lt;em&gt;G&lt;&#x2F;em&gt; (but have not been promoted, e.g., &lt;em&gt;B&lt;&#x2F;em&gt;, &lt;em&gt;D&lt;&#x2F;em&gt;) also push &lt;em&gt;G&lt;&#x2F;em&gt; down the queue when using FIFO-Reinsertion.
Second, compared to promotion at each request, object ordering in &lt;span style=&quot;font-family:arial; font-variant-cap:small-caps&quot;&gt;LP-FIFO&lt;&#x2F;span&gt; is closer to the insertion order, which we conjecture is better suited for many workloads that exhibit popularity decay — old objects have a lower probability of getting a request.&lt;&#x2F;p&gt;
&lt;p&gt;While &lt;span style=&quot;font-family:arial; font-variant-cap:small-caps&quot;&gt;LP-FIFO&lt;&#x2F;span&gt; surprisingly wins over LRU in miss ratio, it does not outperform state-of-the-art algorithms. We next discuss another building block that bridges this gap.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;quick-demotion&quot;&gt;Quick Demotion&lt;&#x2F;h2&gt;
&lt;p&gt;Efficient eviction algorithms not only need to keep popular objects in the cache but also need to evict unpopular objects fast. In this section, we show that &lt;strong&gt;quick demotion&lt;&#x2F;strong&gt; (QD) is critical for an efficient eviction algorithm, and it enables FIFO-based algorithms to achieve state-of-the-art efficiency.&lt;&#x2F;p&gt;
&lt;p&gt;Because demotion happens passively in most eviction algorithms, an object typically traverses through the cache before being evicted. Such traversal gives each object a good chance to prove its value to be kept in the cache.
However, cache workloads often follow Zipf popularity distribution, with most objects being unpopular.
This is further exacerbated by (1) the scan and loop access patterns in the block cache workloads, and (2) the vast existence of dynamic and short-lived data, the use of versioning in object names, and the use of short TTLs in the web cache workloads.
We believe the &lt;em&gt;opportunity cost of new objects demonstrating their values is often too high&lt;&#x2F;em&gt;: the object being evicted at the tail of the queue may be more valuable than the objects recently inserted.&lt;&#x2F;p&gt;
&lt;figure class=&quot;image&quot;&gt;
&lt;img src=&quot;QD.svg&quot; alt=&quot;An examplf of quick demotion&quot; style=&quot;width:64%&quot;&gt;
&lt;figcaption&gt;An example of quick demotion: adding a small FIFO to filter most new objects that do not have a request soon after insertion.&lt;&#x2F;figcaption&gt;
&lt;&#x2F;figure&gt;
&lt;p&gt;To illustrate the importance of &lt;strong&gt;quick demotion&lt;&#x2F;strong&gt;, we add a simple QD technique on top of state-of-the-art eviction algorithms.
The QD technique consists of a small probationary FIFO queue storing cached data and a ghost FIFO queue storing metadata of objects evicted from the probationary FIFO queue.
The probationary FIFO queue uses 10% of the cache space and acts as a filter for unpopular objects: objects not requested after insertion are evicted early from the FIFO queue. The main cache runs a state-of-the-art algorithm and uses 90% of the space.
And the ghost FIFO stores as many entries as the main cache.
Upon a cache miss, the object is written into the probationary FIFO queue unless it is in the ghost FIFO queue, in which case, it is written into the main cache.
When the probationary FIFO queue is full, if the object to evict has been accessed since insertion, it is inserted into the main cache. Otherwise, it is evicted and recorded in the ghost FIFO queue.&lt;&#x2F;p&gt;
&lt;p&gt;We add this FIFO-based QD technique to five state-of-the-art eviction algorithms, ARC, LIRS, CACHEUS, LeCaR, and LHD.
We used the open-source LHD implementation from the authors, implemented the others following the corresponding papers, and cross-checked with open-source implementations.
We evaluated the QD-enhanced and original algorithms on the 5307 traces.
Because the traces have a wide range of miss ratios, we choose to present each algorithm’s miss ratio reduction from FIFO calculated as &lt;em&gt;(mr&lt;sub&gt;FIFO&lt;&#x2F;sub&gt; - mr&lt;sub&gt;algo&lt;&#x2F;sub&gt;) &#x2F; mr&lt;sub&gt;FIFO&lt;&#x2F;sub&gt;&lt;&#x2F;em&gt;. Therefore, higher values are better. &lt;&#x2F;p&gt;
&lt;div style=&quot;display: flex; justify-content: space-around;&quot;&gt;
&lt;img src=&quot;block_1.svg&quot; alt=&quot;block cache traces, small cache size&quot; style=&quot;width:48%&quot;&gt;
&lt;img src=&quot;block_3.svg&quot; alt=&quot;block cache traces, large cache size&quot; style=&quot;width:48%&quot;&gt;
&lt;&#x2F;div&gt;
&lt;div style=&quot;display: flex; justify-content: space-around;&quot;&gt;
&lt;img src=&quot;web_1.svg&quot; alt=&quot;web cache traces, small cache size&quot; style=&quot;width:48%&quot;&gt;
&lt;img src=&quot;web_3.svg&quot; alt=&quot;web cache traces, large cache size&quot; style=&quot;width:48%&quot;&gt;
&lt;&#x2F;div&gt;
&lt;div style=&quot;width: 88%; margin: 0 auto;&quot;&gt;
On the block (first row) and web traces (second row), quick demotion can improve most state-of-the-art algorithm&#x27;s efficiency. Left: small cache, right: large cache.
&lt;&#x2F;div&gt;
&lt;p&gt;The figures above show that the QD-enhanced algorithms further reduce the miss ratio of each state-of-the-art algorithm on almost all percentiles. For example, QD-ARC (QD-enhanced ARC) reduces ARC’s miss ratio by up to 59.8% with a mean reduction of 1.5% across all workloads on the two cache sizes, QD-LIRS reduces LIRS’s miss ratio by up to 49.6% with a mean of 2.2%, and QD-LeCaR reduces LeCaR’s miss ratio by up to 58.8% with a mean of 4.5%.
Note that achieving a large miss ratio reduction on a large number of diverse traces is non-trivial. For example, the best state-of-the-art algorithm, ARC, can only reduce the miss ratio of LRU by 6.2% on average.&lt;&#x2F;p&gt;
&lt;p&gt;The gap between the QD-enhanced algorithm and an original algorithm is wider (1) when the state-of-the-art is relatively weak, (2) when the cache size is large, and (3) on the web workloads.
First, With a weaker state-of-the-art, the opportunity for improvement is larger, allowing QD to provide more prominent benefits. For example, QD-LeCaR reduces LeCaR’s miss ratios by 4.5% on average, larger than the reductions on other state-of-the-art algorithms.
Second, when the cache size is large, unpopular objects spend more time in the cache, and &lt;strong&gt;quick demotion&lt;&#x2F;strong&gt; becomes more valuable.
For example, QD-ARC and ARC have similar miss ratios on the block workloads at the small cache size. But QD-ARC reduces ARC’s miss ratio by 2.3% on average at the large cache size.
However, when the cache size is too large, e.g., 80% of the number of objects in the trace,
adding QD may increase the miss ratio (not shown).
Third, QD provides more benefits on the web workloads than the block workloads, especially when the cache size is small. We conjecture that web workloads have more short-lived data and exhibit stronger popularity decay, which leads to a more urgent need for &lt;strong&gt;quick demotion&lt;&#x2F;strong&gt;.
While &lt;strong&gt;quick demotion&lt;&#x2F;strong&gt; improves the efficiency of most state-of-the-art algorithms, for a small subset of traces, QD may increase the miss ratio when the cache size is small because the probationary FIFO is too small to capture some potentially popular objects.&lt;&#x2F;p&gt;
&lt;p&gt;Although adding the probationary FIFO improves efficiency, it further increases the complexity of the already complicated state-of-the-art algorithms.
To reduce complexity, we add the same QD technique on top of 2-bit CLOCK and call it &lt;span style=&quot;font-family:arial; font-variant-cap:small-caps&quot;&gt;QD-LP-FIFO&lt;&#x2F;span&gt;.
&lt;span style=&quot;font-family:arial; font-variant-cap:small-caps&quot;&gt;QD-LP-FIFO&lt;&#x2F;span&gt; uses two FIFO queues to cache data and a ghost FIFO queue to track evicted objects.
It is not hard to see &lt;span style=&quot;font-family:arial; font-variant-cap:small-caps&quot;&gt;QD-LP-FIFO&lt;&#x2F;span&gt; is simpler than all state-of-the-art algorithms — it requires at most one metadata update on a cache hit and no locking for any cache operation. Therefore, we believe it will be faster and more scalable than all state-of-the-art algorithms.
Besides enjoying all the benefits of simplicity, &lt;span style=&quot;font-family:arial; font-variant-cap:small-caps&quot;&gt;QD-LP-FIFO&lt;&#x2F;span&gt; also achieves lower miss ratios than state-of-the-art algorithms.
For example, compared to LIRS and LeCaR, &lt;span style=&quot;font-family:arial; font-variant-cap:small-caps&quot;&gt;QD-LP-FIFO&lt;&#x2F;span&gt; reduces miss ratio by 1.6% and 4.3% on average, respectively, across the 5307 traces.
While the goal of this work is not to propose a new eviction algorithm, &lt;span style=&quot;font-family:arial; font-variant-cap:small-caps&quot;&gt;QD-LP-FIFO&lt;&#x2F;span&gt; illustrates how we can build simple yet efficient eviction algorithms by adding &lt;strong&gt;quick demotion&lt;&#x2F;strong&gt; and &lt;strong&gt;lazy promotion&lt;&#x2F;strong&gt; techniques to a simple base eviction algorithm such as FIFO.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;discussion&quot;&gt;Discussion&lt;&#x2F;h2&gt;
&lt;p&gt;We have demonstrated reinsertion as an example of LP and the use of a small probationary FIFO queue as an example of QD. However, these are not the only techniques.
For example, reinsertion can leverage different metrics to decide whether the object should be reinserted. Besides reinsertion, several other techniques are often used to reduce promotion and improve scalability, e.g., periodic promotion, batched promotion, promoting old objects only, and promoting with try-lock. 
Although these techniques do not fall into our strict definition of &lt;strong&gt;lazy promotion&lt;&#x2F;strong&gt; (promotion on eviction), many of them effectively retain popular objects from being evicted.
On the &lt;strong&gt;quick demotion&lt;&#x2F;strong&gt; side, besides the small probationary FIFO queue, one can leverage other techniques to define and discover unpopular objects such as &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;conference&#x2F;atc17&#x2F;atc17-blankstein.pdf&quot;&gt;Hyperbolic&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;conference&#x2F;nsdi18&#x2F;nsdi18-beckmann.pdf&quot;&gt;LHD&lt;&#x2F;a&gt;.
Moreover, admission algorithms, e.g., &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;3149371&quot;&gt;TinyLFU&lt;&#x2F;a&gt;, Bloom Filter, probabilistic, and &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;nsdi19-eisenman.pdf&quot;&gt;ML-based admission algorithms&lt;&#x2F;a&gt;, can be viewed as a form of QD — though some of them are too aggressive at demotion (rejecting objects from entering the cache).&lt;&#x2F;p&gt;
&lt;p&gt;Note that QD bears similarity with some &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;wiki.c2.com&#x2F;?GenerationalGarbageCollection&quot;&gt;generational garbage collection algorithms&lt;&#x2F;a&gt;, which separately store short-lived and long-lived data in young-gen and old-gen heaps.
Therefore, ideas from garbage collection may be borrowed to strengthen cache eviction algorithms.&lt;&#x2F;p&gt;
&lt;p&gt;The design of &lt;span style=&quot;font-family:arial; font-variant-cap:small-caps&quot;&gt;QD-LP-FIFO&lt;&#x2F;span&gt; opens the door to designing simple yet efficient cache eviction algorithms by innovating on LP and QD techniques. And we envision future eviction algorithms can be designed like building LEGO — adding &lt;strong&gt;lazy promotion&lt;&#x2F;strong&gt; and &lt;strong&gt;quick demotion&lt;&#x2F;strong&gt; on top of a base eviction algorithm.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Verus: A tool for verified systems code in Rust</title>
		<published>2023-08-03T00:00:00+00:00</published>
		<updated>2023-08-03T00:00:00+00:00</updated>
		<link href="https://www.cs.cmu.edu/~csd-phd-blog/2023/rust-verification-with-verus/" type="text/html"/>
		<id>https://www.cs.cmu.edu/~csd-phd-blog/2023/rust-verification-with-verus/</id>
		<content type="html">&lt;p&gt;Part of the challenge (and fun) of low-level systems code is in the optimizations they employ:
developers might use manual memory management, they might use bit-packing and bit-twiddling optimizations,
or they might use multi-threading to speed up their code.
When dealing with such things for critical software, though, it can be difficult to ensure their correctness.
This is why my research group is interested in the formal verification of systems software:
ensuring through computer-checked mathematical proofs that software does what it is supposed to,
and ideally not compromising on these optimizations.&lt;&#x2F;p&gt;
&lt;p&gt;For this purpose, we have been developing &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;verus-lang&#x2F;verus&quot;&gt;Verus&lt;&#x2F;a&gt;,
a verification tool for &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;book&#x2F;&quot;&gt;the Rust programming language&lt;&#x2F;a&gt;.
Rust is increasingly popular as a systems programming language today,
but we didn’t (just) choose it because of its popularity.
Rather, it turns out that the properties that make it attractive as a systems programming language—most notably,
that it allows manual memory management while simultaneously guaranteeing memory-safety—&lt;em&gt;also&lt;&#x2F;em&gt; make it excellent
in the setting of formal verification: in some ways straightforward,
and in some ways surprising. In this blog post, I’ll explain what these ways are.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;verification-mutable-memory-and-rust&quot;&gt;Verification, mutable memory, and Rust&lt;&#x2F;h1&gt;
&lt;p&gt;First, we’re interested in proving code to be “correct”. What does that mean exactly?
Let’s get our feet wet in verification with some simple examples and then talk about a challenge that Rust helps us solve.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;intro-to-verus&quot;&gt;Intro to Verus&lt;&#x2F;h2&gt;
&lt;p&gt;The key idea behind Verus is to check additional properties of programs that Rust doesn’t check on its own.
For example, consider the following valid Rust program, operating over an 8-bit integer.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#393939;color:#dedede;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffd87;&quot;&gt;double&lt;&#x2F;span&gt;&lt;span&gt;(i: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;u8 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fed6af;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#87d6d5;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Though it’s a valid program, it (potentially) has a problem: if the argument &lt;code&gt;i&lt;&#x2F;code&gt; is more than 127, then the multiplication will overflow the 8-bit integer.
If you run Verus on it (which you can &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;play.verus-lang.org&#x2F;?version=stable&amp;amp;mode=basic&amp;amp;edition=2021&amp;amp;code=use+vstd%3A%3Aprelude%3A%3A*%3B%0A%0Averus%21+%7B%0A%0A++++fn+double%28i%3A+u8%29+-%3E+u8+%7B%0A++++++++return+i+*+2%3B%0A++++%7D%0A++++%0A%7D%0A%0Afn+main%28%29+%7B%7D%0A%0A&quot;&gt;try yourself at the Verus playground&lt;&#x2F;a&gt;),
Verus reports this error:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#393939;color:#dedede;&quot;&gt;&lt;code&gt;&lt;span&gt;error: possible arithmetic underflow&#x2F;overflow
&lt;&#x2F;span&gt;&lt;span&gt; --&amp;gt; &#x2F;playground&#x2F;src&#x2F;main.rs:6:16
&lt;&#x2F;span&gt;&lt;span&gt;  |
&lt;&#x2F;span&gt;&lt;span&gt;6 |         return i * 2;
&lt;&#x2F;span&gt;&lt;span&gt;  |                ^^^^^
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To remedy this, the programmer can declare their &lt;em&gt;intent&lt;&#x2F;em&gt;: namely, that the &lt;code&gt;double&lt;&#x2F;code&gt; function should never be called with any argument greater than 127.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#393939;color:#dedede;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffd87;&quot;&gt;double&lt;&#x2F;span&gt;&lt;span&gt;(i: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;u8
&lt;&#x2F;span&gt;&lt;span&gt;    requires i &amp;lt;= 127
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    return i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;&amp;#x2a; &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#87d6d5;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;requires&lt;&#x2F;code&gt; clause is not a standard Rust feature, but a feature of Verus: in general, Verus source code comprises both Rust code and extra directives for Verus, such as this
&lt;code&gt;requires&lt;&#x2F;code&gt; clause, also known as a &lt;em&gt;precondition&lt;&#x2F;em&gt;. In any case, Verus now accepts the program (&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;play.verus-lang.org&#x2F;?version=stable&amp;amp;mode=basic&amp;amp;edition=2021&amp;amp;code=use+vstd%3A%3Aprelude%3A%3A*%3B%0A%0Averus%21+%7B%0A%0A++++fn+double%28i%3A+u8%29+-%3E+u8%0A++++++++requires+i+%3C%3D+127%0A++++%7B%0A++++++++return+i+*+2%3B%0A++++%7D%0A++++%0A%7D%0A%0Afn+main%28%29+%7B%7D%0A%0A&quot;&gt;playground link&lt;&#x2F;a&gt;) because with the new assumption, Verus can determine that this arithmetic operation never overflows.&lt;&#x2F;p&gt;
&lt;p&gt;Furthermore, any time the developer calls &lt;code&gt;double&lt;&#x2F;code&gt; from elsewhere in the program, Verus will check that the call satisfies the precondition.
Keep in mind, also, that this is a check done statically, checked for all possible executions of the program, not a runtime check.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;specifications-and-program-correctness&quot;&gt;Specifications and program correctness&lt;&#x2F;h2&gt;
&lt;p&gt;With Verus, we are actually interested in correctness criteria that go beyond simple arithmetic bounds checks.
Usually, we are interested in proving that a program’s behavior meets some &lt;em&gt;specification&lt;&#x2F;em&gt;, as in this function that computes the maximum of two integers:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#393939;color:#dedede;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffd87;&quot;&gt;max&lt;&#x2F;span&gt;&lt;span&gt;(a: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;, b: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; (result: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    ensures
&lt;&#x2F;span&gt;&lt;span&gt;        result &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;==&lt;&#x2F;span&gt;&lt;span&gt; a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;||&lt;&#x2F;span&gt;&lt;span&gt; result &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;==&lt;&#x2F;span&gt;&lt;span&gt; b,
&lt;&#x2F;span&gt;&lt;span&gt;        result &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;&amp;gt;=&lt;&#x2F;span&gt;&lt;span&gt; a,
&lt;&#x2F;span&gt;&lt;span&gt;        result &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;&amp;gt;=&lt;&#x2F;span&gt;&lt;span&gt; b,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fed6af;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; b {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fed6af;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; a;
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fed6af;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fed6af;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; b;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Again, let’s highlight the Verus-specific parts:
first, we have the &lt;code&gt;ensures&lt;&#x2F;code&gt; clause (also known as a &lt;em&gt;postcondition&lt;&#x2F;em&gt;) serving as the function’s specification, along with the name &lt;code&gt;result&lt;&#x2F;code&gt; on the return type,
which is referenced from said postcondition.
Once again, the body of the &lt;code&gt;max&lt;&#x2F;code&gt; function is the Rust code we are verifying.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;ensures&lt;&#x2F;code&gt; clause denotes a predicate that should hold true at the end of the call to &lt;code&gt;max&lt;&#x2F;code&gt;.
This determines what it means for an implementation of &lt;code&gt;max&lt;&#x2F;code&gt; to be “correct”: it is correct if every execution of its code
returns a result that meets its specification.&lt;&#x2F;p&gt;
&lt;p&gt;So, how does Verus actually check that this property holds?
To do this, Verus (and similar tools) encode the correctness of &lt;code&gt;max&lt;&#x2F;code&gt; as logical formulae called &lt;em&gt;verification conditions&lt;&#x2F;em&gt;:&lt;&#x2F;p&gt;
&lt;p&gt;\[ a &amp;gt; b \implies result = a \implies (result = a \lor result = b) \land (result \ge a) \land (result \ge b) \]&lt;&#x2F;p&gt;
&lt;p&gt;\[ \lnot(a &amp;gt; b) \implies result = b \implies (result = a \lor result = b) \land (result \ge a) \land (result \ge b) \]&lt;&#x2F;p&gt;
&lt;p&gt;These conditions are simplified a bit for presentation, but they are close enough for intuition.
The first of these would be read as, “if \( a &amp;lt; b \) (i.e., the first branch is taken), and if \( result \) is set to the return value \( a \), then the conditions of
the ensures clause hold”. The second condition is similar, but for the &lt;code&gt;else&lt;&#x2F;code&gt; side of the branch.&lt;&#x2F;p&gt;
&lt;p&gt;If we prove the verification conditions are correct, this implies the correctness of the program according to its specification.
To do so, Verus uses an automated theorem prover—in this case, &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Z3Prover&#x2F;z3&quot;&gt;Z3&lt;&#x2F;a&gt;—to prove the verifification conditions hold for all
values of &lt;em&gt;a&lt;&#x2F;em&gt;, &lt;em&gt;b&lt;&#x2F;em&gt;, and &lt;em&gt;result&lt;&#x2F;em&gt;. This example is simple enough that Z3 can validate the conditions quickly, though for more complicated examples, the developer may need to write additional proofs
to help it out. If Z3 is unable to prove the theorem, either because it is wrong, or because it needs additional help to prove, then Verus outputs an error message like the one from
the previous section.&lt;&#x2F;p&gt;
&lt;p&gt;Specification-checking is extremely useful for situations where an implementation is optimized and handles low-level details, but we would like to provide a higher-level, mathematically precise specification.
For example:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;A program uses the bitwise operation &lt;code&gt;(x &amp;amp; (x - 1)) == 0&lt;&#x2F;code&gt; to determine if &lt;code&gt;x&lt;&#x2F;code&gt; is a power-of-2, but uses a more mathematically precise specification, \( \exists b.~ 2^b = x \).&lt;&#x2F;li&gt;
&lt;li&gt;A data-structure implements a hash table or a red-black tree, but has a specification stating that its operations are equivalent to those of a mathematical set.&lt;&#x2F;li&gt;
&lt;li&gt;A replicated data structure with a sophisticated synchronization algorithm uses a specification that it acts indistinguishably from a single copy of the data structure.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;challenge-handling-mutable-memory&quot;&gt;Challenge: handling mutable memory&lt;&#x2F;h2&gt;
&lt;p&gt;One such “low-level detail” we often have to reason about is &lt;em&gt;mutable heap state&lt;&#x2F;em&gt;.
To see why this is challenging without Rust’s help, let us set aside Rust for a moment,
and imagine we designed a programming language with general pointer types, like in C.
Consider a simple function that takes two pointers and updates one of them:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#393939;color:#dedede;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span style=&quot;color:#a0cfa1;&quot;&gt;&#x2F;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#87ae86;&quot;&gt; Imagined C-like verification language
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffd87;&quot;&gt;compute_boolean_not&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;x, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;x_not)
&lt;&#x2F;span&gt;&lt;span&gt;    ensures (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;x_not) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;== !&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;x)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt; tmp &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;= *&lt;&#x2F;span&gt;&lt;span&gt;x;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;x_not &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;= !&lt;&#x2F;span&gt;&lt;span&gt;tmp;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This program looks straightforward at first, but it actually has a problem: what if &lt;code&gt;x&lt;&#x2F;code&gt; and &lt;code&gt;x_not&lt;&#x2F;code&gt; point to the same memory?
Then &lt;code&gt;*x&lt;&#x2F;code&gt; would be updated when we update &lt;code&gt;*x_not&lt;&#x2F;code&gt;. Therefore, a tool would never be able to prove this code matches its specification—it simply isn’t true.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;rust-verification-with-verus&#x2F;compute_boolean_not_graphical.png&quot; alt=&quot;Visual representation of the above example&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;i&gt;&lt;b&gt;Left:&lt;&#x2F;b&gt; what the developer imagines happening. &lt;b&gt;Right:&lt;&#x2F;b&gt; what might actually happen.&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;p&gt;One solution is to specify that the pointers do not &lt;em&gt;alias&lt;&#x2F;em&gt; with each other, i.e., that they don’t point to the same memory location:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#393939;color:#dedede;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span style=&quot;color:#a0cfa1;&quot;&gt;&#x2F;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#87ae86;&quot;&gt; Imagined C-like verification language
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffd87;&quot;&gt;compute_boolean_not&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;x, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;x_not)
&lt;&#x2F;span&gt;&lt;span&gt;    requires x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;!=&lt;&#x2F;span&gt;&lt;span&gt; x_not        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0cfa1;&quot;&gt;&#x2F;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#87ae86;&quot;&gt; This line has been added
&lt;&#x2F;span&gt;&lt;span&gt;    ensures (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;x_not) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;== !&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;x)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt; tmp &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;= *&lt;&#x2F;span&gt;&lt;span&gt;x;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;x_not &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;= !&lt;&#x2F;span&gt;&lt;span&gt;tmp;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Recall the &lt;code&gt;requires&lt;&#x2F;code&gt; clause here indicates an assumption the function can make at the beginning of its execution.
By making this assumption, Verus can now check that the specification holds, although now every call to &lt;code&gt;compute_boolean_not&lt;&#x2F;code&gt;
will need to uphold this contract.&lt;&#x2F;p&gt;
&lt;p&gt;Unfortunately, adding these “non-aliasing conditions” gets unwieldy fast, as data structures increase both in breadth and depth.
This was our experience when we wrote the first version of &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;rust-verification-with-verus&#x2F;#further-reading&quot;&gt;VeriBetrKV&lt;&#x2F;a&gt;, a key-value store developed in &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;dafny.org&#x2F;&quot;&gt;Dafny&lt;&#x2F;a&gt;, which has a similar aliasing situation to our C-like language.
Not only were the conditions difficult to write manually, but getting them wrong often led to error messages that were difficult to diagnose.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rust-to-the-rescue&quot;&gt;Rust to the rescue&lt;&#x2F;h2&gt;
&lt;p&gt;In Rust, it isn’t common to use general-purpose pointer types. Instead, Rust uses more restricted &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch04-02-references-and-borrowing.html&quot;&gt;&lt;em&gt;reference&lt;&#x2F;em&gt; types&lt;&#x2F;a&gt;. In Rust, the types &lt;code&gt;&amp;amp;T&lt;&#x2F;code&gt; and &lt;code&gt;&amp;amp;mut T&lt;&#x2F;code&gt;
each denote a reference to a value of type &lt;code&gt;T&lt;&#x2F;code&gt;.
In the case of &lt;code&gt;&amp;amp;mut T&lt;&#x2F;code&gt;, which is specifically a &lt;em&gt;mutable&lt;&#x2F;em&gt; reference, the user is able
to modify the value behind the pointer.
Thus, in Rust&#x2F;Verus, our boolean-negation example would look like this, with the &lt;code&gt;x_not&lt;&#x2F;code&gt; parameter marked as a mutable reference.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#393939;color:#dedede;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffd87;&quot;&gt;compute_boolean_not&lt;&#x2F;span&gt;&lt;span&gt;(x: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt;, x_not: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;mut bool&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    ensures (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;x_not) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;== !&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;x)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; tmp: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;bool &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;= *&lt;&#x2F;span&gt;&lt;span&gt;x;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;x_not &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;= !&lt;&#x2F;span&gt;&lt;span&gt;tmp;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;At the machine code level, these references are just like pointers, but the Rust type system enforces additional properties: namely, a &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt; reference to a piece of data can never coexist 
with another reference to that data. Rust enforces this property because it is crucial to Rust’s guarantees about memory safety.&lt;&#x2F;p&gt;
&lt;p&gt;However, this property is also a huge boon for software verification. Because the non-aliasing property is checked by Rust’s type system,
the developer no longer has to write the non-aliasing conditions
manually. Furthermore, Rust’s type system is fast and often presents high-quality error messages when the property is violated.&lt;&#x2F;p&gt;
&lt;p&gt;One can think of this as if these non-aliasing conditions are 
inserted automatically, so the developer doesn’t have to worry about it, but in fact, the situation is even better: the verification tool can simplify the verification conditions to not include any
notion of pointer addresses in the first place! In fact, some of my colleagues have &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;rust-verification-with-verus&#x2F;#further-reading&quot;&gt;published a paper&lt;&#x2F;a&gt; quantifying the gains from this kind of simplification.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;are-reference-types-all-we-need&quot;&gt;Are reference types all we need?&lt;&#x2F;h1&gt;
&lt;p&gt;The fact that Rust works as a language at all is evidence that reference types are sufficient
&lt;em&gt;most&lt;&#x2F;em&gt; of the time. Unfortunately, most of the time isn’t good enough. The non-aliasing
reference problem gets in the way for implementing any of the following:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Doubly-linked lists&lt;&#x2F;li&gt;
&lt;li&gt;Reference-counted pointers (e.g., Rust’s &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;rc&#x2F;struct.Rc.html&quot;&gt;&lt;code&gt;Rc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, similar to C++’s &lt;code&gt;shared_ptr&lt;&#x2F;code&gt;)&lt;&#x2F;li&gt;
&lt;li&gt;Any manner of concurrent algorithm: locks, message-passing queues, memory allocators, systems with domain-specific logic for avoiding data races&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The reason these examples give difficulty is because Rust’s type system enforces that any object have a unique “owner” (unless those owners are immutable references).
However, these examples seemingly need to violate the restriction:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;rust-verification-with-verus&#x2F;dlist.png&quot; alt=&quot;Visual representation of a doubly-linked list. Each node has two incoming pointers from its neighbors, and two outgoing pointers to its neighbors.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;i&gt;In a doubly-linked list, each node has two neighbors which point to it. Thus, these nodes do not have unique owners.&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;rust-verification-with-verus&#x2F;rc.png&quot; alt=&quot;Visual representation of reference-counted smart pointer, Rc. The shared object has multiple reference objects pointing to it.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;i&gt;When working with reference-counted smart pointers, each object may have multiple reference objects. These objects need to coordinate via the reference count to drop the given object at the appropriate time. This counter does not have a unique owner.&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;rust-verification-with-verus&#x2F;queue.png&quot; alt=&quot;Visual representation of message-passing queue. The producer thread and the consumer thread each have a pointer to a shared queue buffer.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;i&gt;In a message passing queue, the producer thread and the consumer thread have to share a queue buffer to store in-flight messages. This buffer does not have a unique owner.&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;p&gt;So how can we tackle these kinds of problems?&lt;&#x2F;p&gt;
&lt;p&gt;For such things, Rust programmers need to use Rust’s notorious &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;book&#x2F;ch19-01-unsafe-rust.html&quot;&gt;“unsafe code”&lt;&#x2F;a&gt; which opts in to various Rust features that 
the type system is unable to validate are used safely. As such, the burden goes from the
type-checker to the programer to ensure they are used correctly.
Applications like the above are generally considered low-level, and they are often
relegated to time-tested libraries. It’s these kinds of low-level systems, though,
that we are especially interested in verifying! So what do we do?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;unsafe-code-in-verus-or-condititionally-safe-code&quot;&gt;Unsafe code in Verus, or: “condititionally safe code”&lt;&#x2F;h2&gt;
&lt;p&gt;With Verus, we can recover the ability to implement such things while having a computer-checked guarantee of memory safety.
A Rust feature being  “unsafe” really just means that the developer has to uphold a certain contract to use it safely, which Rust cannot check.
It is for this reason that I like to call unsafe code &lt;em&gt;conditionally safe&lt;&#x2F;em&gt;—i.e., it is safe subject to meeting
certain conditions. Rust cannot check these conditions, but Verus &lt;em&gt;can&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Here is a simple example: Rust’s common vector indexing operation performs a bounds-check to ensure there is no memory corruption from an out-of-bounds access.
Therefore, this function is &lt;em&gt;unconditionally&lt;&#x2F;em&gt; “safe” to call, no matter what index the caller provides: even if the caller provides something out-of-bounds, the program might panic and exit, but it will never corrupt memory.
However, there is a lesser-used &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;vec&#x2F;struct.Vec.html#method.get_unchecked&quot;&gt;&lt;code&gt;get_unchecked&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; operation which performs &lt;em&gt;no&lt;&#x2F;em&gt; such bounds check.
Thus, &lt;code&gt;get_unchecked&lt;&#x2F;code&gt; is only safe to call if the index is
&lt;em&gt;already known to be in-bounds&lt;&#x2F;em&gt;, thus making it unsafe (conditionally safe).
This condition can be codified as a Verus &lt;code&gt;requires&lt;&#x2F;code&gt; clause:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#393939;color:#dedede;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffd87;&quot;&gt;get_unchecked&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;(vec: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;Vec&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;, idx: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;T
&lt;&#x2F;span&gt;&lt;span&gt;    requires idx &amp;lt; vec&lt;&#x2F;span&gt;&lt;span style=&quot;text-decoration:underline;font-weight:bold;font-style:italic;color:#ffccee;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;len()
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now, Verus will check that the index is in-bounds whenever &lt;code&gt;get_unchecked&lt;&#x2F;code&gt; is called.
Thus, we can regain assurance in code that uses this function, provided that Verus is able to validate the code.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;handling-unsafe-ownership&quot;&gt;Handling unsafe ownership&lt;&#x2F;h2&gt;
&lt;p&gt;Bounds-checking makes for an easy example, but when we consider programs like the ones
diagrammed above, the situation gets a little more complicated.
Recall that what characterizes these systems is that the objects may be pointed to
from multiple owners, which have to coordinate their access somehow.&lt;&#x2F;p&gt;
&lt;p&gt;As a result, the “conditions” of the conditionally safe operations become
substantially more involved. For example, accessing data through a pointer is only safe if there is no
&lt;em&gt;data race&lt;&#x2F;em&gt;, i.e., another thread trying to access it at the same time. Such a condition seems inherently “non-local” as it involved talking about all threads at once,
and therefore is much harder to check than that of a simple index being in bounds.&lt;&#x2F;p&gt;
&lt;p&gt;However, we have already discussed that Rust’s type system allows us to ensure the unique ownership of data, which then rules out illegal operations such as data races.
Therefore, the kind of “condition” we need to check is already the exact kind of condition that Rust’s type system is designed to ensure.
The problem here is just that these particular data structures do not use the specific types that are designed to ensure this. So how can we apply Rust’s philosophy anyway?&lt;&#x2F;p&gt;
&lt;p&gt;Since the data structures we want to verify use objects that don’t obey Rust’s unique ownership, our trick is to add &lt;em&gt;new&lt;&#x2F;em&gt; objects that &lt;em&gt;do&lt;&#x2F;em&gt;.
However, we don’t want to bog down the program with extra data—that would defeat the point of writing optimized code—so these new objects are merely “conceptual proof objects.”
In verification languages, such objects are often called &lt;em&gt;ghost&lt;&#x2F;em&gt; objects, not because they are spooky, but because they have no influence on the “physical world.” The real data structures in the compiled binary
would be the ones diagramed above, but Verus treats the program as if the ghost objects were really there when generating its verification conditions.&lt;&#x2F;p&gt;
&lt;p&gt;For example, for a program that uses pointers, Verus programs can use a ghost object that represents “the right to read or write memory from the given location.”
Just like for ordinary (“real”) data, Rust’s type system ensures that ownership this object is unique. Verus in turn ensures that such an object is 
present when the program accesses the data behind the pointer. Combining both results, we can be confident that such an access really is data-race-free.
Even while multiple owners might point to the same piece of data, in the sense of physically having a pointer to it, only one owner at a time can have the &lt;em&gt;right&lt;&#x2F;em&gt; to manipulate that data.&lt;&#x2F;p&gt;
&lt;p&gt;To verify a doubly-linked list, then, we would arrange nodes with pointers in the usual way, but in addition to the “real” nodes, we would have an additional collection of ghost objects
that represent the right to access those nodes. By writing additional Verus annotations, we can explain, mathematically, how these ghost objects relate to the structure of the linked list,
and as a result we can use the ghost objects to traverse the list.
For more details, you can see &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;rust-verification-with-verus&#x2F;#further-reading&quot;&gt;our paper&lt;&#x2F;a&gt;, where we present the doubly-linked list in detail.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;further-reading&quot;&gt;Further reading&lt;&#x2F;h1&gt;
&lt;p&gt;There is currently one paper on Verus available, which introduces Verus and works out
the doubly-linked list example in detail, among others. (If you compare to this blog post,
you may notice Verus’ syntax has evolved a bit since this paper was written.)&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2303.05491&quot;&gt;Andrea Lattuada, Travis Hance, Chanhee Cho, Matthias Brun, Isitha Subasinghe, Yi Zhou, Jon Howell, Bryan Parno, and Chris Hawblitzel. &lt;em&gt;Verus: Verifying Rust Programs Using Linear Ghost Types.&lt;&#x2F;em&gt; (OOPSLA 2023)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Before Verus, we explored this space of verification techniques through a language
we developed called &lt;em&gt;Linear Dafny&lt;&#x2F;em&gt;, an extension of the verification langauge &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;dafny.org&#x2F;&quot;&gt;Dafny&lt;&#x2F;a&gt;. Verus incorporates a lot of our
learnings from Linear Dafny, which there are several papers on.
We first introduced Linear Dafny in this paper on VeriBetrKV, a verified key-value store:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;osdi20-hance.pdf&quot;&gt;Travis Hance, Andrea Lattuada, Chris Hawblitzel, Jon Howell, Rob Johnson, and Bryan Parno. &lt;em&gt;Storage Systems are Distributed Systems (So Verify Them That Way!).&lt;&#x2F;em&gt; (OSDI 2020)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Some of my colleagues quantified the utility of Linear Dafny’s type system via direct comparison:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;homes.cs.washington.edu&#x2F;%7Ejlli&#x2F;papers&#x2F;oopsla2022.pdf&quot;&gt;Jialin Li, Andrea Lattuada, Yi Zhou, Jonathan Cameron, Jon Howell, Bryan Parno, and Chris Hawblitzel. &lt;em&gt;Linear Types for Large-Scale Systems Verification.&lt;&#x2F;em&gt; (OOPSLA 2022)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Finally, we explored the combination of ghost objects and ownership types to verify
some sophisticated concurrent systems in a Linear Dafny framework called IronSync:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;osdi23-hance.pdf&quot;&gt;Travis Hance, Yi Zhou, Andrea Lattuada, Reto Achermann, Alex Conway, Ryan Stutsman, Gerd Zellweger, Chris Hawblitzel, Jon Howell, and Bryan Parno. &lt;em&gt;Sharding the State Machine: Automated Modular Reasoning for Complex Concurrent Systems.&lt;&#x2F;em&gt; (OSDI 2023)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;related-work&quot;&gt;Related work&lt;&#x2F;h1&gt;
&lt;p&gt;Verus is far from the only Rust verification tool around.
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;plv.mpi-sws.org&#x2F;rustbelt&#x2F;popl18&#x2F;&quot;&gt;RustBelt&lt;&#x2F;a&gt; is a framework for verifying unsafe code within a precise mathematical formalism of a model of the Rust langauge.
It is notable because it can prove general memory-safety theorems about Rust’s type system, even in the presence of libraries that use unsafe code.
However, it does not take &lt;em&gt;advantage&lt;&#x2F;em&gt; of Rust’s type system for the sake of verification, and it doesn’t target developers writing actual Rust code.&lt;&#x2F;p&gt;
&lt;p&gt;Other tools which, like Verus, target developers include &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.pm.inf.ethz.ch&#x2F;research&#x2F;prusti.html&quot;&gt;Prusti&lt;&#x2F;a&gt;,
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;model-checking&#x2F;kani&quot;&gt;Kani&lt;&#x2F;a&gt;,
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2206.07185&quot;&gt;Aeneas&lt;&#x2F;a&gt;,
and &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;xldenis&#x2F;creusot&quot;&gt;Creusot&lt;&#x2F;a&gt;.
Of these, the one most similar to Verus is likely Creusot, which takes advantage of the Rust type system in a similar way to generate simple verification conditions.
Creusot is also notable for its “prophecy encoding” of mutable references, which is more general than Verus’ current mutable reference support.
What distinguishes Verus, by contrast, is its support for these ghost objects and especially their use in concurrency.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h1&gt;
&lt;p&gt;Rust’s type system, and similar type systems that enforce unique ownership over data,
are enormously helpful in designing a verification language for low-level code.
Just as Rust guarantees memory safety, thus taking the burden off the developer in the common case, 
Verus takes advantage of the same to remove the burden of complex aliasing conditions for verification developers.
More surprisingly, though, we can apply Rust’s type system even for code that initially seems very un-Rust-like, which is common in highly-optimized systems code.
Specifically,
by utilizing ghost objects
we recover the ability to use Rust’s ownership system
(together with Verus to check conditionally safe code)
to check code where the type system would not help in ordinary Rust.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Provably-Safe Sandboxing with WebAssembly</title>
		<published>2023-07-25T00:00:00+00:00</published>
		<updated>2023-07-25T00:00:00+00:00</updated>
		<link href="https://www.cs.cmu.edu/~csd-phd-blog/2023/provably-safe-sandboxing-wasm/" type="text/html"/>
		<id>https://www.cs.cmu.edu/~csd-phd-blog/2023/provably-safe-sandboxing-wasm/</id>
		<content type="html">&lt;blockquote&gt;
&lt;p&gt;What if you could run untrusted code and still be able to sleep at night, safe and sound?&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Disclaimer: our award-winning work &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;provably-safe-sandboxing-wasm&#x2F;#references&quot;&gt;[1]&lt;&#x2F;a&gt; can only calm your unsafe-software related fears; we recommend complementing this by additionally checking for monsters under your bed, and leaving a night light on, for any fears of things that go bump in the night.&lt;&#x2F;p&gt;
&lt;figure&gt;&lt;a name=&quot;fig1&quot;&gt;&lt;&#x2F;a&gt;&lt;br&gt;
&lt;p&gt;&lt;img src=&quot;.&#x2F;intra-process-sandboxing.svg&quot; alt=&quot;A block diagram, representing intra-process sandboxing. Multiple sandboxes are shown inside a single host process, each of which interact via an API with the runtime. The runtime itself interacts with the kernel via syscalls. Multiple sandboxes can run within a single process, and multiple processes can run on the same OS kernel.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;figcaption&gt;Figure 1: Intra-process sandboxing&lt;&#x2F;figcaption&gt;
&lt;p&gt;&lt;br&gt;&lt;&#x2F;figure&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Whether you want to include third party libraries in your code, support software plugins, use a smart content delivery network, or just browse the Web, you might need to execute untrusted code, which creates a risk that it will compromise its environment. Intra-process software sandboxing (&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;provably-safe-sandboxing-wasm&#x2F;#fig1&quot;&gt;Figure 1&lt;&#x2F;a&gt;), such as with Software Fault Isolation (SFI), is a useful primitive that allows for safe and lightweight execution of such untrusted code in the same process as its environment. Unfortunately, despite being a well-studied technique with a rich and long history, previous efforts to deploy it in production have failed, due to technical and marketplace hurdles, such as requiring access to original source code, complex binary rewriting, or only being supported by a single vendor.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;webassembly.org&#x2F;&quot;&gt;WebAssembly&lt;&#x2F;a&gt; (Wasm) is ideally positioned to provide this crucial primitive and support such applications, since Wasm promises both safety &lt;em&gt;and&lt;&#x2F;em&gt; performance, while serving as a popular compiler target for many high-level languages. As a virtual architecture designed with sandboxing in mind, it has clean, succinct, and well-defined semantics, allowing for safe execution of high-performance code on the Web. However, this same design can also benefit non-Web applications, since the Wasm standard explicitly separates the core Wasm language from the specific API provided to each Wasm module by the runtime or other modules. For example, instead of offering a Web-oriented API, (say) for manipulating the DOM, many runtimes offer the WebAssembly System Interface (WASI) API to run Wasm beyond the Web. All of this has made Wasm an attractive compilation target, and compilers for most popular languages, such as C, C++, Rust, Java, Go, C#, PHP, Python, TypeScript, Zig, and Kotlin, now support it as a target. Thus, a single compiler &lt;em&gt;from&lt;&#x2F;em&gt; Wasm to executable code is sufficient to immediately support sandboxed code execution for all such languages. This makes Wasm an attractive narrow waist to provide high-performance lightweight sandboxing.&lt;&#x2F;p&gt;
&lt;p&gt;However, Wasm’s safety guarantees are only as strong as the implementation that enforces them. While Wasm might seem to immediately provide sandboxing, note that the actual implementation of the compiler from Wasm is a critical part of the trusted computing base (TCB) for the guarantee of sandboxing. In particular, any bug in the compiler could threaten the sandboxing protections, and indeed such bugs have been found in existing runtimes, and would lead to arbitrary code execution by an adversary. For example, using carefully crafted Wasm modules, an attacker could achieve:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;a memory-out-of-bounds read in Safari&#x2F;WebKit using a logic bug (CVE-2018-4222),&lt;&#x2F;li&gt;
&lt;li&gt;memory corruption in Chrome&#x2F;V8 using an integer overflow bug (CVE-2018-6092),&lt;&#x2F;li&gt;
&lt;li&gt;an arbitrary memory read in Chrome&#x2F;V8 using a parsing bug (CVE-2017-5088),&lt;&#x2F;li&gt;
&lt;li&gt;arbitrary code execution in Safari&#x2F;WebKit using an integer overflow bug (CVE-2021-30734),&lt;&#x2F;li&gt;
&lt;li&gt;a sandbox escape in both Lucet &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;provably-safe-sandboxing-wasm&#x2F;#references&quot;&gt;[6]&lt;&#x2F;a&gt; and Wasmtime &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;provably-safe-sandboxing-wasm&#x2F;#references&quot;&gt;[7]&lt;&#x2F;a&gt; using an optimization bug (CVE-2021-32629),&lt;&#x2F;li&gt;
&lt;li&gt;a memory-out-of-bounds read&#x2F;write in Wasmtime (CVE-2023-26489),&lt;&#x2F;li&gt;
&lt;li&gt;and many others.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;A plausible explanation for such disastrous sandbox-compromising bugs—even in code designed with sandboxing as an explicit focus, is that the correct (let alone secure) implementation of high-performance compilers is difficult and remains an active area of research, despite decades of work.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;span style=&quot;color:rgba(65,120,150,1);font-size:1.3rem;margin:0.5em 1em 0.5em 1em;display:block;&quot;&gt;Upon reviewing the design space for executing Wasm code, we identified a crucial gap: Wasm implementations that provide &lt;em&gt;both&lt;&#x2F;em&gt; strong security and high performance. In our work, we thus propose, explore, and implement two distinct techniques, with varying performance and development complexity, which guarantee safe sandboxing using provably-safe compilers.&lt;&#x2F;span&gt; The first draws on traditional formal methods to produce mathematical, machine-checked proofs of safety. The second carefully embeds Wasm semantics in safe Rust code such that the Rust compiler can emit safe executable code with good performance. We describe each of these techniques in the upcoming sections, but additionally refer the interested reader to our paper &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;provably-safe-sandboxing-wasm&#x2F;#references&quot;&gt;[1]&lt;&#x2F;a&gt; for further details.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;vwasm-a-formally-verified-sandboxing-compiler&quot;&gt;vWasm: A Formally Verified Sandboxing Compiler&lt;&#x2F;h2&gt;
&lt;p&gt;The first of our techniques, implemented as an open-source compiler, vWasm &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;provably-safe-sandboxing-wasm&#x2F;#references&quot;&gt;[2]&lt;&#x2F;a&gt;, achieves provably-safe sandboxing via formal verification. Formal verification of software consists of writing a formal (mathematical) statement of the property we wish to prove about the software, and then writing a formal proof that shows that this statement is true for our software. The proof is machine-checked and thus provides the highest degree of assurance in its correctness. In contrast to techniques such as software testing, fuzzing, and manual reviews, formal verification is able to reason about all execution paths, thereby accounting for any possible input. This means that behaviors like buffer overflows, use-after-frees, etc. are completely ruled out. We describe vWasm’s top-level property, as well as our proof strategy, shortly.&lt;&#x2F;p&gt;
&lt;p&gt;Our choice of verification tool, F* &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;provably-safe-sandboxing-wasm&#x2F;#references&quot;&gt;[4]&lt;&#x2F;a&gt;, is a general-purpose functional programming language with effects, built for formal verification. Syntactically, it is closest to languages from the ML family (such as OCaml, F#, or SML). It has the full expressive power of dependent types, and has proof automation backed by Z3, an SMT solver. Code written in F* can be extracted to multiple languages, and for vWasm, we use F*’s OCaml extraction. Proofs are written within vWasm as a combination of pre-&#x2F;post-conditions, extrinsic lemmas, intrinsic dependently-typed values, and layered effects.&lt;&#x2F;p&gt;
&lt;p&gt;vWasm is implemented as a compiler from Wasm to x86-64 (abbreviated as x64 henceforth), but it is designed to keep most of its code and proofs generic with respect to the target architecture. Here, we describe the process of compiling to x64, but the techniques generalize in a straightforward way to other architectures such as ARM. In compiling from Wasm to x64, there are three important conceptual stages: (i) a frontend which compiles Wasm to an architecture-parametric intermediate representation (IR), (ii) a sandboxing pass which acts upon the architecture-parametric IR, and (iii) a printer which outputs the x64 assembly code.&lt;&#x2F;p&gt;
&lt;p&gt;The frontend for the compiler is both untrusted and unverified. This means that one neither needs to trust its correctness for the overall theorem statement to be true, nor does one need to write proofs about it. Note that this is in stark contrast with traditional compiler verification, such as with CompCert &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;provably-safe-sandboxing-wasm&#x2F;#references&quot;&gt;[5]&lt;&#x2F;a&gt;, where any stage of the compilation must either be trusted or verified. This means that we are free to use any compiler technology for the compiler’s frontend, including arbitrarily complicated optimizations, as long as it outputs code within our architecture-parametric IR. Since compiler optimization is orthogonal to our primary goal, for vWasm’s frontend, we implemented only a simple register allocator and a basic peep-hole optimizer. We leave other optimizations for future work.&lt;&#x2F;p&gt;
&lt;p&gt;On the other end of the compilation pipeline is the x64 assembly printer, which is trusted to be correct. This means it is included in vWasm’s overall TCB, but we note that the printer is largely a straightforward one-to-one translation of our IR to strings, making it fairly simple to audit.&lt;&#x2F;p&gt;
&lt;p&gt;Finally, the sandboxing pass, which lies between the above two, is untrusted but verified to be correct. We define this formally below, but informally, this means that the sandboxing code has been proven (and the proof mechanically checked) to produce safely sandboxed code, given any input. Within the sandboxing pass, all accesses (reads or writes) into the Wasm module’s linear memory, indirect function call table, imports, globals, etc. are proven (sometimes after suitable transformations) to be safe. To prove sandbox safety, we additionally prove that the sandboxing pass also guarantees (a restricted form of) Control-Flow Integrity (CFI) that ensures that any checks performed for sandboxing cannot be bypassed, and thus must be obeyed.&lt;&#x2F;p&gt;
&lt;p&gt;Formally reasoning about the safety of sandboxing requires first defining a machine model, and then defining what sandbox safety is in that model. Our machine model covers the subset of x64 targeted by the compiler. A simplified version of this model can be found in our paper, while the complete model can be found in our open-sourced code. We define the semantics for x64 as small-step semantics, allowing for reasoning about even potentially infinitely running code. Within this machine model, the program state contains an &lt;code&gt;ok&lt;&#x2F;code&gt; field, which is set to the value &lt;code&gt;AllOk&lt;&#x2F;code&gt; if and only if, until that point in execution, nothing invalid has occurred. Crucially, this also means that no accesses outside the memory allocated to the module have occurred. Sandboxing is safe if and only if, informally, starting from any initial &lt;code&gt;AllOk&lt;&#x2F;code&gt; state, executing the sandboxed code for any number of steps leads to an &lt;code&gt;AllOk&lt;&#x2F;code&gt; state.&lt;&#x2F;p&gt;
&lt;p&gt;Written more formally in F*, but still slightly simplified for easier reading:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#393939;color:#dedede;&quot;&gt;&lt;code&gt;&lt;span&gt;val sandbox_compile
&lt;&#x2F;span&gt;&lt;span&gt;  (a:aux) (c:code) (s:erased state): Err code
&lt;&#x2F;span&gt;&lt;span&gt;    (requires (
&lt;&#x2F;span&gt;&lt;span&gt;        (s.ok = AllOk) &#x2F;\
&lt;&#x2F;span&gt;&lt;span&gt;        (reasonable_size a.sandbox_size s.mem) &#x2F;\
&lt;&#x2F;span&gt;&lt;span&gt;        (s.ip `in_code` c) &#x2F;\ ...))
&lt;&#x2F;span&gt;&lt;span&gt;    (ensures (fun c&amp;#39; -&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;        forall n. (eval_steps n c&amp;#39; s).ok = AllOk))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;br&gt;
&lt;p&gt;This statement, written as pre- and post-conditions for the sandboxing pass &lt;code&gt;sandbox_compile&lt;&#x2F;code&gt;, shows that any code (&lt;code&gt;c&#x27;&lt;&#x2F;code&gt;) output by the sandboxer is formally guaranteed via the machine-checked proof to be safe. The pass takes two arguments &lt;code&gt;a&lt;&#x2F;code&gt; (auxiliary data) and &lt;code&gt;c&lt;&#x2F;code&gt; (the input program), and a computationally-irrelevant argument &lt;code&gt;s&lt;&#x2F;code&gt; (the initial state of the program, which is used for reasoning in our proofs, but that is erased when running the compiler), and returns output code &lt;code&gt;c&#x27;&lt;&#x2F;code&gt; under the custom effect &lt;code&gt;Err&lt;&#x2F;code&gt; (which allows the compiler to quit early upon error, for example if it finds a call to a non-existent function).  The statement guarantees that as long as the pre-conditions in the requires clause are satisfied, the post-condition in the ensures clause provably holds on the produced output code. The pre-conditions say that the initial state must be safe, have a reasonable sandbox size, and start from a valid location in the code; if these conditions are met, the output code &lt;code&gt;c&#x27;&lt;&#x2F;code&gt; will be safe when executed for any number of steps &lt;code&gt;n&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The proofs for this theorem span approximately 3,500 lines of F* code, not including the machine model or any of the supporting framework we built to write this proof. In total, vWasm consists of approximately 15,000 lines of F* code and proofs, and required approximately two person-years of development effort.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rwasm-high-performance-informally-proven-safe-sandboxing&quot;&gt;rWasm: High-Performance Informally-Proven-Safe Sandboxing&lt;&#x2F;h2&gt;
&lt;p&gt;Our second technique, implemented as an open-source compiler, rWasm &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;provably-safe-sandboxing-wasm&#x2F;#references&quot;&gt;[3]&lt;&#x2F;a&gt;, achieves provably-safe sandboxing via a careful embedding of Wasm semantics into safe Rust, such that the Rust compiler can then emit high-performance, safe machine code. This approach provides multiple benefits, such as portability across architectures, performance that is competitive with other unsafe compilers, and the ability to introduce runtime extensions (such as inline reference monitors—IRMs) that can be optimized in-tandem with the executed code.&lt;&#x2F;p&gt;
&lt;p&gt;Our insight for this approach is that the specific property of safe sandboxing is heavily intertwined with memory safety. In particular, code written in a memory-safe language cannot escape the confines of the memory provided to it. Informally, this means that by lifting (potentially unsafe) code to a memory-safe language, and then compiling that lifted code to machine code, the generated machine code must be safely sandboxed, due to the memory safety of the intermediate memory-safe language.&lt;&#x2F;p&gt;
&lt;p&gt;While other memory-safe languages would also suffice to obtain safe sandboxing, we pick Rust as our memory-safe language of choice for rWasm, since it is a non-garbage-collected systems-oriented language, which allows us to obtain predictable performance. While Rust &lt;em&gt;does&lt;&#x2F;em&gt; have a non-memory-safe escape hatch via the &lt;code&gt;unsafe&lt;&#x2F;code&gt; keyword (since certain scenarios, such as writing an operating system, might need more control than directly allowed by the language), as long as this keyword is not used (ensured by the declaration &lt;code&gt;#![forbid(unsafe)]&lt;&#x2F;code&gt;), Rust guarantees memory safety. Given the prevalence of Rust in industry, and how seriously the Rust team takes unsoundness bugs, safe Rust is thus battle-tested to be memory safe, even if not (yet) proven to be so. Early efforts towards formalization of Rust and its security guarantees have already begun, such as with the RustBelt and Oxide projects.&lt;&#x2F;p&gt;
&lt;p&gt;We implement all stages of rWasm in safe Rust, but note that none of it needs to be trusted or verified. This means we do not need to depend upon the safety or correctness of any part of rWasm for the safety of the produced executable machine code. Instead, the safety of the produced code simply comes from the lack of any &lt;code&gt;unsafe&lt;&#x2F;code&gt; in the generated Rust code (and that unsafe-free Rust guarantees memory safety, as mentioned before). Contrast this with say, wasm2c, which requires either trusting (in addition to the C compiler itself) the wasm2c compiler, or its generated C code, since C does not guarantee memory safety.&lt;&#x2F;p&gt;
&lt;p&gt;Astute readers will note that sandbox safety in any type-safe language also depends on the language’s runtime libraries. Fortunately, rWasm imports nothing, uses only allocation-related features (for &lt;code&gt;Vec&lt;&#x2F;code&gt;), and even eliminates dependency on the Rust standard library via the &lt;code&gt;#![no_std]&lt;&#x2F;code&gt; directive. As with any sandbox, care is required when exposing an API to sandboxed code (e.g., to avoid APIs enabling sandbox bypasses directly or via confused deputies), but such concerns are orthogonal to sandbox construction.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;evaluation&quot;&gt;Evaluation&lt;&#x2F;h2&gt;
&lt;p&gt;How do vWasm and rWasm perform in practice? We measure both techniques on a collection of quantitative and qualitative metrics, and while more details can be found in our full paper, we show some selected results here.&lt;&#x2F;p&gt;
&lt;figure&gt;&lt;a name=&quot;fig2&quot;&gt;&lt;&#x2F;a&gt;&lt;br&gt;
&lt;p&gt;&lt;img src=&quot;.&#x2F;execution-time.svg&quot; alt=&quot;A graph, plotting normalized slowdown (on a log scale) on the y-axis against the Wasm runtimes on the x-axis. A summary of the graph is in the upcoming text.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;figcaption&gt;Figure 2: Mean execution time of PolyBench-C benchmarks across the Wasm runtimes, normalized to pure native execution. Interpreters have square brackets; just-in-time (JIT) compilers have braces; the rest are ahead-of-time (AOT) compilers. vWasm* disables sandboxing.&lt;&#x2F;figcaption&gt;
&lt;p&gt;&lt;br&gt;&lt;&#x2F;figure&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Run-time performance is critical for practical adoption in most applications. Hence, we benchmark our compilers and various baselines using the PolyBench-C benchmark suite, which consists of thirty programs and has been a standard benchmark suite for Wasm since its inception. &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;provably-safe-sandboxing-wasm&#x2F;#fig2&quot;&gt;Figure 2&lt;&#x2F;a&gt; summarizes our results, showing the normalized execution time of the benchmarks on the Wasm runtimes.  Each point in the chart is the ratio of the mean time taken to execute the benchmark with the particular runtime vs. the mean time taken to execute by compiling the C code directly to non-sandboxed x64, skipping Wasm entirely.&lt;&#x2F;p&gt;
&lt;p&gt;The results indicate that, unsurprisingly, compiled code strictly outperforms interpreted code for run-time performance. &lt;span style=&quot;color:rgba(65,120,150,1);font-size:1.3rem;margin:0.5em 1em 0.5em 1em;display:block;&quot;&gt;With respect to our compilers, we see that vWasm consistently outperforms the interpreters on all benchmarks, and that rWasm is competitive even with the compilers which are optimized for speed, and not necessarily safety.&lt;&#x2F;span&gt; We note that the relative performance amongst the compilers can vary drastically based upon the workload (for example, on some of the longer-running programs in the benchmark suite, rWasm is more than twice as fast as WAVM &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;provably-safe-sandboxing-wasm&#x2F;#references&quot;&gt;[8]&lt;&#x2F;a&gt;, which itself is twice as fast as rWasm on other benchmarks). Looking at vWasm and vWasm* (which is vWasm but with the sandboxing pass disabled), we find that the run time is marginally affected (by only 0.2%), indicating that almost all of the slowdown for vWasm, compared to other compilers, is due to the unverified portion of the compiler, which can be improved without needing to write any new proofs or even impacting existing proofs.&lt;&#x2F;p&gt;
&lt;p&gt;Next, we quantify the development effort needed to implement both vWasm and rWasm. The former took approximately two person-years to develop, including both code and proofs, while the latter took one person-month. This stark contrast is a testament to the daunting amount of work formal verification requires, even with modern, automated tools like F*. It also illustrates the significant benefit of rWasm’s carefully leveraging Rust’s investment in safety.&lt;&#x2F;p&gt;
&lt;p&gt;Finally, provable safety is an important property of a verified sandboxing compiler, but one might wish to prove other properties, such as traditional compiler correctness. Here, vWasm has the upper hand, as this is feasible to do in F*, and we have even structured the compiler to make such proofs possible. In contrast, proving correctness for rWasm would be a challenging task, since one would need to formally model the Rust language, show that rWasm preserves Wasm semantics in compiling to Rust, and then implement a semantics-preserving Rust compiler (or prove &lt;code&gt;rustc&lt;&#x2F;code&gt; as semantics-preserving). The nature of the provable sandboxing property is what puts it into the sweet spot where we obtain it “for free” when compiling to Rust, and we believe there may be other such properties where one can obtain provable guarantees in a similar fashion. However, all these properties are a strict subset of what might be proven for an implementation like vWasm, which is built in a full-blown verification-oriented language.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In this work, we have explored two concrete points in the design space for implementing a sandboxing execution environment, with a focus on WebAssembly. We proposed designs for these two points, implemented them as open-source tools, vWasm and rWasm, and evaluated them on a collection of both quantitative and qualitative metrics. We show that run-time performance and provable safety are not in conflict, and indeed rWasm is the first Wasm runtime that is both provably-sandboxed and fast.&lt;&#x2F;p&gt;
&lt;p&gt;We refer the interested reader to our paper &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;provably-safe-sandboxing-wasm&#x2F;#references&quot;&gt;[1]&lt;&#x2F;a&gt; and to our open-source tools vWasm &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;provably-safe-sandboxing-wasm&#x2F;#references&quot;&gt;[2]&lt;&#x2F;a&gt; and rWasm &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;provably-safe-sandboxing-wasm&#x2F;#references&quot;&gt;[3]&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;A version of this blogpost was previously posted as an &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;publications&#x2F;loginonline&#x2F;provably-safe-multilingual-software-sandboxing-using-webassembly&quot;&gt;article in USENIX ;login:&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;a name=&quot;references&quot;&gt;&lt;&#x2F;a&gt;
&lt;small&gt;
[1] Provably-Safe Multilingual Software Sandboxing using WebAssembly. Jay Bosamiya, Wen Shih Lim, and Bryan Parno. In Proceedings of the USENIX Security Symposium, August, 2022. Distinguished Paper Award &lt;em&gt;and&lt;&#x2F;em&gt; Internet Defense Prize. &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;conference&#x2F;usenixsecurity22&#x2F;presentation&#x2F;bosamiya&quot;&gt;https:&#x2F;&#x2F;www.usenix.org&#x2F;conference&#x2F;usenixsecurity22&#x2F;presentation&#x2F;bosamiya&lt;&#x2F;a&gt;&lt;br&gt;
[2] vWasm: A formally-verified provably-safe sandboxing Wasm-to-native compiler. &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;secure-foundations&#x2F;vWasm&#x2F;&quot;&gt;https:&#x2F;&#x2F;github.com&#x2F;secure-foundations&#x2F;vWasm&#x2F;&lt;&#x2F;a&gt;&lt;br&gt;
[3] rWasm: A cross-platform high-performance provably-safe sandboxing Wasm-to-native compiler. &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;secure-foundations&#x2F;rWasm&#x2F;&quot;&gt;https:&#x2F;&#x2F;github.com&#x2F;secure-foundations&#x2F;rWasm&#x2F;&lt;&#x2F;a&gt;&lt;br&gt;
[4] F*: A Proof-Oriented Programming Language. &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;fstar-lang.org&#x2F;&quot;&gt;https:&#x2F;&#x2F;fstar-lang.org&#x2F;&lt;&#x2F;a&gt;&lt;br&gt;
[5] Xavier Leroy, Sandrine Blazy, Daniel Kästner, Bernhard Schommer, Markus Pister, and Christian Ferdinand. CompCert - a formally verified optimizing compiler. In Embedded Real Time Software and Systems (ERTS). SEE, 2016.&lt;br&gt;
[6] Announcing Lucet: Fastly’s native WebAssembly compiler and runtime. &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.fastly.com&#x2F;blog&#x2F;announcing-lucet-fastly-native-webassembly-compiler-runtime&quot;&gt;https:&#x2F;&#x2F;www.fastly.com&#x2F;blog&#x2F;announcing-lucet-fastly-native-webassembly-compiler-runtime&lt;&#x2F;a&gt;, March 2019.&lt;br&gt;
[7] Wasmtime: A small and efficient runtime for WebAssembly &amp;amp; WASI. &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;wasmtime.dev&#x2F;&quot;&gt;https:&#x2F;&#x2F;wasmtime.dev&#x2F;&lt;&#x2F;a&gt;&lt;br&gt;
[8] WAVM: WebAssembly virtual machine. &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;wavm.github.io&#x2F;&quot;&gt;https:&#x2F;&#x2F;wavm.github.io&#x2F;&lt;&#x2F;a&gt;&lt;br&gt;
&lt;&#x2F;small&gt;&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Code Conversion in Distributed Storage Systems</title>
		<published>2023-07-19T00:00:00+00:00</published>
		<updated>2023-07-19T00:00:00+00:00</updated>
		<link href="https://www.cs.cmu.edu/~csd-phd-blog/2023/convertible-codes/" type="text/html"/>
		<id>https://www.cs.cmu.edu/~csd-phd-blog/2023/convertible-codes/</id>
		<content type="html">&lt;p&gt;&lt;a name=&quot;fig-intro&quot;&gt;&lt;&#x2F;a&gt;
&lt;img src=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;conversion_intro.png&quot; alt=&quot;Code conversion&quot; &#x2F;&gt;
&lt;em&gt;Figure 1: diagram showing the code conversion process in a distributed storage system.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;Today’s society is data-driven, and many of the applications that society relies on require storing ever-increasing amounts of data.
To this end, distributed storage systems have become the foundation of the data infrastructure, for example cloud storage systems.
These large-scale systems are typically run on massive clusters which have thousands to millions of disks, and store amounts of data on the scale of exabytes (\(10^{18}\) bytes).
At this large scale, failures become a common ocurrence.
Given the fundamental role that distributed storage systems play in supporting other applications, they must guarantee high levels of reliability despite these failures.
One common way to ensure reliability is through replication.
However, duplicating (or triplicating) the amount space used with replication is prohibitively expensive.
Instead, most current large-scale storage systems primarily employ &lt;em&gt;erasure codes&lt;&#x2F;em&gt;.
An erasure code encodes data in a way that makes it resilient against failures with lower overhead than replication.&lt;&#x2F;p&gt;
&lt;p&gt;The level of fault tolerance and the storage space consumed by an erasure code are determined by its parameters.
For example, the popular Reed-Solomon codes (and other traditional maximum-distance separable codes) have two main parameters: code length (\(n\)) and dimension (\(k\)).
These parameters are typically set based on the failure rate of storage devices, the required degree of reliability, and some additional requirements on system performance and storage overhead.&lt;&#x2F;p&gt;
&lt;p&gt;In practice, there are multiple reasons which necessitate changing the parameters of an erasure code for &lt;em&gt;already-encoded data&lt;&#x2F;em&gt;.
The process of transforming the data from the old encoding to the new encoding is known as &lt;em&gt;code conversion&lt;&#x2F;em&gt; (see &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;#fig-intro&quot;&gt;figure 1&lt;&#x2F;a&gt;).
One of the reasons for doing code conversions is &lt;em&gt;disk-adaptive redundancy&lt;&#x2F;em&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;#kadekodi2019cluster&quot;&gt;Kadekodi et al. 2019&lt;&#x2F;a&gt;):
it has been shown that the failure rate of disks can vary drastically across make&#x2F;models and over time (&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;#schroeder2007disk&quot;&gt;Schroeder and Gibson, 2007&lt;&#x2F;a&gt;), and that significant savings in storage space (and hence operating costs) can be achieved by tuning the code parameters to the observed failure rates.
For example, on production cluster traces from Google, disk-adaptive redundancy can lead to up to 25% space savings (&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;#kadekodi2020pacemaker&quot;&gt;Kadekodi et al. 2020&lt;&#x2F;a&gt;).
Due to the large scale, this translates to savings of millions of dollars and significant reductions in the carbon footprint.
Another reason for code conversion is the changes in the popularity of data.
More popular data is typically encoded with higher redundancy (to support faster reads) and less popular data is encoded with less redundancy (for storage efficiency).
Thus, as popularity of the data changes, it is beneficial to change the parameters of the code used to encode the data (&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;#xia2015tale&quot;&gt;Xia et al. 2015&lt;&#x2F;a&gt;).
In this case, data needs to be redistributed to make use of the new disks I&#x2F;O throughput.&lt;&#x2F;p&gt;
&lt;p&gt;The default approach to code conversion is to read all data, re-encode it, and write it back.
This approach requires a large amount of disk I&#x2F;O access and bandwidth which, due to inherent physical limitations of hard disk drives, are very scarce resources.
The following figure (from &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;#kadekodi2020pacemaker&quot;&gt;Kadekodi et al. 2020&lt;&#x2F;a&gt;) shows the fraction of the total cluster I&#x2F;O used by code conversion in a simulation using real-world cluster traces.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;heart_mono_front.png&quot; alt=&quot;Conversion IO in simulated cluster&quot; &#x2F;&gt;
&lt;em&gt;Figure 2: Trace-based simulation of a cluster using the default approach to code conversion. X-axis represents calendar date, left Y-axis represents the total fraction of the IO used by conversion, right Y-axis shows the size of the cluster in terms of the number of disks.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Observe that the total IO used by code conversion can use up to 100% of the cluster IO during significant periods of time.
Therefore, the default approach to code conversion can easily overwhelm a storage system, interfering with other important (foreground) tasks such as serving user requests.
In this post, we summarize our work on &lt;strong&gt;convertible codes&lt;&#x2F;strong&gt;, which are erasure codes that can be converted more efficiently than the default approach.
So far the information theory community has extensively studied various aspects of storage codes such as rate, update cost, repair bandwidth, and repair locality.
The conversion problem opens up a new dimension to optimize for when designing storage codes.
There are several open problems in this new design space, with a high potential for real-world impact.&lt;&#x2F;p&gt;
&lt;p&gt;We start by providing some &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;#background&quot;&gt;background&lt;&#x2F;a&gt; about storage systems, erasure codes, and the way erasure codes are used in storage systems.
Then, we introduce and formally define &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;#conversion&quot;&gt;code conversion and convertible codes&lt;&#x2F;a&gt;.
Afterwards, we provide a &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;#min-cost&quot;&gt;summary of our results&lt;&#x2F;a&gt; and showcase some examples that show how convertible codes can reduce conversion cost.
Finally, we conclude with some &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;#conclusion&quot;&gt;open problems&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;background&quot;&gt;Background on storage systems&lt;&#x2F;h2&gt;
&lt;p&gt;Many modern applications require storing large amounts of data; amounts which far exceed the capacity of a single disk drive.
In such cases, data needs to be distributed across many disks, attached to many different machines.
One immediate problem that emerges in this scenario is that, as the number of components in the system increases, the probability that at least one component fails becomes very high.
Because distributed systems need to keep running despite of these failures, reliability is an essential part of their design.&lt;&#x2F;p&gt;
&lt;p&gt;The simplest way of adding reliability to a distributed storage system is to use &lt;em&gt;replication&lt;&#x2F;em&gt;: each piece of data has multiple copies each stored in a different disk, so that if any disk fails, no data is permanently lost.
However, replication significantly increases the total amount of space used by the system, which makes it very expensive to use in large-scale systems.
For example, three-replication (which tolerates up to two failures) is used in some systems, and it uses 200% additional storage.
Storage cost is normally measured as the ratio of the total space used to the size of the original data, and is called &lt;em&gt;storage overhead&lt;&#x2F;em&gt;.
So three-replication incurs a storage overhead of 3.&lt;&#x2F;p&gt;
&lt;p&gt;Given the high cost of replication, nowadays most storage systems use &lt;em&gt;erasure coding&lt;&#x2F;em&gt; instead, which can offer the same (or even higher) reliability guarantees while using much less storage space.
For example, an \([5, 3]\) MDS code (explained in detail in &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;#erasure-codes&quot;&gt;Background on erasure codes&lt;&#x2F;a&gt;) can tolerate up to two failures (same as three-replication) and has a storage overhead of \(\frac{5}{3} = 1.66\), i.e., only 66.6% extra storage.&lt;&#x2F;p&gt;
&lt;p&gt;Storage overhead is one of the main cost metrics for distributed storage systems.
This is because the top costs of running a system come from the cost of buying all the necessary hardware, and operating it: i.e. providing infrastructure, power, cooling, networking, etc.
Such is the scale of these systems, that even a single-digit percentage reduction in storage overhead is significant.&lt;&#x2F;p&gt;
&lt;p&gt;There are many other costs and metrics apart from storage overhead.
Among them, disk I&#x2F;O resources come first, because it is important for the performance of the system.
HDDs offer relatively low I&#x2F;O bandwidth compared to the total amount of storage space, so this is often the bottleneck of the system’s throughput.
Due to the mechanical overheads involved in moving the read head to the right place within a disk, the number of I&#x2F;O operations (called accesses) is also an important metric.
Similarly, the amount of network I&#x2F;O operations, CPU, and memory usage are also important.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;design&quot;&gt;Distributed storage system design&lt;&#x2F;h3&gt;
&lt;p&gt;One of the most well-known types of distributed storage systems is &lt;abbr title=&quot;Redundant Array of Inexpensive Disks&quot;&gt;RAID&lt;&#x2F;abbr&gt;.
A RAID system typically consists of an array of \(n\) disks with same capacity attached to a single machine.
Data is encoded with an \([n, k]\) MDS (maximum distance separable) code and for each codeword, each of the \(n\) codeword symbols is placed on a different disk.&lt;&#x2F;p&gt;
&lt;p&gt;Modern distributed storage systems require to scale past a single machine, and thus have a different design from RAID.
An example of such a system is &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;hadoop.apache.org&#x2F;docs&#x2F;stable&#x2F;hadoop-project-dist&#x2F;hadoop-hdfs&#x2F;HdfsDesign.html&quot;&gt;HDFS&lt;&#x2F;a&gt;, which also supports erasure coding.
These systems manage a large number of nodes and disks: sometimes thousands or tens of thousands of them.
As in RAID, data is encoded with an \([n, k]\) MDS code, and each codeword symbol is placed on a different disk, but \(n\) is much smaller than the number of disks (typically \(n \leq 50\)).
The disks where a codeword is placed are chosen by a semi-random placement algorithm, which tries to avoid choosing disks that might fail at the same time (e.g., by choosing disks in different racks).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;erasure-codes&quot;&gt;Background on erasure codes&lt;&#x2F;h3&gt;
&lt;p&gt;While many types of erasure codes exists, in this post we will focus specifically on &lt;em&gt;linear&lt;&#x2F;em&gt; erasure codes with the &lt;em&gt;MDS&lt;&#x2F;em&gt; property, which we explain in the following.
An \([n, k]\) MDS (maximum-distance separable) erasure code takes \(k\) symbols of data, and encodes them into \(n\) code symbols with the property that any \(k\) out of the \(n\) code symbols can recover the original \(k\) data symbols.
Symbols are elements from a specific finite field (denoted \(\mathbb{F}\)).
Many practical applications use the finite field \(\mathrm{GF}(2^8)\), where each symbol is represented as a single byte.
Let \(r \coloneqq n - k\), and let \([i] = \{1,2,\ldots,i\}\).
Mathematically, an \([n, k]\) erasure code over \(\mathbb{F}\) is a function \(\mathcal{C}: \mathbb{F}^{k} \to \mathbb{F}^{n}\).
Elements in the image of \(\mathcal{C}\) are called &lt;em&gt;codewords&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;A linear code can be described by the mapping \(\mathbf{m} \to \mathbf{m} \mathbf{G}\), where \(\mathbf{G}\) is the \(k \times n\) &lt;em&gt;generator matrix&lt;&#x2F;em&gt;.
A code is MDS iff for any codeword it is possible to recover the original data after erasing any \(r\) arbitrary symbols.
For linear codes, this is equivalent to the property that the \(k \times k\) matrix formed by the columns corresponding to any \(k\) code symbols is invertible.
In practice, &lt;em&gt;systematic&lt;&#x2F;em&gt; codes are often used, which permit reading data without decoding.
A linear code is said to be &lt;em&gt;systematic&lt;&#x2F;em&gt; if its generator matrix contains a \(k \times k\) identity matrix as a submatrix; for such codes, we refer to the \(k \times r\) submatrix defined by the remaining columns as the &lt;em&gt;parity matrix&lt;&#x2F;em&gt; \(\mathbf{P}\).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conversion&quot;&gt;The code conversion problem&lt;&#x2F;h2&gt;
&lt;p&gt;The problem of changing data encoded under an initial code \(\mathcal{C}^I\) to its corresponding encoding under a final code \(\mathcal{C}^F\) is called &lt;em&gt;code conversion&lt;&#x2F;em&gt;.
In this section, we describe &lt;em&gt;convertible codes&lt;&#x2F;em&gt;, which are capable of efficiently changing the erasure code parameters from \([n^I, k^I]\) to \([n^F, k^F]\).
Let us start by showing an example of convertible codes in action.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;convertible_codes_example.png&quot; alt=&quot;Code conversion&quot; &#x2F;&gt;
&lt;em&gt;Figure 2: Example of code conversion from a \([7,4]\) MDS code to a \([11,8]\) MDS code.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a name=&quot;ex-merge&quot;&gt;&lt;&#x2F;a&gt;
&lt;strong&gt;Example 1.&lt;&#x2F;strong&gt; Consider conversion from \([n^I = 7, k^I = 4]\) to \([n^F = 11, k^F = 8]\).
In this example, both codes are systematic (i.e. the data symbols are contained in the codewords), and each box represents a symbol.
Two codewords from the \([7,4]\) code are combined to obtain a single codeword from the \([11,8]\) code.
The first observation we make is that since both codes are systematic, we can simply keep the data symbols where they are (i.e., unchanged) through the conversion (dashed arrows).
Thus, in this case, we only need to define how the new parities are computed.&lt;&#x2F;p&gt;
&lt;p&gt;The default approach to conversion would be to read all of the data symbols \((a_1,\ldots,a_8)\), and use those to compute the new parities \(q_1, q_2\).
However, it is possible to reduce that cost.
Let the field \(\mathbb{F}\) be the integers modulo 17.
When we define the code, we want to ensure two properties: (1) the initial and final codes are MDS, and (2) the new parities can be computed efficiently.
To ensure this, we build the code from a &lt;em&gt;Vandermonde matrix&lt;&#x2F;em&gt;.
In a Vandermonde matrix, each column is determined by an &lt;em&gt;evaluation point&lt;&#x2F;em&gt; (an element from the field), and row \(i\) corresponds to the evaluation point raised to the power of \(i - 1\).
We can carefully choose the evaluation points to ensure the MDS property holds (it does not suffice to just choose distinct point).
Choosing evaluation points \((\theta_1 = 1, \theta_2 = 2, \theta_3 = 6)\) we have:
\[
\mathbf{P}^F =
\begin{bmatrix}
1 &amp;amp; 1 &amp;amp; 1 \\
\theta_1 &amp;amp; \theta_2 &amp;amp; \theta_3 \\
\theta_1^2 &amp;amp; \theta_2^2 &amp;amp; \theta_3^2 \\
\theta_1^3 &amp;amp; \theta_2^3 &amp;amp; \theta_3^3 \\
\theta_1^4 &amp;amp; \theta_2^4 &amp;amp; \theta_3^4 \\
\theta_1^5 &amp;amp; \theta_2^5 &amp;amp; \theta_3^5 \\
\theta_1^6 &amp;amp; \theta_2^6 &amp;amp; \theta_3^6 \\
\theta_1^7 &amp;amp; \theta_2^7 &amp;amp; \theta_3^7 \\
\end{bmatrix} =
\begin{bmatrix}
1 &amp;amp; 1 &amp;amp; 1 \\
1 &amp;amp; 2 &amp;amp; 6 \\
1 &amp;amp; 4 &amp;amp; 2 \\
1 &amp;amp; 8 &amp;amp; 12 \\
1 &amp;amp; 16 &amp;amp; 4 \\
1 &amp;amp; 15 &amp;amp; 7 \\
1 &amp;amp; 13 &amp;amp; 8 \\
1 &amp;amp; 9 &amp;amp; 14 \\
\end{bmatrix}.
\]
Let \(\mathbf{P}^I\) denote matrix defined by the first 4 rows of \(\mathbf{P}^F\).
The parities for the initial code are computed using \(\mathbf{P}^I\), and the parities of the final code are computed using \(\mathbf{P}^F\), i.e., the \((p,p^{\prime},q)\) elements in Figure 2 are defined as:
\[
(p_1,p_2,p_3) = (a_1,\ldots,a_4) \mathbf{P}^I \\
(p^{\prime}_1,p^{\prime}_2,p^{\prime}_3) = (a_5,\ldots,a_8) \mathbf{P}^I \\
(q_1,q_2,q_3) = (a_1,\ldots,a_8) \mathbf{P}^F.
\]
It is straightforward (although tedious) to check that the codes defined with these matrices have the MDS property.
During conversion, instead of reading all data we can compute simply compute the new parities from the old ones by scaling them by the appropriate powers of the chosen evaluation points:
\[
(a_1,\ldots,a_4)\mathbf{P}^I +
(a_5,\ldots,a_8)\mathbf{P}^I
\begin{bmatrix}
\theta_1^4 &amp;amp; 0 &amp;amp; 0 \\
0 &amp;amp; \theta_2^4 &amp;amp; 0 \\
0 &amp;amp; 0 &amp;amp; \theta_3^4 \\
\end{bmatrix} = (a_1,\ldots,a_8)\mathbf{P}^F.
\]
Notice that this is possible due to the Vandermonde structure of the matrices, which allows us to turn \(\mathbf{P}^I\) into the bottom half of \(\mathbf{P}^F\) by scaling each column.
This allows us to compute the final parities by using the existing initial parities, without the need to read the data.&lt;&#x2F;p&gt;
&lt;p&gt;By doing this, we can achieve code conversion by reading (and transferring) just 6 symbols in total.
In comparison, the default approach of read-reencode-write would require reading (and transferring) 8 symbols (i.e., all the original data symbols).&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;framework&quot;&gt;The convertible codes framework&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;framework_example.png&quot; alt=&quot;Diagram of code conversion&quot; &#x2F;&gt;
&lt;em&gt;Figure 3: Abstract depiction of a conversion from an \([n^I,k^I]\) MDS code to a \([n^F,k^F]\) MDS code.&lt;&#x2F;em&gt;
&lt;em&gt;Each box represents a symbol, and the boxes are grouped into codewords.&lt;&#x2F;em&gt;
&lt;em&gt;The top row represents initial codewords and the bottom row represents final codewords.&lt;&#x2F;em&gt;
&lt;em&gt;Some symbols are kept unchanged, and reused in the final codewords (denoted with dashed arrows).&lt;&#x2F;em&gt;
&lt;em&gt;The converter (the node labeled “c”), reads data from some symbols in the initial codewords, and computes the new symbols in the final codewords (denoted with solid arrows).&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Convertible codes focus on conversions where \(\mathcal{C}^I\) is an \([n^I,k^I]\) code and \(\mathcal{C}^F\) is an \([n^F,k^F]\) code.
In this post, we focus on the case where \(\mathcal{C}^I\) and \(\mathcal{C}^F\) are linear and MDS.
To achieve the change in code dimension from \(k^I\) to \(k^F\) the conversion procedure needs to consider multiple codewords at a time.
Let \(\lambda^I\) be the number of codewords of \(\mathcal{C}^I\) taken as input, and let \(\lambda^F\) be the number of codewords of \(\mathcal{C}^F\) produced as output.
To preserve the amount of data, we must have \(\lambda^I k^I = \lambda^F k^F\).
In particular, we define \(\lambda^I\) and \(\lambda^F\) as the smallest possible integers that satisfy the above equation, i.e.:
\[
\lambda^I \coloneqq \frac{\mathrm{lcm}(k^I,k^F)}{k^I}
\text{ and }
\lambda^F \coloneqq \frac{\mathrm{lcm}(k^I,k^F)}{k^F}.
\]
For example, in &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;#ex-merge&quot;&gt;Example 1&lt;&#x2F;a&gt; we have \(k^I = 4\) and \(k^F = 8\), which means that we consider a total of \(\mathrm{lcm}(k^I,k^F) = 8\) data symbols in total, which at the beginning form \(\lambda^I = 2\) codewords, and at the end form \(\lambda^F = 1\) codeword.&lt;&#x2F;p&gt;
&lt;p&gt;Since multiple codewords are being converted, we also need to specify how data is distributed across different codewords.
This is specified through an &lt;em&gt;initial partition&lt;&#x2F;em&gt; \(\mathcal{P}^I\) and &lt;em&gt;final partition&lt;&#x2F;em&gt; \(\mathcal{P}^F\) of the set \([\mathrm{lcm}(k^I,k^F)]\), which indicate the \(k^I\) data symbols encoded by each initial codeword, and \(k^F\) data symbols encoded by each final codeword.
Let \(\mathbf{m} \in \mathbb{F}^{\mathrm{lcm}(k^I,k^F)}\) be the data to be stored, let \(P \subseteq [\mathrm{lcm}(k^I,k^F)]\) be a subset of indexes, and let \(\mathbf{m}_{P} \in \mathbb{F}^{|P|}\) be the entries of \(\mathbf{m}\) indexed by \(P\).
Then, the set of &lt;em&gt;initial codewords&lt;&#x2F;em&gt; is \(\{\mathcal{C}^I(\mathbf{m}_P) \mid P \in \mathcal{P}^I\}\), and the set of &lt;em&gt;final codewords&lt;&#x2F;em&gt; is \(\{\mathcal{C}^F(\mathbf{m}_P) \mid P \in \mathcal{P}^F\}\).
In the case of &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;#ex-merge&quot;&gt;Example 1&lt;&#x2F;a&gt;, the initial partition is \(\mathcal{P}^I = \{\{1,2,3,4\},\{5,6,7,8\}\}\), and the final partition is \(\mathcal{P}^F = \{\{1,2,3,4,5,6,7,8\}\}\), and thus the initial codewords are \(\{\mathcal{C}^I(a_1,\ldots,a_4), \mathcal{C}^I(a_5,\ldots,a_8)\}\) and the final codeword is \(\mathcal{C}^F(a_1,\ldots,a_8)\).&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;em&gt;conversion procedure&lt;&#x2F;em&gt; takes the initial codewords as input, and output the final codewords.
Formally, a convertible code is defined as follows.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Definition (Convertible code).&lt;&#x2F;strong&gt;
A convertible code over \(\mathbb{F}\) is defined by:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;a pair of codes \((\mathcal{C}^I, \mathcal{C}^F)\) where \(\mathcal{C}^I\) is an \([n^I, k^I]\) code over \(\mathbb{F}\) and \(\mathcal{C}^F\) is an \([n^F, k^F]\) code over \(\mathbb{F}\);&lt;&#x2F;li&gt;
&lt;li&gt;a pair of partitions \(\mathcal{P}^I, \mathcal{P}^F\) of \([\mathrm{lcm}(k^I, k^F)]\) such that each subset in \(\mathcal{P}^I\) is of size \(k^I\) and each subset in \(\mathcal{P}^F\) is of size \(k^F\); and&lt;&#x2F;li&gt;
&lt;li&gt;a conversion procedure that on input \({\mathcal{C}^I(\mathbf{m}_P) \mid P \in \mathcal{P}^I}\) outputs \({\mathcal{C}^F(\mathbf{m}_P) \mid P \in \mathcal{P}^F}\), for any \(\mathbf{m} \in \mathbb{F}^{\mathrm{lcm}(k^I,k^F)}\).&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;conversion-procedure&quot;&gt;Conversion procedure&lt;&#x2F;h3&gt;
&lt;p&gt;The objective of the conversion procedure is to convert the initial codewords into the final codewords efficiently.
This is modeled with a &lt;em&gt;converter&lt;&#x2F;em&gt; which reads data from some symbols in the initial codewords, and computes new symbols in the final codewords.
As seen in the figure above, not all symbols in the final codewords need to be new; some symbols can be kept unchanged from the initial codewords, which incurs no cost.
Since our objective is to minimize cost, we will focus only on the so-called &lt;em&gt;stable&lt;&#x2F;em&gt; convertible codes, which have \(k^F\) unchanged symbols in each final codeword (which was proven in &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;#maturana2022convertible&quot;&gt;Maturana &amp;amp; Rashmi, 2022a&lt;&#x2F;a&gt; to be the maximum possible).&lt;&#x2F;p&gt;
&lt;p&gt;To decide whether a conversion procedure is efficient, we need to measure its cost.
Since each final codeword has exactly \(r^F\) new symbols, the cost of writing the new symbols is fixed, regardless of the conversion procedure.
Therefore, we will focus only the read costs of conversion.
Two types of cost have been considered in the literature.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Definition (Access cost).&lt;&#x2F;strong&gt;
The total number of symbols read by the converter.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Definition (Conversion bandwidth).&lt;&#x2F;strong&gt;
The total size of the data read by the converter (note that the converter may read only part of a symbol).&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In this post, we will focus only on &lt;em&gt;access cost&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;conversion-regimes&quot;&gt;Conversion regimes&lt;&#x2F;h3&gt;
&lt;p&gt;To facilitate the study of convertible codes, two special subcases have been identified in the literature.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Definition (Merge regime).&lt;&#x2F;strong&gt;
Code conversions which merge multiple codewords into a single one, i.e., \(\lambda^I \geq 2\), \(\lambda^F = 1\), and \(k^F = \lambda^I k^F\), with arbitrary \(n^I\) and \(n^F\).&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Definition (Split regime).&lt;&#x2F;strong&gt;
Code conversions which split a single codeword into a multiple one, i.e., \(\lambda^I = 1\), \(\lambda^F \geq 2\), and \(k^I = \lambda^F k^F\), with arbitrary \(n^I\) and \(n^F\).&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The case where all parameters \((n^I,k^I,n^F,k^F)\) are arbitrary is referred to as the &lt;em&gt;general regime&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The benefit of studying the merge regime and the split regime separately, is that in these two subcases one need not worry about defining the partitions \(\mathcal{P}^I\) and \(\mathcal{P}^F\), which simplifies the analysis.
This is because in these two subcases all data gets mapped to the same codeword (either in the initial or final configuration).
Thus, all partitions are equivalent by just relabeling the symbols.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;access-opt&quot;&gt;Minimizing the access cost of conversion&lt;&#x2F;h2&gt;
&lt;p&gt;The following table shows the known lower bounds for the access cost of conversion.
In this section, we will describe the constructions that achieve each of the non-trivial bounds.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a name=&quot;table-access-lb&quot;&gt;&lt;&#x2F;a&gt;
&lt;strong&gt;Table.&lt;&#x2F;strong&gt; &lt;em&gt;Summary of known lower bounds on access cost (assuming \(r^F = n^F - k^F \leq \min\{k^I, k^F\}\)).&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Regime&lt;&#x2F;th&gt;&lt;th&gt;\(r^I &amp;lt; r^F\)&lt;&#x2F;th&gt;&lt;th&gt;\(r^I \geq r^F\)&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;Merge&lt;&#x2F;td&gt;&lt;td&gt;\( \lambda^I k^I \) &lt;sup class=&quot;footnote-reference&quot;&gt;(1)&lt;&#x2F;sup&gt;&lt;&#x2F;td&gt;&lt;td&gt;\( \lambda^I r^F \) &lt;sup class=&quot;footnote-reference&quot;&gt;(1)&lt;&#x2F;sup&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Split&lt;&#x2F;td&gt;&lt;td&gt;\( \lambda^F k^F \) &lt;sup class=&quot;footnote-reference&quot;&gt;(2)&lt;&#x2F;sup&gt;&lt;&#x2F;td&gt;&lt;td&gt;\( (\lambda^I - 1) k^F + r^F \) &lt;sup class=&quot;footnote-reference&quot;&gt;(2)&lt;&#x2F;sup&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;\( k^I = k^F \)&lt;&#x2F;td&gt;&lt;td&gt;\( k^I \)&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;\( k^I \neq k^F\)&lt;&#x2F;td&gt;&lt;td&gt;\(\mathrm{lcm}(k^I,k^F)\) &lt;sup class=&quot;footnote-reference&quot;&gt;(2)&lt;&#x2F;sup&gt;&lt;&#x2F;td&gt;&lt;td&gt;\(\lambda^I r^F + (\lambda^I \bmod \lambda^F) (k^I - \max\{k^F \bmod k^I, r^F\})\) &lt;sup class=&quot;footnote-reference&quot;&gt;(2)&lt;&#x2F;sup&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;&lt;em&gt;&lt;sup class=&quot;footnote-reference&quot;&gt;(1)&lt;&#x2F;sup&gt;: &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;#maturana2022convertible&quot;&gt;Maturana &amp;amp; Rashmi, 2022a&lt;&#x2F;a&gt;.&lt;&#x2F;em&gt;
&lt;em&gt;&lt;sup class=&quot;footnote-reference&quot;&gt;(2)&lt;&#x2F;sup&gt;: &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;#maturana2020access&quot;&gt;Maturana et al., 2020&lt;&#x2F;a&gt;.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;merge-regime&quot;&gt;Merge regime&lt;&#x2F;h3&gt;
&lt;p&gt;Recall that, in this case, \(\lambda^I\) codewords are merged into a single one.
During conversion, all the data nodes are kept unchanged.
To meet the bound in the table above, the converter can access \(r^F\) symbols from each initial codeword.
As we saw in &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;#ex-merge&quot;&gt;example 1&lt;&#x2F;a&gt;, this is possible by designing the parity matrices in a way that allows the converter to compute the new parities using only the old parities.
This can be done, for example, by using a Vandermonde matrix, although Vandermonde parity matrices are not guaranteed to produce MDS codes.
However, &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;#maturana2022convertible&quot;&gt;Maturana &amp;amp; Rashmi (2022a)&lt;&#x2F;a&gt; provide a method for constructing access-optimal codes that are guaranteed to be MDS over large enough field sizes.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;split-regime&quot;&gt;Split regime&lt;&#x2F;h3&gt;
&lt;p&gt;Achieving the bound in table above is simple: during conversion, the converter reads the data symbols from all initial codewords except one, along with \(r^F\) initial parity symbols.
Then, the read data symbols are used to compute the corresponding parity symbols, and to remove their interference from the read initial parities.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Example 2.&lt;&#x2F;strong&gt; &lt;a name=&quot;ex-access-split&quot;&gt;&lt;&#x2F;a&gt;
Consider the conversion from \([n^I = 11, k^I = 8]\) to \([n^F = 7, k^F = 4]\) over \(\mathrm{GF}(17)\).
Suppose we use the same \(\mathbf{P}^I\) and \(\mathbf{P}^F\) from &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;#merge-ex&quot;&gt;example 1&lt;&#x2F;a&gt; but swapped.
During conversion, the converter reads \((a_5,\ldots,a_8)\) and the 3 initial parities \((a_1,\ldots,a_8)\mathbf{P}^I\).
The parity symbols of the second final codeword can be computed directly from the data;
the parity symbols of the first final codeword are computed as follows:
\[
(a_1,\ldots,a_8)\mathbf{P}^I -
(a_5,\ldots,a_8)
\begin{bmatrix}
1 &amp;amp; 16 &amp;amp; 4 \\
1 &amp;amp; 15 &amp;amp; 7 \\
1 &amp;amp; 13 &amp;amp; 8 \\
1 &amp;amp; 9 &amp;amp; 14 \\
\end{bmatrix}
=
(a_1,\ldots,a_4)\mathbf{P}^F.
\]
Thus, in total 7 symbols are read, compared to the default approach of reading all 8 data symbols.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;general-regime&quot;&gt;General regime&lt;&#x2F;h3&gt;
&lt;p&gt;In the general regime, partitions need to specified; &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;#maturana2020access&quot;&gt;Maturana et al., 2020&lt;&#x2F;a&gt; show the optimal way of choosing them.
At a high level, the optimal partition keeps data from the same initial codeword together in the final codeword whenever possible; that way, parity symbols can be used more effectively.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;general_regime_example.png&quot; alt=&quot;General regime example&quot; &#x2F;&gt;
&lt;em&gt;Figure 4: Code conversion from \([6,5]\) MDS code to \([13,12]\) MDS code.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Example 3.&lt;&#x2F;strong&gt;
Consider conversion from \([n^I=6, k^I=5]\), to \([n^F=13, k^F=12]\).
Thus, there are a total of \(\mathrm{lcm}(5,12)=60\) data symbols, organized into \(\lambda^I=12\) initial codewords or \(\lambda^F=5\) final codewords.
The parity matrices of the codes are designed as if the final code was \([16,15]\) (which combines 3 codewords into 1).
The conversion procedure splits two of the initial codewords into “intermediate codewords” (which are not materialized, but only used to describe the construction).
Then, two initial codewords are merged along with two data symbols from the intermediate codewords.
The split and merge are executed with the same techniques we showcased for the merge and split regime, and thus only 18 symbols need to be read (marked by a dot in the figure).
Compare this the default approach of reading all 60 data symbols.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;The code conversion problem adds a new dimension to the design of codes.
This new dimension not only opens a variety of interesting theoretical questions, but has a huge potential for real-world impact in distributed storage systems.
In this post, we only scratched the surface of the code conversion problem:
other work on code conversion has focused on minimizing conversion bandwidth instead of access cost (&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;#maturana2022bandwidth&quot;&gt;Maturana &amp;amp; Rashmi, 2022&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;#maturana2023bandwidth&quot;&gt;Maturana &amp;amp; Rashmi, 2023&lt;&#x2F;a&gt;) and on codes with better repair properties (&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;#xia2015tale&quot;&gt;Xia et al., 2015&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;#wu2022optimal&quot;&gt;Wu et al. 2022&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;convertible-codes&#x2F;#maturana2023locally&quot;&gt;Maturana &amp;amp; Rashmi, 2023&lt;&#x2F;a&gt;)
Even when considering these additional works, there are still many open questions in this nascent area of research.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;references&quot;&gt;References&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a name=&quot;kadekodi2019cluster&quot;&gt;&lt;&#x2F;a&gt; S. Kadekodi, K. V. Rashmi, and G. R. Ganger, “Cluster storage systems gotta have HeART: improving storage efficiency by exploiting disk-reliability heterogeneity,”
&lt;em&gt;FAST 2019&lt;&#x2F;em&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a name=&quot;kadekodi2020pacemaker&quot;&gt;&lt;&#x2F;a&gt; S. Kadekodi, F. Maturana, S. J. Subramanya, J. Yang, K. V. Rashmi, and G. R. Ganger, “PACEMAKER: Avoiding HeART attacks in storage clusters with disk-adaptive redundancy,”
&lt;em&gt;OSDI 2020&lt;&#x2F;em&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a name=&quot;maturana2020access&quot;&gt;&lt;&#x2F;a&gt; F. Maturana, V. S. C. Mukka, and K. V. Rashmi, “Access-optimal linear MDS convertible codes for all parameters,” &lt;em&gt;ISIT 2020&lt;&#x2F;em&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a name=&quot;maturana2023bandwidth&quot;&gt;&lt;&#x2F;a&gt; F. Maturana and K. V. Rashmi, “Bandwidth cost of code conversions in distributed storage: fundamental limits and optimal constructions,” &lt;em&gt;IEEE Transactions on Information Theory&lt;&#x2F;em&gt;, 2023.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a name=&quot;maturana2022convertible&quot;&gt;&lt;&#x2F;a&gt; F. Maturana and K. V. Rashmi, “Convertible codes: enabling efficient conversion of coded data in distributed storage,” &lt;em&gt;IEEE Transactions on Information Theory&lt;&#x2F;em&gt;, 2022.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a name=&quot;maturana2022bandwidth&quot;&gt;&lt;&#x2F;a&gt; F. Maturana and K. V. Rashmi, “Bandwidth cost of code conversions in the split regime,” &lt;em&gt;ISIT 2022&lt;&#x2F;em&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a name=&quot;maturana2023locally&quot;&gt;&lt;&#x2F;a&gt; F. Maturana and K. V. Rashmi, “Locally repairable convertible codes: erasure codes for efficient repair and conversion,” &lt;em&gt;ISIT 2023&lt;&#x2F;em&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a name=&quot;schroeder2007disk&quot;&gt;&lt;&#x2F;a&gt; B. Schroeder and G. A. Gibson, “Disk Failures in the Real World: What Does an MTTF of 1,000,000 Hours Mean to You?,” &lt;em&gt;FAST 2007&lt;&#x2F;em&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a name=&quot;wu2022optimal&quot;&gt;&lt;&#x2F;a&gt; S. Wu, Z. Shen, P. P. C. Lee, and Y. Xu, “Optimal repair-scaling trade-off in locally repairable codes: analysis and evaluation,” &lt;em&gt;IEEE Transactions on Parallel and Distributed Systems&lt;&#x2F;em&gt;, 2022.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a name=&quot;xia2015tale&quot;&gt;&lt;&#x2F;a&gt; M. Xia, M. Saxena, M. Blaum, and D. Pease, “A tale of two erasure codes in HDFS,” &lt;em&gt;FAST 2015&lt;&#x2F;em&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>The Quantum Physicist&#x27;s Method of Resource Analysis</title>
		<published>2023-06-06T00:00:00+00:00</published>
		<updated>2023-06-06T00:00:00+00:00</updated>
		<link href="https://www.cs.cmu.edu/~csd-phd-blog/2023/quantum-physicists-method/" type="text/html"/>
		<id>https://www.cs.cmu.edu/~csd-phd-blog/2023/quantum-physicists-method/</id>
		<content type="html">&lt;p&gt;The physicist’s method is a powerful framework for cost analysis that
many a computer scientist will learn at some point in their undergraduate career.
However, its high-level description leaves some practical gaps, especially concerning
how to actually bookkeep its finer details, and these details become important
when trying to build a more explicit accounting framework.
This post explains how to fill in these gaps with
the &lt;em&gt;quantum&lt;&#x2F;em&gt; physicist’s method, a refinement of the physicist’s method
that is robust enough for automatic program analysis, as in
my paper &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;abs&#x2F;10.1145&#x2F;3473581&quot;&gt;here&lt;&#x2F;a&gt;. (Quick disclaimer: There is
no quantum computing in here, despite the name.) To do explain the new
bookkeeping devices of the quantum physicist’s method,
this post will first explain the classical physicist’s method
for algorithm analysis, then describe the difficulties it encounters when
adapted to the domain of program analysis, and finally lay out the
solution granted by bookkeeping with the quantum physicist’s method.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;the-classical-physicist-s-method&quot;&gt;The Classical Physicist’s Method&lt;&#x2F;h1&gt;
&lt;p&gt;To make sense of the physicist’s method (and the later refinements we’ll make to it), it is
good to start by recalling the physical reasoning behind it. Think back to your highschool physics class
where you learned about energy. If you drop a 1 kilogram ball from
1 meter above the Earth, and drop an identical ball from the top of a 1 meter high ramp, how do their speeds compare
when they hit the ground?&lt;&#x2F;p&gt;
&lt;p&gt;It might seem like I haven’t given you enough information, but a neat little physical
principle called &lt;em&gt;conservation of energy&lt;&#x2F;em&gt; tells you all you need to know. At the start, both balls
have the same amount&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#grav&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; of (gravitational) potential energy since they are the same height, same mass, and subject to the same
gravity. And at the end, both balls have none, since their distance from the ground is 0. Because the
total energy is &lt;em&gt;conserved&lt;&#x2F;em&gt;, we know that all that energy must still be around, just in some other form - in this case,
as kinetic energy in the balls’ speeds. So even though both
balls took different routes to the ground, the same energy goes into their speed, and thus the speeds are the same&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#speed&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;.
Let me emphasize that point: &lt;em&gt;As long as we know energy is conserved,
we can measure expenditure with the difference between starting and ending energy&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Eventually Robert Tarjan and Danny Sleator brought this idea to computer science.
They introduced it to define
&lt;em&gt;amortized&lt;&#x2F;em&gt; algorithm costs (see &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;epubs.siam.org&#x2F;doi&#x2F;pdf&#x2F;10.1137&#x2F;0606031?casa_token=cR8nppnD8MQAAAAA%3AgK8XhJzUtPvkIVXTHIe299HSRuczuwiYVM74VDBjOMpHDlLcZLIVlziYWpRQMHeuN3lz84b9kIUg&amp;amp;&quot;&gt;here&lt;&#x2F;a&gt;).
However, the idea of amortization itself is much older, and comes from the financial industry.
Amortization is used to express a notion of average cost where occasional
spikes of high cost are prepaid over longer periods of time, like paying off a loan
in installments instead of all at once at the due date. However, if we think about this
prepayment as storing extra potential energy for later, the reasoning becomes exactly the
same as reasoning about conservation of energy. Hence, Tarjan and Sleator suggested
calling the approach “the physicist’s method”&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#personal&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;To see how this all comes up in the analysis of algorithms, consider implementing an arbitrarily sized list using
fixed-size arrays&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#list&quot;&gt;4&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;. In particular, lets look at the list’s insertion function, and measure its
cost in how many array write accesses it uses. The common case is that list insertion will just be able to directly write a new
element into the next unused slot in the array, for a cost of 1 write. But eventually, the array will be full with no unusued slots.
When this happens, our implementation will:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;allocate a new array double the size of the old one&lt;&#x2F;li&gt;
&lt;li&gt;write all the elements from the old array into the new one&lt;&#x2F;li&gt;
&lt;li&gt;write the new element into the next empty space of the new array&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;If you count them, you’ll find this uncommon case uses a number of array writes equal to the length of the list plus one,
which is a far cry from the common case’s constant cost. Worst-case cost analysis thus makes this algorithm look much more
inefficient than it usually is.&lt;&#x2F;p&gt;
&lt;p&gt;If instead we think through a lens of amortization, we find that insertion is, morally-speaking, a constant cost operation.
Essentially, insertion is cheap enough often enough that prepaying a little extra at each common case
can offset the high cost of the uncommon case. We can see how that looks in the graph below&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#graph&quot;&gt;5&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;, where the 
black spikes of cost
never exceed the red constant-per-step payment.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;.&#x2F;amortizedgraph.jpeg&quot; alt=&quot;a graph showing a constant-per-step bound over spiky costs&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;To show this formally, we define a suitable &lt;em&gt;potential&lt;&#x2F;em&gt; function \(\Phi\) giving the amount of prepaid potential energy stored in the
program state. Specifically, our desired \(\Phi(A)\) will be equal to twice the number of
filled slots past
the halfway point in the array \(A\).
We can think of this like attaching a 2-charge battery to each individual array cell past the halfway point, so that
we deal with that battery’s energy if and only if we access that array cell.
The amortized cost of an operation \(o\) is then defined as \(\Phi(o(A)) - \Phi(A) + C(A,o)\), which is the difference in potential induced by \(o\) plus \(C(A,o)\) its true cost on the array \(A\).
If we account for this potential energy alongside our normal costs, suddenly the cost profile becomes much smoother:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;In the common case, insertion just writes into the next unused slot of \(A\). We still pay the true cost of 
\(C(A,\mathsf{insert}) = 1\) for the that write, but now might also need to pay 2 more to “charge the battery”
if the element is past the halfway point in the array. This “battery-charging” is how we pay for the difference in
potential as given by \(\Phi\). In the worst case, the total amortized cost is therefore 3.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;In the uncommon case, our array \(A\) is now full. Thus, we have stored 2 units of potential with half the elements of \(A\),
which works out to one unit of potential for each element. So, potential can pay for each element’s write into the new array,
with none leftover. The new array itself then has no potential, because it is exactly half full. At this point, stored
potential has exactly covered the cost of all writes and all the state’s potential, accruing a running cost of 0. Finally
list insertion behaves like its common case again, giving worst-case amortized cost of 3.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Thus, through mediating energy expenditure with potential, we find that
insertion into these array-backed lists takes an amortized constant number of writes. The magic
happened when we prepaid for two extra writes in the common case to “charge the battery”.
Eventually, that prepayment gets spent in the uncommon case to cover the writes into the
new array.&lt;&#x2F;p&gt;
&lt;p&gt;Now that you’ve seen an example, we can look at the general case:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;a set of operations \(\mathsf{op} = \mathsf{state} \rightarrow \mathsf{state} \)&lt;&#x2F;li&gt;
&lt;li&gt;a true cost function \(C : \mathsf{state} \times \mathsf{op} \rightarrow \mathbb{R}\)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;If you can find:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;a potential function \(\Phi : \mathsf{state} \rightarrow \mathbb{R}_{\geq 0}\) &lt;&#x2F;li&gt;
&lt;li&gt;amortized cost \(a_o\) for each operation \(o\)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;such that \(\Phi(S) + a_{o_i} \geq \Phi(o_i(S))  + C(S, o_i)\)
for any state \(S\),&lt;&#x2F;p&gt;
&lt;p&gt;Then for any sequence of \(n\) operations \((o_i)\) and the sequence of states \((S_i)\) that they induce :&lt;&#x2F;p&gt;
&lt;p&gt;\[\sum_{i=0}^{i&amp;lt;n} a_{o_i} + \Phi(S_{0})  - \Phi(S_{n}) \geq \sum_{i=0}^{i&amp;lt;n} C(S_i, o_i)\]&lt;&#x2F;p&gt;
&lt;p&gt;i.e., the total amortized cost plus change in potential covers the total true cost.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The condition placed on \(\Phi\) and \(a_{o_i}\) is what corresponds to conservation of energy&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#technically&quot;&gt;6&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;.
The potential in the state \(\Phi(S)\), and the extra energy paid \(a_{o_i}\) are sufficient to
cover the potential stored in the resulting state \(\Phi(o_i(S))\) and the energy
expenditure \(C(S, o_i)\) – no new energy is created. With that condition in place, just like in physics,
we can forget about intermediate states and just focus on the initial and ending states \(S_0\) and \(S_{n}\).
Hence the conclusion of the theorem, that the potential difference between \(\Phi(S_{0})\) and \(\Phi(S_{n})\) 
plus all the total supplied extra energy can pay for the total energy expenditure.&lt;&#x2F;p&gt;
&lt;p&gt;In the above formalization, you might notice that the form of the potential function \(\Phi\) is left abstract.
The function &lt;em&gt;could&lt;&#x2F;em&gt; be any sort of complicated, non-uniform, ugly function. But it is no coincidence that
the \(\Phi\) we chose in our above example was “nice”. Specifically, this “niceness” amounts to potential being
&lt;em&gt;local&lt;&#x2F;em&gt; – one can think of the state \(S\) as broken up into many pieces (our array cells),
each with their own local amount of potential (our “batteries”).
Then \(\Phi\) just gives the sum of potential stored on these different pieces,
and adjusts the potential on a piece only when that piece is directly operated on.
In fact, this appears to be exactly how Tarjan intended the
bookkeeping for the physicist’s method to be conceptualized:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;In order to keep track of saved or borrowed credits [potential], it is generally convenient to
store them in the data structure. Regions of the structure containing credits are
unusually hard to access or update (the credits saved are there to pay for extra work);
regions containing “debits” are unusually easy to access or update. It is important to
realize that this is only an accounting device; the programs that actually manipulate
the data structure contain no mention of credits or debits.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;– Tarjan in &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;epubs.siam.org&#x2F;doi&#x2F;pdf&#x2F;10.1137&#x2F;0606031?casa_token=cR8nppnD8MQAAAAA%3AgK8XhJzUtPvkIVXTHIe299HSRuczuwiYVM74VDBjOMpHDlLcZLIVlziYWpRQMHeuN3lz84b9kIUg&amp;amp;&quot;&gt;&lt;em&gt;Amortized Computational Complexity&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;This local-view of potential has been time-tested, and is basically the only form of potential
you will find in the literature. As such, our goal throughout the rest of this
post will be to keep our definition of potential as local as possible.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;building-a-program-analysis&quot;&gt;Building a Program Analysis&lt;&#x2F;h1&gt;
&lt;p&gt;To build a program analysis based on the physicist’s method, we first need to
adapt the framework above. This is because some of the assumptions made
above are simply not applicable in our programmatic setting. The differences
are mostly technical, but accounting for them does lead to a slightly
different-looking theorem.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The above framework assumes that operations can be executed in any order.
This makes sense when treating the collection of operations like an
interface – you don’t know what order an external user might call operations, so
your analysis needs to be prepared for anything. However this assumption
is wrong for analyzing a program (like the implementation of such an interface).
The program itself dictates specific sequences of operations, and the
analysis must take this into account to get sensible results&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#timesensitive&quot;&gt;7&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;The above framework assumes that extra energy \(a_o\) is
paid out on a per-operation basis.
Again, this makes sense when reasoning about an interface, since an external
user pays for each operation they call. However, when a program executes an operation,
there is no external user to introduce extra energy into the system, so costs
must be paid solely out of the energy supply internal to the program, i.e., the potential
of the state&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#pool&quot;&gt;8&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;After adapting the theorem from the previous section to account for these
differences we are left with something
like the statement below. The main changes are that we consider only certain
sequences of operations, and that we drop amortized costs.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;a set of operations \(\mathsf{op} = \mathsf{state} \rightarrow \mathsf{state} \)&lt;&#x2F;li&gt;
&lt;li&gt;a collection of possible sequences of such operations \(\mathsf{seq}\)&lt;&#x2F;li&gt;
&lt;li&gt;a true cost function \(C : \mathsf{state} \times \mathsf{op} \rightarrow \mathbb{R}\)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;If you can find:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;a potential function \(\Phi : \mathsf{state} \rightarrow \mathbb{R}_{\geq 0}\) &lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;such that \(\Phi(S_i) \geq \Phi(S_{i+1}) + C(S_i, o_i)\)
across all state sequences induced by \(\mathsf{seq}\)
from any initial state \(S_0\)&lt;&#x2F;p&gt;
&lt;p&gt;Then for any sequence of \(n\) operations \((o_i)\) prefixing \(\mathsf{seq}\)
and the sequence of states \((S_i)\) that they induce:&lt;&#x2F;p&gt;
&lt;p&gt;\[\Phi(S_{0}) - \Phi(S_{n}) \geq \sum_{i=0}^{i&amp;lt;n} C(S_i, o_i)\]&lt;&#x2F;p&gt;
&lt;p&gt;i.e., difference in energy bounds the total cost at every point&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#corollary&quot;&gt;9&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;&#x2F;p&gt;
&lt;p&gt;With this framework, our program analysis just needs to find a suitable \(\Phi\).
We are currently only considering a &lt;em&gt;local&lt;&#x2F;em&gt; definition of \(\Phi\), so our
task is really just finding way of
locally assigning potential
to the parts of each individual data structure at each point in our program.&lt;&#x2F;p&gt;
&lt;p&gt;There might be many ways to find such a local \(\Phi\),
but one simple option is to type the data structures. These
types can then include some annotation indicating how much potential the data structure
stores where, like “list but with 2 unit of potential per element”. This tells
you exactly how much potential each piece holds, making it easy to recover a
locally-definable \(\Phi\).&lt;&#x2F;p&gt;
&lt;p&gt;If you run
with this idea, you might eventually get something that looks similar to
the type system called Automatic Amortized Resource Analysis (AARA).
AARA can infer a valid \(\Phi\) through the inference of
potential-carrying types, and is fully automatable (as its name suggests).
See &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;640128.604148&quot;&gt;here&lt;&#x2F;a&gt; for AARA’s origin
and &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.raml.co&#x2F;&quot;&gt;here&lt;&#x2F;a&gt; for an up-to-date implementation.&lt;&#x2F;p&gt;
&lt;p&gt;There are also a lot of different ways to approach this problem
apart from AARA. Some approaches are more manual 
(like &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;link.springer.com&#x2F;chapter&#x2F;10.1007&#x2F;978-3-319-89884-1_19&quot;&gt;this&lt;&#x2F;a&gt;
verification framework using separation logic). Some use potential with 
other traditional techniques (like &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;abs&#x2F;10.1145&#x2F;3408979&quot;&gt;this&lt;&#x2F;a&gt; 
adaptation of recurrence solving). And some are designed for different 
programming environments (like &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;drops.dagstuhl.de&#x2F;opus&#x2F;volltexte&#x2F;2020&#x2F;12355&#x2F;pdf&#x2F;LIPIcs-FSCD-2020-33.pdf&quot;&gt;this&lt;&#x2F;a&gt;
one for client-server interactions). I’m certain there are many more options still, 
but the reason I bring up AARA in particular is that,
while all of these approaches &lt;em&gt;could&lt;&#x2F;em&gt; potentially employ the quantum phyisicist’s method in
the future, AARA is the only one that &lt;em&gt;has&lt;&#x2F;em&gt; (and I’m the one that did it).&lt;&#x2F;p&gt;
&lt;h1 id=&quot;trouble-in-paradise&quot;&gt;Trouble in Paradise&lt;&#x2F;h1&gt;
&lt;p&gt;This localized-potential approach happens to work rather well in many cases. For instance, AARA
can analyze sorting functions and many list manipulations without issue. Nonetheless, it is not hard to confound this approach.
Consider a simple loading function that populates one of our array-backed list from one of two other lists.
When called, the load function first executes some code (e.g. &lt;code&gt;shouldComeFromList1&lt;&#x2F;code&gt;) to decide which list the data should
come from, and then inserts it all one element at a time. Here we see what this might look like in pseudo-code&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#python&quot;&gt;10&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#393939;color:#dedede;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span style=&quot;color:#fed6af;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffd87;&quot;&gt;load&lt;&#x2F;span&gt;&lt;span&gt;(target, list1, list2):
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fed6af;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;shouldComeFromList1():
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fed6af;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fed6af;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span&gt;list1:
&lt;&#x2F;span&gt;&lt;span&gt;            target.insert(i)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fed6af;&quot;&gt;else&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fed6af;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fed6af;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span&gt;list2:
&lt;&#x2F;span&gt;&lt;span&gt;            target.insert(i)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If we assume that &lt;code&gt;shouldComeFromList1&lt;&#x2F;code&gt; has no array writes, then we only need consider the cost
of insertion. Clearly, only one list’s-worth of insertions occurs, and each insertion has an amortized cost of 3,
so \(\Phi\) need only assign 3 energy-per-element to the list selected by &lt;code&gt;shouldComeFromList1&lt;&#x2F;code&gt;.
However, there is in general no way to statically know which list that is – it is &lt;em&gt;undecidable&lt;&#x2F;em&gt;,
even if we had access to the source code for &lt;code&gt;shouldComeFromList1&lt;&#x2F;code&gt;.
This confounds our local method of accounting, since it must store potential in a specific list,
but cannot say which list will end up sourcing the data. We might get around this by having \(\Phi\) yield something
like \(3*\mathsf{max}(|\verb“list1“|, |\verb“list2“|)\) to cover the worst case, but this \(\mathsf{max}\) is not
expressible in a local way - at best, the local approach can overapproximate
\(\mathsf{max}\) with a sum, giving potential of \(3*(|\verb“list1“| + |\verb“list2“|)\), the cost for loading &lt;em&gt;both&lt;&#x2F;em&gt; lists.
And while this bound can only be loose by a constant factor of 2, other examples can loosen the bound to be exponentially worse
(like binary search &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;abs&#x2F;10.1145&#x2F;3473581&quot;&gt;here&lt;&#x2F;a&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;At this point, you might think the bound looseness
is just some weakness on &lt;em&gt;the analysis’s&lt;&#x2F;em&gt; end, where
presumably &lt;em&gt;some&lt;&#x2F;em&gt; localization of the tightest potential exists, but the analysis just can’t figure it out.
However, the situation is actually worse:
We can create an example where &lt;em&gt;no&lt;&#x2F;em&gt; tight localization suffices, even while nonlocal reasoning
makes a tight solution obvious&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#Bell&quot;&gt;11&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;This problem happens especially when measuring the cost of a resource like memory,
since memory is returned after use&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#neg&quot;&gt;12&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; and can be reused. When a resource returned, it is as
if additional payment is provided midway through the computation. This &lt;em&gt;could&lt;&#x2F;em&gt; lessen the amount
of resources needed upfront, but only if those resources aren’t needed prior to when the extra
resources are returned. In effect, the cost of resources like memory is measured with
their &lt;em&gt;peak&lt;&#x2F;em&gt; cost, the high water mark of the number of resources in use at one time.
These resources are therefore a bit more complicated than resources that only tick down, like
time. This makes it easy to create a situation with no tight localization of potential, like that below.&lt;&#x2F;p&gt;
&lt;p&gt;To see this problem in action, imagine we have a list of data, and two different
data processing procedures &lt;code&gt;process1&lt;&#x2F;code&gt; and &lt;code&gt;process2&lt;&#x2F;code&gt;. To compare the results of
these procedures, we might write the code below.
How should we account for the &lt;em&gt;memory&lt;&#x2F;em&gt; cost of the comparison, if each of &lt;code&gt;copy&lt;&#x2F;code&gt;&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#copy&quot;&gt;13&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;,
&lt;code&gt;process1&lt;&#x2F;code&gt;, and &lt;code&gt;process2&lt;&#x2F;code&gt; temporarily
use one unit of memory per element in the list?&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#393939;color:#dedede;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span style=&quot;color:#fed6af;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffd87;&quot;&gt;copy&lt;&#x2F;span&gt;&lt;span&gt;(list):
&lt;&#x2F;span&gt;&lt;span&gt;    ret &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;emptyList()
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fed6af;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fed6af;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;list&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        ret.insert(i)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fed6af;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;ret
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fed6af;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffd87;&quot;&gt;processBoth&lt;&#x2F;span&gt;&lt;span&gt;(data):
&lt;&#x2F;span&gt;&lt;span&gt;    dataCopy &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;copy(data)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fed6af;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;(process1(data), process2(dataCopy))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It seems obvious from the outset that whatever memory &lt;code&gt;copy&lt;&#x2F;code&gt; uses can be
reused for &lt;code&gt;process1&lt;&#x2F;code&gt;, and that &lt;code&gt;process1&lt;&#x2F;code&gt;’s memory in turn can be reused for &lt;code&gt;process2&lt;&#x2F;code&gt;,
since all act on lists of equal length. So, we should only need to allocate \(|\verb“data“|\)
memory units. However, if that is all the memory we have,
accounting for it locally is impossible.&lt;&#x2F;p&gt;
&lt;p&gt;To follow the accounting, let’s step through a call to &lt;code&gt;processBoth&lt;&#x2F;code&gt;. We start with the only
data structure being our input &lt;code&gt;data&lt;&#x2F;code&gt;, so it must contain all the potential.
We proceed to copy &lt;code&gt;data&lt;&#x2F;code&gt; to ready it for each of the processing functions.
This copying procedure temporarily uses all the \(|\verb“data“|\) memory units,
leaving some amount stored on &lt;code&gt;data&lt;&#x2F;code&gt; and some amount stored on &lt;code&gt;dataCopy&lt;&#x2F;code&gt; when
the memory is returned.
Then &lt;code&gt;process1&lt;&#x2F;code&gt; is applied to &lt;code&gt;data&lt;&#x2F;code&gt;, requiring all of
the \(|\verb“data“|\) memory units. Now, because &lt;code&gt;process1&lt;&#x2F;code&gt; doesn’t touch
&lt;code&gt;dataCopy&lt;&#x2F;code&gt;, &lt;code&gt;process1&lt;&#x2F;code&gt; cannot use any of the potential in &lt;code&gt;dataCopy&lt;&#x2F;code&gt;
– this means &lt;code&gt;data&lt;&#x2F;code&gt;
needs to have recieved all the potential, and none is stored on &lt;code&gt;dataCopy&lt;&#x2F;code&gt;. However,
this is followed by applying &lt;code&gt;process2&lt;&#x2F;code&gt; to &lt;code&gt;dataCopy&lt;&#x2F;code&gt;, which results in mirrored accounting for
potential: all potential should have been returned to &lt;code&gt;dataCopy&lt;&#x2F;code&gt;, with none stored in &lt;code&gt;data&lt;&#x2F;code&gt;!
While we intuitively know that this could be solved by having &lt;code&gt;process1&lt;&#x2F;code&gt; return
potential to &lt;code&gt;dataCopy&lt;&#x2F;code&gt;, there is never a time where &lt;code&gt;process1&lt;&#x2F;code&gt; and &lt;code&gt;dataCopy&lt;&#x2F;code&gt;
are local to the same operation.
Thus, no local allocation of \(|\verb“data“|\) potential suffices.
Just like before, the local
approach can only manage to overapproximate this example by a factor of 2, and can
be exponentially worse in other examples.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;the-quantum-physicist-s-method&quot;&gt;The Quantum Physicist’s Method&lt;&#x2F;h1&gt;
&lt;p&gt;So far, our situation is rather unfortunate. We have this beautiful framework
from algorithm analysis, but when we naively adapt it to a program analysis we
must sacrifice either the efficacy of the result or the beauty of locality.
However, there is a solution: bookkeeping using the &lt;em&gt;quantum&lt;&#x2F;em&gt; physicist’s method.
To keep this section intelligible to non-physicists, this section will focus on
the actual execution of the method, while any quantum
physical parallels that come up will be kept
contained in the footnotes.&lt;&#x2F;p&gt;
&lt;p&gt;The idea behind the quantum physicist’s method is to introduce
the accounting device of “worldviews”. Each individual worldview 
\(\phi_j : \mathsf{state} \rightarrow \mathbb{R} \) is
just a normal local accounting of potential like like our previous \(\Phi\), 
though with the added caveat that they are
allowed to locally assign &lt;em&gt;negative&lt;&#x2F;em&gt; amounts of potential under special
conditions&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#detail&quot;&gt;14&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Formally, the collection of worldviews satisfies the following
properties for all state sequences induced by \(\mathsf{seq}\)
from any initial state \(S_0\)&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;\(\forall j. \hspace{4pt} \phi_j(S_i) \geq \phi_j(S_{i+1}) + C(S_i, o_i)\),
i.e., every worldview pays out the usual costs&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;\(\exists j. \hspace{4pt} \forall T\subseteq S_i. \hspace{4pt} \phi_j(S_i) \geq 0 \),
i.e., some worldview is classically valid, wherein potential is non-negative
everywhere&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#whole&quot;&gt;15&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Given these properties, one can prove the following key theorem:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Theorem: \(max_j\phi_j\) is a suitable definition
of \(\Phi\) for the classical physicist’s method&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;&#x2F;p&gt;
Indeed, the first property meets the bulk of the requirements for a valid
potential function, and the second property ensures that the max potential
is always classically valid.
&lt;p&gt;You might at this point wonder what this new way of finding a potential 
function buys us. The answer is that this simple way of combining our 
familiar local accounts of potential introduces some powerful &lt;em&gt;nonlocal&lt;&#x2F;em&gt; 
flexibility. By allowing different worldviews to tactically “go into debt”,
this method can infer tighter cost bounds than naive local reasoning can usually 
supply.&lt;&#x2F;p&gt;
&lt;p&gt;To better understand how the mechanics of these worldviews actually work,
it might help to walk through a situation without so much technical cruft:
Suppose that
Alice and Bob get $5 to share from their parents to spend on candy in a candy store. Alice wants a $3
pack of caramels and Bob wants a $2 chocolate bar. However, Alice’s caramels are in a
vending machine that only takes $5 bills. If Alice keeps $5 to herself, then Bob can’t buy his candy.
But if Bob keeps $2 to himself, then Alice can’t use the vending machine for her candy.
So, what do Alice and Bob do?&lt;&#x2F;p&gt;
&lt;p&gt;The answer is quite simple: Alice buys her caramels with all the money, gets the change back,
and then gives it to Bob –
they both can then get what they want with no extra money needed.
I’m sure I have done the same with my brother plenty of times growing up.
We can bookkeep this the following way:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;center&quot;&gt;&lt;&#x2F;th&gt;&lt;th align=&quot;center&quot;&gt;start&lt;&#x2F;th&gt;&lt;th&gt;Alice buys&lt;&#x2F;th&gt;&lt;th&gt;get change&lt;&#x2F;th&gt;&lt;th&gt;transfer&lt;&#x2F;th&gt;&lt;th&gt;Bob buys&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;Alice&#x2F;Bob money split&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;5&#x2F;0&lt;&#x2F;td&gt;&lt;td&gt;0&#x2F;0&lt;&#x2F;td&gt;&lt;td&gt;2&#x2F;0&lt;&#x2F;td&gt;&lt;td&gt;0&#x2F;2&lt;&#x2F;td&gt;&lt;td&gt;0&#x2F;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;And this is exactly what we want, with one small caveat:
The “transfer” operation is actually quite nontrivial to work with. Only
highly specialized programming languages will even have constructs for &lt;em&gt;mentioning&lt;&#x2F;em&gt;
potential, and those that do will be burdened (or burden the programmer) with
figuring out how such constructs can be soundly used. But, by using worldviews for
bookkeeping, this whole problem can be bypassed entirely. We provide such an
account below:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;center&quot;&gt;&lt;&#x2F;th&gt;&lt;th align=&quot;center&quot;&gt;start&lt;&#x2F;th&gt;&lt;th&gt;Alice buys&lt;&#x2F;th&gt;&lt;th&gt;get change&lt;&#x2F;th&gt;&lt;th&gt;Bob Buys&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;worldview 1 Alice&#x2F;Bob money split&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;5&#x2F;0&lt;&#x2F;td&gt;&lt;td&gt;0&#x2F;0&lt;&#x2F;td&gt;&lt;td&gt;2&#x2F;0&lt;&#x2F;td&gt;&lt;td&gt;2&#x2F;-2&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;worldview 2 Alice&#x2F;Bob money split&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;3&#x2F;2&lt;&#x2F;td&gt;&lt;td&gt;-2&#x2F;2&lt;&#x2F;td&gt;&lt;td&gt;0&#x2F;2&lt;&#x2F;td&gt;&lt;td&gt;0&#x2F;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;With this worldview accounting&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#qt&quot;&gt;16&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;, we pay the exact same amount out of the same place at each step.
The only difference between the two worldviews is that worldview 1 starts in the allocation of money needed
for Alice to buy her candy, and worldview 2 starts in the allocation needed for Bob to buy his. Then,
we find that the problematic “transfer” occurs where different worldviews become classically valid –
we see that happen at “get change”, since worldview 1 is classically valid at “Alice buys”, and
worldview 2 is classically valid at “Bob buys”. This pattern will hold in general, allowing transfers
to be coded completely implicitly into our analysis.&lt;&#x2F;p&gt;
&lt;p&gt;Using worldviews like this, we can solve both of the problems from the previous section:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;To solve the first – the data loading problem – simply start with 2 worldviews: one where &lt;code&gt;list1&lt;&#x2F;code&gt; carries all potential,
and one where &lt;code&gt;list2&lt;&#x2F;code&gt; does. No matter which list pays, there will then be a classically valid worldview.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;To solve the second – the data processing problem – start with 2 worldviews assigning &lt;code&gt;data&lt;&#x2F;code&gt; all the potential. Then upon copying,
let the worldviews diverge – one leaves all the potential on &lt;code&gt;data&lt;&#x2F;code&gt;, and one moves it all
to &lt;code&gt;dataCopy&lt;&#x2F;code&gt;. The former can be the classically valid one while applying &lt;code&gt;process1&lt;&#x2F;code&gt;, and the latter when applying &lt;code&gt;process2&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;In either case the max amount of potential across the worldviews is exactly the tight amount of potential
we wanted assigned.&lt;&#x2F;p&gt;
&lt;p&gt;And so, with worldviews in hand, we can salvage the niceness of locality by wrapping a bunch of local accountings
together and letting them make each other more flexible. From such an accounting we can
reconstruct a potential function that satisfies the standard framework for 
amortized analysis, just as our new theorem ensures. This
leaves us with a program analysis built off the physicist’s method that can give many tighter
bounds than its predecessors.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;wrap-up&quot;&gt;Wrap Up&lt;&#x2F;h1&gt;
&lt;p&gt;If you are interested in seeing such an analysis in action,
I’ll point you again to my work extending AARA &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;abs&#x2F;10.1145&#x2F;3473581&quot;&gt;here&lt;&#x2F;a&gt;.
My paper adds the quantum physicist’s method along with some special infrastructure called &lt;em&gt;remainder contexts&lt;&#x2F;em&gt;, and then
uses its new capabilities to be able to automatically reason about memory usage and tree depth. The work also
comes with an implementation, a description of how it was designed, and tables of experiments run with it on
the OCaml standard library &lt;code&gt;Set&lt;&#x2F;code&gt; module. The implementation never gave worse cost bounds than the local approach, and often
gave much better ones. You can check it out and see for yourself!&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;grav&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;Specifically, they both have \(1\mathsf{kg} * 9.81\frac{\mathsf{m}}{\mathsf{s}^2} * 1 \mathsf{m} = 9.81 \mathsf{J}\) of energy.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;speed&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;Specifically, solving for
\(v\) in the conversion between energy and speed
\(9.81\mathsf{J} = \frac 1 2 * 1\mathsf{kg} * (v \frac{\mathsf{m}}{\mathsf{s}})^2 \) gives
\( 4.43\frac{\mathsf{m}}{\mathsf{s}}\) as the speed of the balls at ground level.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;personal&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;3&lt;&#x2F;sup&gt;
&lt;p&gt;I personally found this analogy with physical reasoning very useful to my
understanding when I was learning about algorithm analysis in undergrad. I’m sure many students feel the same.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;list&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;4&lt;&#x2F;sup&gt;
&lt;p&gt;This list would be the data structure called a &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dynamic_array&quot;&gt;dynamic array&lt;&#x2F;a&gt;.
It is the &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;api&#x2F;java&#x2F;util&#x2F;ArrayList.html&quot;&gt;&lt;code&gt;ArrayList&lt;&#x2F;code&gt; in Java&lt;&#x2F;a&gt;
and the &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.cplusplus.com&#x2F;reference&#x2F;vector&#x2F;vector&#x2F;&quot;&gt;&lt;code&gt;vector&lt;&#x2F;code&gt; in C++&lt;&#x2F;a&gt;, and probably underlies a lot of other list implementations too.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;graph&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;5&lt;&#x2F;sup&gt;
&lt;p&gt;Taken from &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;200384&#x2F;constant-amortized-time&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;technically&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;6&lt;&#x2F;sup&gt;
&lt;p&gt;Technically speaking, it only corresponds to the non-creation of energy, since we are interested
in an upper-bound on cost. Energy conservation means both non-creation and
non-loss of energy. Adapting the amortized analysis framework to non-loss would result in a lower-bound on cost.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;timesensitive&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;7&lt;&#x2F;sup&gt;
&lt;p&gt;To help with this order-sensitivity, we will also from
now on consider the program state to have some notion of where it lies in
execution, like a program counter. However, this is just a technical point to
allow \(\Phi\) the flexibility to leverage operation order, and its exact
implementation is not important.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;pool&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;8&lt;&#x2F;sup&gt;
&lt;p&gt;One might consider that external energy could be introduced at the
very start when a user calls on the program to execute. However, we will just
streamline this initial
payment by treating it as part of the energy assigned 
to the initial program state.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;corollary&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;9&lt;&#x2F;sup&gt;
&lt;p&gt;As a corollary, since the amortized cost payments are gone,
we also find that the potential of the initial
state bounds the peak cost. This is more useful to measure resources like memory.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;python&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;10&lt;&#x2F;sup&gt;
&lt;p&gt;By pseudo-code I mean python.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;Bell&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;11&lt;&#x2F;sup&gt;
&lt;p&gt;For those with a physics background, you might consider this our version of a &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Bell_test&quot;&gt;Bell test&lt;&#x2F;a&gt;.
In physics, this is a case proving that &lt;em&gt;local realism&lt;&#x2F;em&gt; is incompatible with
quantum quantum mechanics; in our setting, it is a case proving that
purely local potential is insufficient for a tight cost analysis.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;neg&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;12&lt;&#x2F;sup&gt;
&lt;p&gt;This return of energy is modeled in our framework simply by letting \(C\) return negative costs.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;copy&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;13&lt;&#x2F;sup&gt;
&lt;p&gt;Copying is only really needed in this code if &lt;code&gt;process1&lt;&#x2F;code&gt; or &lt;code&gt;process2&lt;&#x2F;code&gt; might mutate the underlying list. However,
the pertinent features of code pattern also come up in side-effect free settings during, e.g., tree traversal.
See &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;abs&#x2F;10.1145&#x2F;3473581&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;overpay&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;17&lt;&#x2F;sup&gt;
&lt;p&gt;Well, technically a worldview could choose to overpay for the cost too.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;detail&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;14&lt;&#x2F;sup&gt;
&lt;p&gt;This sets up our worldviews to begin looking somewhat like
states in &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Quantum_superposition&quot;&gt;quantum superposition&lt;&#x2F;a&gt;.
Both are collections of simultaneous classical-looking states, just with negative
values allowed where they usually wouldn’t be. In quantum physics, those values are
probabilities; in our setting, they are potentials.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;whole&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;15&lt;&#x2F;sup&gt;
&lt;p&gt;While only a technical point here, the consequences of
allowing the accumulation of negative potential in some parts of the
program state does
provide another quantum physical parallel. Two famous no-go theorems of 
quantum physics, &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;No-cloning_theorem&quot;&gt;&lt;em&gt;no-cloning&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; 
and &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;No-deleting_theorem&quot;&gt;&lt;em&gt;no-deleting&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;, mean 
that a quantum state cannot simply duplicate or delete one of its pieces. These 
same principles are relevant to the progam states of the quantum physicist’s method: We cannot 
simply duplicate potential when copying a datastructure, nor may we simply lose potential
when deleting&#x2F;ignoring a datastructure. Either case could
introduce extra potential, when positive amounts are duplicated or negative amounts
are lost, which would violate conservation.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;qt&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;16&lt;&#x2F;sup&gt;
&lt;p&gt;We call this particular way of accounting for how to get around the barrier of the vending machine
“resource tunneling”, because it is analagous to 
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Quantum_tunnelling&quot;&gt;quantum tunneling&lt;&#x2F;a&gt; 
around a potential barrier. In quantum physics, this occurs because a 
particle’s position (or energy, depending on what you measure) is in a 
superposition of many states, a small portion of which allow being on the
other side of the potential barrier; in our setting, it is because potential 
is tracked through the collection of worldviews, at least one of which is 
sufficient to pay for the potential needed. In either case, there may be no
one state of the collection that can explain the tunneling; no state that, 
if tracked individually from the start, could pass the potential barrier.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Robustness between the worst and average case</title>
		<published>2023-04-21T00:00:00+00:00</published>
		<updated>2023-04-21T00:00:00+00:00</updated>
		<link href="https://www.cs.cmu.edu/~csd-phd-blog/2023/intermediate-robustness/" type="text/html"/>
		<id>https://www.cs.cmu.edu/~csd-phd-blog/2023/intermediate-robustness/</id>
		<content type="html">&lt;p&gt;As machine learning systems become increasingly implemented in safety-critical applications, such as autonomous driving and healthcare, we need to ensure these systems are reliable and trustworthy. For example, we might wish to determine whether a car’s camera-based autopilot system can correctly classify the color of the light even in the presence of severe weather conditions, such as snow. Consider that the average snowy day looks something like the following:&lt;&#x2F;p&gt;
&lt;img src=.&#x2F;snow1.png  width=&quot;400&quot;&gt;
&lt;p&gt;Overall, the visibility is not too bad, and we can guess that these weather conditions do not present too much of an issue for the car’s autopilot system. However, every once in a while, we might get a snowy day that looks more like this:&lt;&#x2F;p&gt;
&lt;img src=.&#x2F;snow2.png  width=&quot;400&quot;&gt;
&lt;p&gt;The visibility is much worse in this scenario, and these conditions might be more difficult for the car’s autopilot system to safely navigate. However, the traffic light color, as well as most of the objects on the road, can still be identified, and we would hope that the autopilot would be able to operate correctly in these conditions. Finally, very rarely, we might have a snow squall like the following: &lt;&#x2F;p&gt;
&lt;img src=.&#x2F;snow3.png  width=&quot;400&quot;&gt;
&lt;p&gt;These conditions are so extreme that a human driver would probably need to pull over to the side of the road rather than attempt to drive in with such little visibility. Therefore, we probably should not require the autopilot system to be robust to such conditions. Now we ask the question, how should we evaluate the robustness of the the car’s autopilot to severe weather conditions? &lt;&#x2F;p&gt;
&lt;p&gt;Existing methods for evaluating the robustness of a machine learning model to perturbed inputs (e.g. images that have been corrupted due to severe weather) are largely based on one of two notions. Average-case robustness, measures the model’s average performance on randomly sampled perturbations. In the autopilot example, for instance, we could randomly sample a bunch of images from all days recorded snow precipitation, and measure the average accuracy of the traffic light detection on those days. If most of those samples look like the first image shown above, we should expect the system’s average robustness to be pretty good. This notion of robustness, however, doesn’t tell us much about how our autopilot system will operate on more extreme conditions as depicted in the second and third images. &lt;&#x2F;p&gt;
&lt;p&gt;Alternatively, worst-case robustness, or adversarial robustness, measures the model’s worst-case performance across all possible perturbations. For example, the worst-case performance of the autopilot system might be the result of navigating in the conditions depicted by the third image, displaying the snow squall. In this case, we should expect the system’s worst-case robustness to be pretty bad. But as we mentioned previously, we may not care so much if the system is able to navigate the worst-case conditions shown in the third image. &lt;&#x2F;p&gt;
&lt;p&gt;So then, how do we best measure the robustness of the system to conditions like those shown in the second image, i.e. conditions worse than average, but not the worst possible conditions? In this blog post, we present an alternative method for evaluating the test-time performance of machine learning models that measures robustness &lt;em&gt;between&lt;&#x2F;em&gt; the worst and average case, or &lt;em&gt;intermediate&lt;&#x2F;em&gt; robustness. &lt;&#x2F;p&gt;
&lt;h2 id=&quot;a-simple-example-robustness-to-gaussian-noise&quot;&gt;A simple example: robustness to Gaussian noise&lt;&#x2F;h2&gt;
&lt;p&gt;To further motivate the notion of intermediate robustness, consider the simple scenario in which we are interested in evaluating the robustness of an image classification model to Gaussian noise applied to the input images. The image below is a sample from the ImageNet validation dataset, which an image classifier trained on the ImageNet training dataset correctly classifies as “pizza”. &lt;&#x2F;p&gt;
&lt;img src=.&#x2F;pizza1.png  width=&quot;500&quot;&gt;
&lt;p&gt;Given ten thousand random samples of Gaussian noise, the model classifies 97% of these noised images correctly, including the image below. Given the model correctly classifies a large majority of the randomly perturbed images, evaluating according to average-case robustness will place most weight on “easy” noise samples like this image.&lt;&#x2F;p&gt;
&lt;img src=.&#x2F;pizza2.png  width=&quot;500&quot;&gt;
&lt;p&gt;The following image shown below illustrates an example of a randomly noised image that the model incorrectly classifies as “soup bowl”. Evaluating according to average-case robustness will place not put much weight on these samples that are harder for the model to classify correctly. &lt;&#x2F;p&gt;
&lt;img src=.&#x2F;pizza3.png  width=&quot;500&quot;&gt;
&lt;p&gt;What if we want to evaluate the model’s robustness on a stricter level than average-case robustness? Evaluating the image classifier according to worst-case robustness doesn’t make much sense for this particular noise distribution, because the worst-case noise could be an arbitrarily large amount of noise with extremely low probability due to the Gaussian distribution being unbounded. A more practical evaluation of robustness would consider something stricter than simply average performance on random perturbations, but not quite as strict as adversarial robustness, which is exactly what our intermediate robustness metric enables.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;an-intermediate-robustness-metric&quot;&gt;An intermediate robustness metric&lt;&#x2F;h2&gt;
&lt;p&gt;We’ll now go into the details of how we formulate an intermediate robustness metric. We start by observing that we can naturally generalize average-case and worst-case robustness under one framework. To show this, we will make use of the mathematical definition of an \( L^p \)-norm of a function \( f \) on a measure space \( X \): \( ||f||_p = (\int_X |f|^p )^{(1&#x2F;p)} \). However, to differentiate this from the use of \( \ell_p \)-norm balls as perturbation sets in adversarial robustness, we will from here on out refer this definition as a \(q \)-norm of a function. Ultimately, average and worst-case robustness can be generalized by taking the \( q \)-norm of the loss function over the perturbation distribution, where the loss just measures how well the model performs on the perturbed data. The setting of \( q=1 \) results in average-case robustness, whereas the setting of \( q = \infty \) results in worst-case robustness, because by definition the \( L^\infty \)-norm is given by the pointwise maximum of a function. Then, any value of \( q \) between \( 1 \) and \( \infty \) results in &lt;em&gt;intermediate&lt;&#x2F;em&gt; robustness. This is more formally written below:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Define a neural network \( h \) with parameters \( \theta \), and a loss function \( \ell \) that measures how different the model predictions are from the true label \( y \) given an input \( x \). Consider we are interested in measuring the robustness of this model to perturbations \( \delta \) from some perturbation distribution with density \( \mu \). Now consider the following expectation over the \( q \)-norm of the loss according to this perturbation density,
$$ \mathbf{E}_{x, y \sim \mathcal{D}} \Big[ ||\ell(h_\theta(x+\delta), y)||_{\mu, q} \Big], $$
where the \( q \)-norm of the loss with perturbation density \( \mu \) is the following:
$$ ||\ell(h_\theta(x+\delta), y)||_{\mu, q} = \mathbf{E}_{\delta \sim \mu} [|\ell(h_\theta(x+\delta), y)|^q]^{1&#x2F;q} = \Big( \int |\ell(h_\theta(x+\delta), y)|^q \mu(\delta)d\delta) \Big)^{1&#x2F;q}.$$
Assuming a smooth, non-negative loss function, this expectation corresponds to the expected loss on random perturbations (average-case) when \( q = 1 \), 
$$ || \ell(h_\theta(x+\delta), y) ||_{\mu, 1} = \mathbf{E}_{\delta \sim \mu} [\ell(h_\theta(x+\delta), y)], $$
and the expected maximum loss over all possible perturbations (worst-case) when \( q = \infty \), 
$$ || \ell(h_\theta(x+\delta), y) ||_{\mu, \infty} = \text{max}_{\delta \in \text{Supp}(\mu)}[\ell(h_\theta(x+\delta), y)].$$&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt; &lt;&#x2F;p&gt;
&lt;p&gt;Intuitively, as we increase \( q \), more emphasis will be placed on high loss values, as the losses become more strongly “peaked” due to the exponent of \( q \). And so by increasing \(q \) from \( 1 \) to \( \infty \), we enable a full spectrum of intermediate robustness measurements that are increasingly strict by placing more weight on high loss values. This formulation allows us to evaluate a model’s robustness in a wide range between the two extremes of average and worst case performance.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;approximating-the-metric-using-path-sampling&quot;&gt;Approximating the metric using path sampling&lt;&#x2F;h2&gt;
&lt;p&gt;In most cases, we have to approximate the metric we just defined, which cannot be calculated exactly because it requires computing a high-dimensional integral over the perturbation space. Ultimately, we approximate the integral using the path sampling method [Gelman and Meng, 1998], but to motivate why this is important, we’ll first give an example of a naive, yet suboptimal, way of estimating the integral.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;monte-carlo-estimator&quot;&gt;Monte Carlo estimator&lt;&#x2F;h3&gt;
&lt;p&gt;For illustration purposes, let’s consider approximating the integral \( \int_a^b f(x)^q \mu(x)dx \) for an arbitrary function \( f \) and probability density \( \mu \). Recall that the integral of a function can be interpreted as calculating the area below the function’s curve. We could pick a random sample \( x \), evaluate the function \( f(x)^q \) at \( x \) and multiply by \( (b-a ) \) to estimate the area. However, using just one sample, this will likely underestimate or overestimate the area. If we instead pick many samples and take the average of their estimates, with enough samples this theoretically should eventually converge to something close to the desired integral. This is known as the Monte Carlo estimator, and can be visualized in the plot below for the function \( f(x)^q \) with \( q = 1 \).&lt;&#x2F;p&gt;
&lt;img src=.&#x2F;integral1.png  width=&quot;400&quot;&gt;
&lt;p&gt;Now let’s see what this plot looks like for \( q=2 \). We see that values of \( x \) for which the value \( f(x) \) is large make a larger contribution to the integral. However, because these values of \( x \) have a lower probability of being sampled, random sampling places a disproportionate amount of weight on estimates from \( x \) with lower values of \( f(x) \).&lt;&#x2F;p&gt;
&lt;img src=.&#x2F;integral2.png  width=&quot;400&quot;&gt;
&lt;p&gt;As we continue to increase the value of \( q \), as shown in the plot below for \( q=3 \), we can see that Monte Carlo sampling will be increasingly insufficient to approximate this integral well.&lt;&#x2F;p&gt;
&lt;img src=.&#x2F;integral3.png  width=&quot;400&quot;&gt;
&lt;p&gt;Translating this back to our integral of interest, when the perturbation density is concentrated in a region with low loss values, the Monte Carlo estimator will be less capable of producing an accurate approximation of the integral when we want to evaluate intermediate robustness for larger values of \( q \).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;path-sampling-estimator&quot;&gt;Path sampling estimator&lt;&#x2F;h3&gt;
&lt;p&gt;To better approximate the integral for large values of \( q \), we need to sample perturbations that contribute more largely to the integral (e.g. result in higher loss values) more frequently. Path sampling is one method that boosts the frequency of more “important” samples by sampling from a “path” of alternative densities that encourages samples where the integrand is large. &lt;&#x2F;p&gt;
&lt;p&gt;The path sampling estimator of the intermediate robustness metric ultimately takes the form of the geometric mean of the losses given the sampled perturbations from these alternative densities, which are annealed to follow an increasingly “peaked” distribution. Practically, these samples can be drawn using Markov chain Monte Carlo (MCMC) methods. The path sampling estimator is written more formally below:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Consider the following class of densities,
$$ p(\delta|t) \propto \ell(h_\theta(x+\delta),y)^t \mu(\delta),$$
and construct a path by interpolating \( t^{(i)} \) between 0 and \( q \) and sampling a perturbation \( \delta^{(i)} \) from \( p(\delta|t^{(i)}) \) using MCMC. Then, the path sampling estimator of the intermediate robustness metric is the following geometric mean,
$$ \hat{Z}_\text{Path sampling} := \Big( \prod_{i=1}^m \ell \big( h_\theta(x+\delta^{(i)}), y \big) \Big)^{1&#x2F;m}.$$&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;evaluating-the-intermediate-robustness-of-an-image-classifier&quot;&gt;Evaluating the intermediate robustness of an image classifier&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we have introduced a metric for evaluating the intermediate robustness of a model, along with methods for approximating this metric, let’s evaluate the performance of a model at different robustness levels. We’ll see that the intermediate robustness metric interpolates between measurements of average and the worst-case robustness, providing a multitude of additional ways in which we can measure a model’s robustness, and we’ll empirically show the advantage of the path sampling estimator over the Monte Carlo estimator.&lt;&#x2F;p&gt;
&lt;p&gt;Because it is a setting commonly considered in the adversarial (worst-case) robustness literature, consider evaluating the robustness of an image classifier to perturbations \( \delta \) uniformly distributed within the \( \ell_\infty \)-norm ball with radius \( \epsilon \) (i.e. each component of \( \delta \) is uniformly distributed between \( [-\epsilon, \epsilon] \)).&lt;&#x2F;p&gt;
&lt;p&gt;In the figure below, we plot the test-time performance of an image classifier, trained on the CIFAR-10 dataset, using our intermediate robustness metric for different values of \( q \).&lt;&#x2F;p&gt;
&lt;img src=.&#x2F;interpolating.jpeg  width=&quot;500&quot;&gt;
&lt;p&gt;This figure shows that our proposed intermediate robustness metric does indeed capture the gap between the two existing robustness metrics, effectively interpolating between average-case robustness (\( q=1 \)) and worst-case (adversarial) robustness measurements when increasing the value of \( q \) from left to right.&lt;&#x2F;p&gt;
&lt;p&gt;We can also compare the Monte Carlo and path sampling estimators for different values of \( q \). This figure illustrates that while both of the approximation methods result in a similar estimate for \( q=1 \), for larger values of \( q \), path sampling results in a higher, more accurate estimate of the intermediate robustness metric, more closely approaching the adversarial loss, when compared to Monte Carlo sampling.&lt;&#x2F;p&gt;
&lt;p&gt;The benefit of the path sampling estimator can be further shown in the figure below, which plots the convergence of the Monte Carlo sampling and path sampling estimates of the intermediate robustness metric given an increasing number of samples.&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;center&quot;&gt;Convergence with \( q=1 \)&lt;&#x2F;th&gt;&lt;th align=&quot;center&quot;&gt;Convergence with \( q=100 \)&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;&lt;img src=&quot;.&#x2F;convergence-q=1.jpeg&quot; alt=&quot;q=1&quot; &#x2F;&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;&lt;img src=&quot;.&#x2F;convergence-q=100.jpeg&quot; alt=&quot;q=100&quot; &#x2F;&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;Again, when approximating the robustness metric for \( q=1 \), shown on the left, both estimators converge to the same value with relatively few iterations. However, when approximating the intermediate robustness metric for \( q=100 \), shown on the right, the Monte Carlo sampler results in estimates that are consistently lower and less accurate than those of path sampling, even with a large number of samples. &lt;&#x2F;p&gt;
&lt;h2 id=&quot;training-for-different-levels-of-robustness&quot;&gt;Training for different levels of robustness&lt;&#x2F;h2&gt;
&lt;p&gt;We can also &lt;em&gt;train&lt;&#x2F;em&gt; machine learning models according to specific levels of robustness by choosing a value of \( q \) and minimizing the intermediate robustness objective. However, training intermediate robust models is computationally challenging because a non-trivial number of perturbation samples is needed to accurately estimate the robustness objective, even when using the path sampling method. While evaluating models simply requires one iteration over the test dataset, training requires multiple iterations over the training dataset, resulting in an extremely expensive procedure when effectively multiplying the dataset size by the number of perturbaton samples.&lt;&#x2F;p&gt;
&lt;p&gt;Due to this computational complexity, we train an image classifier on the simpler MNIST dataset (using the same perturbation set) to minimize the intermediate robustness objective for different values of \( q \) (approximated using path sampling). We train one model with \( q=1 \), which is just like training with data augmentation (training on randomly sampled perturbations), and we train one model with \( q=100 \), which is somewhere in between training with data augmentation and adversarial training (training on worst-case perturbations).&lt;&#x2F;p&gt;
&lt;p&gt;We evaluate the intermediate and adversarial robustness of each of the final trained models, the results of which can be seen in the figure below.&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;center&quot;&gt;Training with \( q=1 \)&lt;&#x2F;th&gt;&lt;th align=&quot;center&quot;&gt;Training with \( q=100 \)&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;&lt;img src=&quot;.&#x2F;train_q1.png&quot; alt=&quot;q=1&quot; &#x2F;&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;&lt;img src=&quot;.&#x2F;train_q100.png&quot; alt=&quot;q=100&quot; &#x2F;&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;While the model trained with \( q=1 \), shown on the left, and the model trained with \( q=100 \), shown on the right, have similar performance when evaluated at less strict robustness levels, \( q=1 \) and \( q=10 \), the model trained with \( q=100 \) is much more robust when comparing the stricter \( q=1000 \) and adversarial robustness measurements.&lt;&#x2F;p&gt;
&lt;p&gt;Ultimately, the main takeaway from training using the proposed intermediate robustness objective is that the choice of \( q \) allows for fine-grained control over the desired level of robustness, rather than being restricted to average-case or worst-case objectives.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;We’ve introduced a new robustness metric that allows for evaluating a machine learning model’s intermediate robustness, bridging the gap between evaluating robustness to random perturbations and robustness to worst-case perturbations. This intermediate robustness metric generalizes average-case and worst-case notions of robustness under the same framework as functional \( q \)-norms of the loss function over the perturbation distribution. We introduced a method for approximating this metric using path sampling, which results in a more accurate estimate of the metric compared to naive Monte Carlo sampling when evaluating at robustness levels approaching adversarial robustness. Empirically we showed that by evaluating an image classifier on additive noise perturbations, the proposed intermediate robustness metric enables a broader spectrum of robustness measurements, between the least strict notion of average performance on random perturbations and the most conservative notion of adversarial robustness. Finally, we highlighted the potential ability to train for specific levels of robustness using intermediate-\( q \) robustness as a training objective. For additional details, see our paper &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;proceedings.neurips.cc&#x2F;paper&#x2F;2021&#x2F;file&#x2F;ea4c796cccfc3899b5f9ae2874237c20-Paper.pdf&quot;&gt;here&lt;&#x2F;a&gt; and code &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;locuslab&#x2F;intermediate_robustness&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;references&quot;&gt;References&lt;&#x2F;h2&gt;
&lt;p&gt;Andrew Gelman and Xiao-Li Meng. Simulating normalizing constants: From importance sampling
to bridge sampling to path sampling. Statistical science, pages 163–185, 1998.&lt;&#x2F;p&gt;
&lt;p&gt;Bennett, Charles H. “Efficient estimation of free energy differences from Monte Carlo data.” Journal of Computational Physics 22.2 (1976): 245-268.&lt;&#x2F;p&gt;
&lt;p&gt;Meng, Xiao-Li, and Wing Hung Wong. “Simulating ratios of normalizing constants via a simple identity: a theoretical exploration.” Statistica Sinica (1996): 831-860.&lt;&#x2F;p&gt;
&lt;p&gt;Simon Duane, Anthony D Kennedy, Brian J Pendleton, and Duncan Roweth. Hybrid monte carlo.
Physics letters B, 195(2):216–222, 1987&lt;&#x2F;p&gt;
&lt;h2 id=&quot;acknowledgements&quot;&gt;Acknowledgements&lt;&#x2F;h2&gt;
&lt;p&gt;This blog post is based on the NeurIPS 2021 paper titled &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;proceedings.neurips.cc&#x2F;paper&#x2F;2021&#x2F;file&#x2F;ea4c796cccfc3899b5f9ae2874237c20-Paper.pdf&quot;&gt;Robustness between the worst and average case&lt;&#x2F;a&gt;, which was joint work with &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;annaebair.github.io&#x2F;&quot;&gt;Anna Bair&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.huan-zhang.com&#x2F;&quot;&gt;Huan Zhang&lt;&#x2F;a&gt;, and &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;zicokolter.com&#x2F;&quot;&gt;Zico Kolter&lt;&#x2F;a&gt;. This work was supported by a grant from the Bosch Center for Intelligence.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Classification with Strategically Withheld Data</title>
		<published>2023-02-21T00:00:00+00:00</published>
		<updated>2023-02-21T00:00:00+00:00</updated>
		<link href="https://www.cs.cmu.edu/~csd-phd-blog/2023/withheld/" type="text/html"/>
		<id>https://www.cs.cmu.edu/~csd-phd-blog/2023/withheld/</id>
		<content type="html">&lt;p&gt;&lt;em&gt;This blog post is based on a &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2012.10203.pdf&quot;&gt;research paper&lt;&#x2F;a&gt; with the same title, authored by Anilesh Krishnaswamy, Haoming Li, David Rein, Hanrui Zhang, and Vincent Conitzer, published at AAAI 2021.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;TL;DR: We investigate a classification problem where each data point being classified is controlled by an agent who has its own goals or incentives, and may strategically withhold certain features in order to game the classifer and get a more desirable label.  We use (an oversimplied version of) college admissions as a running example to illustrate how traditional methods may fail in such settings, as well as how insights from the economic field of mechanism design may help.  We then demonstrate a principled method — Incentive-Compatible Logistic Regression — for classification problems with strategically withheld features, which achieves remarkable empirical performance on credit approval data.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Applicants to most colleges in the US are required to submit their scores for at least one of the SAT and the ACT.
Applicants usually take one of these two tests — &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.princetonreview.com&#x2F;college&#x2F;sat-act&quot;&gt;whichever works to their advantage&lt;&#x2F;a&gt;.
However, given the growing competitiveness of college admissions, many applicants now take both tests and then strategically decide whether to &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;blog.collegevine.com&#x2F;should-you-submit-your-sat-act-scores&#x2F;&quot;&gt;drop one of the scores&lt;&#x2F;a&gt; (if they think it will hurt their application) or report both.
The key issue here is that it is impossible to distinguish between an applicant who takes both tests but reports only one, and an applicant who takes only one test — for example, because the applicant simply took the one required by their school, the dates for the other test did not work with their schedule, or for other reasons that are not strategic in nature.
Such ambiguity makes it harder for colleges to accurately evaluate applicants, especially since colleges now increasingly &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.fastcompany.com&#x2F;90342596&#x2F;schools-are-quietly-turning-to-ai-to-help-pick-who-gets-in-what-could-go-wrong&quot;&gt;rely on machine learning techniques to help make admissions decisions&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-can-go-wrong&quot;&gt;What Can Go Wrong?&lt;&#x2F;h2&gt;
&lt;p&gt;Consider the following simplified scenario: each applicant may naturally (i.e., before they strategically drop one of the scores) have an SAT score, an ACT score, or both.
We also assume these scores are normalized, so they become real numbers between 0 and 1.
Suppose the true competitiveness of an applicant is the average of the scores they naturally have — that is, if an applicant naturally has only one score, then that score is their true competitiveness; if an applicant naturally has both scores, then their true competitiveness is the average of the two scores.
We will use this setup as our running example from now on.
We will not try to “solve” this example problem (later we will see that in some cases, there is no satisfactory solution to the problem), but rather, we will use the example to illustrate the limitations of some classical methods, as well as to motivate the more principled method that we propose.&lt;&#x2F;p&gt;
&lt;p&gt;Now a college wishes to assess each applicant’s competitiveness based on the scores, and admit all applicants whose competitiveness is at least 0.5 (or some threshold chosen by the college).
Assuming all applicants report all scores they naturally have, it is easy to make admissions decisions: the college simply computes each applicant’s average score, and admits that applicant if the average is at least 0.5.
In other words, the college implements a simple &lt;strong&gt;classifier&lt;&#x2F;strong&gt;, which assigns any applicant &lt;strong&gt;label “admitted”&lt;&#x2F;strong&gt; if the average value of their &lt;strong&gt;&lt;em&gt;natural&lt;&#x2F;em&gt; features&lt;&#x2F;strong&gt; is at least 0.5.&lt;&#x2F;p&gt;
&lt;p&gt;However, the simple classifier has its problems: after it is used for admissions for a couple of years, applicants may eventually figure out how it works (for example, by talking to past applicants and researching their test scores and application results).
Once applicants know how the decisions are made, they can easily game the system by strategically withholding information.
Consider, for example, an applicant with an SAT score of 0.6 and an ACT score of 0.2.
The applicant would normally be rejected since their true competitiveness is 0.4, which is smaller than the classifier’s threshold, 0.5.
However, knowing how the classifier works, the applicant can withhold the ACT score and report the SAT score only to the college.
Then the classifier would mistakenly believe that the applicant’s competitiveness is 0.6, and admit the applicant.
As a result, the classifier is not accurate anymore when applicants act strategically and try to game it.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;how-can-we-fix-it&quot;&gt;(How) Can We Fix It?&lt;&#x2F;h2&gt;
&lt;p&gt;Taking into consideration the fact that applicants will eventually figure out how decisions are made, and in response to that, withhold scores strategically to maximize their chances, is it still possible for the college to admit exactly those applicants that the college wants to admit?
The answer is — perhaps not so surprisingly — it &lt;em&gt;depends on the &lt;strong&gt;distribution&lt;&#x2F;strong&gt; of applicants&lt;&#x2F;em&gt;, including how often each score is missing, as well as how the two scores correlate.
To illustrate this dependence, below we discuss two extreme cases.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;.&#x2F;examples.png&quot; alt=&quot;two extreme cases&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In one extreme case (illustrated in the left of the figure), every applicant naturally has both scores and the college knows that.
Then, the college’s problem is again simple: the college admits an applicant if and only if that applicant reports both scores, and the average of the two scores is at least 0.5.
This ensures that no applicant would want to withhold a score, because that would lead to automatic rejection.
Moreover, no applicant would be mistakenly rejected because they cannot report both scores, since everyone naturally has both scores.&lt;&#x2F;p&gt;
&lt;p&gt;In another extreme case (illustrated in the right of the figure), there are only two types of applicants: a type-1 applicant naturally has an SAT score of 0.6 and does not have an ACT score; a type-2 applicant naturally has an SAT score of 0.6 and an ACT score of 0.2.
Ideally, the college would like to admit all type-1 applicants (because their competitiveness is 0.6), and reject all type-2 applicants (because their competitiveness is 0.4).
However, this is impossible once applicants respond strategically to the college’s classifier.
For example, if the college admits all type-1 applicants whose SAT score is 0.6 and ACT score is missing, then a type-2 applicant would pretend to be a type-1 applicant by withholding their ACT score, and get admitted too.
On the other hand, to prevent type-2 applicants getting in by pretending to be type-1 applicants, the college would have to reject all type-1 applicants too, eventually admitting no one.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;a-principled-approach-via-mechanism-design&quot;&gt;A Principled Approach via Mechanism Design&lt;&#x2F;h2&gt;
&lt;p&gt;The above discussion highlights one fact: when applicants respond strategically, the optimal classifier must depend on the distribution of applicants, even if the college’s criteria for admissions stays the same, and there is no restrictions whatsoever on how many applicants can be admitted.
This is reminiscent of problems in &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Mechanism_design&quot;&gt;mechanism design&lt;&#x2F;a&gt;.
In a mechanism design problem, a &lt;strong&gt;principal&lt;&#x2F;strong&gt; designs and commits to a decision rule, or a &lt;strong&gt;mechanism&lt;&#x2F;strong&gt; — in the admissions problem discussed above, the principal is the college, and the decision rule is the classifier used for admissions.
Self-interested &lt;strong&gt;agents&lt;&#x2F;strong&gt; (e.g., applicants) then respond to this rule by reporting (possibly nontruthfully) their private information (e.g., their test scores) to the principal.
The mechanism then chooses an &lt;strong&gt;outcome&lt;&#x2F;strong&gt; (e.g., admissions decisions) based on the reported information.
Taking the agents’ strategic behavior into consideration, the principal aims to design a mechanism to maximize their own &lt;strong&gt;utility&lt;&#x2F;strong&gt; (e.g., accuracy of admissions decisions), which generally depends on both the outcome and the agents’ private information.
In fact, in our running example, the college’s problem can be cast directly as a mechanism design problem.
Below we will see how tools from mechanism design can help in solving the college’s classification problem.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;incentive-compatibility-and-the-revelation-principle&quot;&gt;Incentive Compatibility and the Revelation Principle&lt;&#x2F;h3&gt;
&lt;p&gt;A key notion in mechanism design is &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Incentive_compatibility&quot;&gt;incentive compatibility&lt;&#x2F;a&gt;: a mechanism is incentive-compatible if it is always in the agents’ best interest to truthfully report their private information.
Applied to our running example, incentive compatibility means that applicants would never want to withhold a test score that they naturally have.
One reason that incentive compatibility is so important in mechanism design is that it is often &lt;em&gt;without loss of generality&lt;&#x2F;em&gt;: if there is no restriction on the ways in which an agent can (mis)report their private information, then for any (possibly not incentive-compatible) mechanism, there always exists an “incentive-compatible version” of that mechanism which achieves the same effects.
This is famously known as the &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Revelation_principle&quot;&gt;revelation principle&lt;&#x2F;a&gt;.
The reason that the revelation principle holds is simple: the principal can adapt any mechanism into an incentive-compatible one by “misreporting for” the agents, in the exact way that the agents would misreport in response to the original mechanism.
We show that a variant of the revelation principle applies to the college’s classification problem (and more generally, to all classification problems with strategically withheld features).
This greatly simplifies the problem, because without loss of generality, we only need to consider classifiers under which applicants have no incentive to withhold any score.
This effectively removes the strategic aspect and leaves a clean classification problem.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;incentive-compatible-logistic-regression&quot;&gt;Incentive-Compatible Logistic Regression&lt;&#x2F;h3&gt;
&lt;p&gt;Given the revelation principle, we propose a principled method, &lt;strong&gt;incentive-compatible logistic regression&lt;&#x2F;strong&gt;, for classification problems with strategically withheld data.
The idea is simple: we run the classical gradient-based algorithm for logistic regression, &lt;em&gt;but with the search space restricted to classifiers that are incentive-compatible&lt;&#x2F;em&gt;.
The college can then use the resulting model to classify applicants in an incentive-compatible way.
We will see below how this can be done by adding a projection step to the region of incentive-compatible classifiers, after each gradient step.&lt;&#x2F;p&gt;
&lt;p&gt;Recall that in logistic regression, the goal is to learn a set of coefficients \({\beta_i}\), one for each feature \(i\), as well as an intercept \(\beta_0\), such that for each data point \((x, y)\), the predicted label \(\hat{y}\) given by
\[
\hat{y} = \mathbb{I}\left[\sigma\left(\beta_0 + \sum_i x_i \cdot \beta_i\right) \ge 0.5\right]
\]
fits the true label \(y\) as well as possible.
Here, \(\sigma\) is the logistic function, defined as
\[
\sigma(t) = 1 &#x2F; (1 + e^{-t}).
\]
Mapping these notions back to our running example, each data point \((x, y)\) corresponds to an applicant, where each feature \(x_i\) is one of the two scores, and the true label \(y\) is \(1\) (corresponding to “admitted”) if the applicant’s true competitiveness is at least the college’s desired threshold, and \(0\) (corresponding to “rejected”) otherwise.
The classifier computes a predicted label \(\hat{y}\) for each data point, which is the admissions decision for that specific applicant.
Naturally, the college wants \(\hat{y}\) to fit \(y\) as well as possible.&lt;&#x2F;p&gt;
&lt;p&gt;It turns out there is a simple condition for the classifier of the above form to be incentive-compatible.
Without loss of generality, suppose each feature \(x_i\) is always nonnegative.
this is naturally true in our running example, since each feature is a score between \(0\) and \(1\); in general, we can shift the features if they are not nonnegative.
Moreover, if a feature is missing in a data point, then we simply treat that feature as \(0\).
Then a classifier induced by \({\beta_i}\) is incentive-compatible if and only if each \(\beta_i\) is nonnegative.
This is because if some \(\beta_i &amp;lt; 0\), then a data point with feature \(x_i &amp;gt; 0\) will be able to increase their score, \(\sigma\left(\beta_0 + \sum_i x_i \cdot \beta_i\right)\), by withholding feature \(x_i\).
Depending on the values of other features, this will sometimes change the predicted label of that data point from \(0\) (i.e., rejected) to \(1\) (i.e., admitted).
In other words, such a classifier cannot be incentive-compatible.
On the other hand, if each \(\beta_i\) is nonnegative, then for any data point, withholding a feature \(x_i\) can never increase the score, so there is no incentive to withhold any feature.&lt;&#x2F;p&gt;
&lt;p&gt;Given the above characterization, we can simply adapt the gradient-based algorithm for (unconstrained) logistic regression to find a good incentive-compatible classifier.
We initialize the classifier arbitrarily, and repeat the following steps for each data point \((x, y)\) until convergence:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;The gradient step&lt;&#x2F;strong&gt;: Let
\[
\beta_0 \gets \beta_0 - \eta_t \cdot \left(\sigma\left(\beta_0 + \sum_i x_i \cdot \beta_i\right) - y\right).
\]
For each feature \(i\), let
\[
\beta_i \gets \beta_i - \eta_t \cdot \left(\sigma\left(\beta_0 + \sum_i x_i \cdot \beta_i\right) - y\right) \cdot x_i.
\]
Here, \(\eta_t\) is the learning rate in step \(t\).
This rate normally decreases in \(t\), e.g., \(\eta_t = 1 &#x2F; \sqrt{t}\).&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;The projection step&lt;&#x2F;strong&gt;: For each feature \(i\), let
\[
\beta_i \gets \max\{0, \beta_i\}.
\]&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;This can be viewed as an instantiation of the projected gradient descent algorithm: the gradient step is exactly the same as in (unconstrained) logistic regression, and the projection step ensures that the incentive-compatibility constraint is satisfied.&lt;&#x2F;p&gt;
&lt;p&gt;Coming back to our running example, incentive-compatible logistic regression will assign a nonnegative weight to each test score and admit an applicant if the weighted sum of the two scores exceeds some threshold.  Note that this does not “solve” the college’s problem in all cases: for example, between the two extreme cases discussed above, incentive-compatible logistic regression would work very well in the first case, but in the second case its performance would not be practically meaningful, simply because the second case is intrinsically hard and no classifier can achieve a reasonable accuracy there.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;experimental-results&quot;&gt;Experimental Results&lt;&#x2F;h2&gt;
&lt;p&gt;We empirically evaluate incentive-compatible logistic regression on 4 real-world credit approval datasets from the &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;archive.ics.uci.edu&#x2F;ml&#x2F;index.php&quot;&gt;UCI ML Repository&lt;&#x2F;a&gt;, based on historical data collected in Australia, Germany, Poland, and Taiwan.
Each data point in each dataset corresponds to a single credit application, with tens of features (3 datasets provide 15-23 features, and the other provides 64), including annual income, employment status, current balance in savings account, etc.
Each data point has a binary label, which is either “approve” (i.e., 1) or “reject” (i.e., 0).
We preprocess the datasets by randomly dropping some features for each data point, thus simulating naturally missing features.
We consider two ways of reporting in our evaluation:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Truthful reporting&lt;&#x2F;strong&gt;: Each data point always reveals all features it naturally has to the classifier.
This is the assumption made by the baseline methods, which we compare against in our evaluation.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Strategic reporting&lt;&#x2F;strong&gt;: In reponse to the classifier, each data point optimally withholds a subset of features to maximize the chance of getting approved (i.e., label 1).
For incentive-compatible logistic regression, strategic reporting is equivalent to truthful reporting.
However, as we will see, the baseline methods perform significantly worse with strategic reporting (which is natural, since they were not designed to be robust against strategic manipulation).&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;As for the baseline methods, we compare against &lt;strong&gt;logistic regression&lt;&#x2F;strong&gt; (without incentive-compatibility), &lt;strong&gt;neural networks&lt;&#x2F;strong&gt;, and &lt;strong&gt;random forests&lt;&#x2F;strong&gt;.
These are the most popular and accurate methods in credit approval applications.
For more details of the experiments, please see Section 6 of &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2012.10203.pdf&quot;&gt;our paper&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The accuracy of each classifier tested on each dataset can be found in the table below.
Note that there are two numbers in each cell: the left one corresponds to the accuracy under truthful reporting, and the right one corresponds to the accuracy under strategic reporting.&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Classifier&lt;&#x2F;th&gt;&lt;th&gt;Australia&lt;&#x2F;th&gt;&lt;th&gt;Germany&lt;&#x2F;th&gt;&lt;th&gt;Poland&lt;&#x2F;th&gt;&lt;th&gt;Taiwan&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;Incentive-compatible logistic regression&lt;&#x2F;td&gt;&lt;td&gt;&lt;strong&gt;0.800&lt;&#x2F;strong&gt; &#x2F; &lt;strong&gt;0.800&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;0.651 &#x2F; &lt;strong&gt;0.651&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;0.698 &#x2F; &lt;strong&gt;0.698&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;0.646 &#x2F; &lt;strong&gt;0.646&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Logistic regression (baseline)&lt;&#x2F;td&gt;&lt;td&gt;&lt;strong&gt;0.800&lt;&#x2F;strong&gt; &#x2F; 0.763&lt;&#x2F;td&gt;&lt;td&gt;&lt;strong&gt;0.652&lt;&#x2F;strong&gt; &#x2F; 0.580&lt;&#x2F;td&gt;&lt;td&gt;0.714 &#x2F; 0.660&lt;&#x2F;td&gt;&lt;td&gt;0.670 &#x2F; 0.618&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Artificial neural networks (baseline)&lt;&#x2F;td&gt;&lt;td&gt;&lt;strong&gt;0.800&lt;&#x2F;strong&gt; &#x2F; 0.747&lt;&#x2F;td&gt;&lt;td&gt;&lt;strong&gt;0.652&lt;&#x2F;strong&gt; &#x2F; 0.580&lt;&#x2F;td&gt;&lt;td&gt;&lt;strong&gt;0.719&lt;&#x2F;strong&gt; &#x2F; 0.636&lt;&#x2F;td&gt;&lt;td&gt;&lt;strong&gt;0.688&lt;&#x2F;strong&gt; &#x2F; 0.543&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Random forest (baseline)&lt;&#x2F;td&gt;&lt;td&gt;0.797 &#x2F; 0.541&lt;&#x2F;td&gt;&lt;td&gt;0.633 &#x2F; 0.516&lt;&#x2F;td&gt;&lt;td&gt;0.709 &#x2F; 0.522&lt;&#x2F;td&gt;&lt;td&gt;0.684 &#x2F; 0.588&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;Here we make two observations:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Under strategic reporting, incentive-compatible logistic regression is consistently much more accurate than all 3 baseline methods.
This highlights the importance of robustness against strategic manipulation by design.&lt;&#x2F;li&gt;
&lt;li&gt;The accuracy of incentive-compatible logistic regression under strategic reporting is often comparable to that of the baseline methods under truthful reporting.
In other words, although strategic manipulation poses challenges in the design of a good classifier, from an information-theoretic perspective, the classification problem does not become much harder.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;We study the problem of classification when each data point can strategically withhold some of its features to obtain a more favorable outcome.
We propose a principled classification method, incentive-compatible logistic regreggsion, which is robust to strategic manipulation.
The new method is tested on real-world datasets, showing that it outperforms out-of-the-box methods that do not account for strategic behavior.
More generally, we draw connections between strategic classification and mechanism design, which may inspire future work in other strategic classification settings.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Designing Data Structures for Collaborative Apps</title>
		<published>2023-02-17T00:00:00+00:00</published>
		<updated>2023-02-17T00:00:00+00:00</updated>
		<link href="https://www.cs.cmu.edu/~csd-phd-blog/2023/collaborative-data-design/" type="text/html"/>
		<id>https://www.cs.cmu.edu/~csd-phd-blog/2023/collaborative-data-design/</id>
		<content type="html">&lt;h1 id=&quot;introduction-collaborative-apps-via-crdts&quot;&gt;Introduction: Collaborative Apps via CRDTs&lt;&#x2F;h1&gt;
&lt;blockquote&gt;
&lt;p&gt;An extended version of this post appears &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;mattweidner.com&#x2F;2022&#x2F;02&#x2F;10&#x2F;collaborative-data-design.html&quot;&gt;on my personal site&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;&#x2F;p&gt;&lt;br &#x2F;&gt;
&lt;p&gt;Suppose you’re building a collaborative app, along the lines of Google Docs&#x2F;Sheets&#x2F;Slides, Figma, Notion, etc., but &lt;em&gt;without a central server&lt;&#x2F;em&gt;. One challenge you’ll face is the actual collaboration: when one user changes the shared state, their changes need to show up for every other user. For example, if multiple users type at the same time in a text field, the result should reflect all of their changes and be consistent (identical for all users).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Conflict-free_replicated_data_type&quot;&gt;&lt;strong&gt;Conflict-free Replicated Data Types (CRDTs)&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; provide a solution to this challenge. They are data structures that look like ordinary data structures (maps, sets, text strings, etc.), except that they are collaborative: when one user updates their copy of a CRDT, their changes automatically show up for everyone else. Each user sees their own changes immediately, while under the hood, the CRDT broadcasts a message describing the change to everyone else.  Other users see the change once they receive this message.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;collaborative-data-design&#x2F;message_sending.png&quot; alt=&quot;CRDTs broadcast messages to relay changes&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a name=&quot;correctness&quot;&gt;&lt;&#x2F;a&gt;Note that multiple users might make changes at the same time, e.g., both typing at once. Since each user sees their own changes immediately, their views of the document will temporarily diverge. However, CRDTs guarantee that once the users receive each others’ messages, they’ll see identical document states again: this is the definition of &lt;strong&gt;CRDT correctness&lt;&#x2F;strong&gt;. Ideally, this state will also be “reasonable”, i.e., it will incorporate both of their edits in the way that the users expect.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;In distributed systems terms, CRDTs are &lt;em&gt;Available&lt;&#x2F;em&gt;, &lt;em&gt;Partition tolerant&lt;&#x2F;em&gt;, and have &lt;em&gt;Strong Eventual Consistency&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;&#x2F;p&gt;&lt;br &#x2F;&gt;
&lt;p&gt;CRDTs work even if messages might be arbitrarily delayed, or delivered to different users in different orders. This lets you make collaborative experiences that don’t need a central server, work offline, and&#x2F;or are end-to-end encrypted (&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.inkandswitch.com&#x2F;local-first&#x2F;&quot;&gt;&lt;strong&gt;local-first software&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;collaborative-data-design&#x2F;google_docs_offline.png&quot; alt=&quot;Google Docs doesn’t let you type while offline&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;i&gt;CRDTs allow offline editing, unlike Google Docs.&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I’m particularly excited by the potential for &lt;strong&gt;open-source collaborative apps&lt;&#x2F;strong&gt; that anyone can distribute or modify, without requiring app-specific hosting.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-challenge-designing-crdts&quot;&gt;The Challenge: Designing CRDTs&lt;&#x2F;h2&gt;
&lt;p&gt;Having read all that, let’s say you choose to use a CRDT for your collaborative app. All you need is a CRDT representing your app’s state, a frontend UI, and a network of your choice (or a way for users to pick the network themselves). But where do you get a CRDT for your specific app?&lt;&#x2F;p&gt;
&lt;p&gt;If you’re lucky, it’s described in a &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;crdt.tech&#x2F;papers.html&quot;&gt;paper&lt;&#x2F;a&gt;, or even better, implemented in a &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;crdt.tech&#x2F;implementations&quot;&gt;library&lt;&#x2F;a&gt;. But those tend to have simple or one-size-fits-all data structures: maps, text strings, unstructured JSON, etc. You can usually rearrange your app’s state to make it fit in these CRDTs; and if users make changes at the same time, CRDT correctness guarantees that you’ll get &lt;em&gt;some&lt;&#x2F;em&gt; consistent result. However, it might not be what you or your users expect. Worse, you have little leeway to customize this behavior.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;collaborative-data-design&#x2F;json_anomaly.png&quot; alt=&quot;Anomaly in a published JSON CRDT: In a collaborative todo-list, concurrently deleting an item and marking it done results in a nonsense list item with no text field.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;i&gt;
In a &lt;a href=&quot;https:&#x2F;&#x2F;doi.org&#x2F;10.1109&#x2F;TPDS.2017.2697382&quot; target=&quot;_blank&quot;&gt;published JSON CRDT&lt;&#x2F;a&gt;, when representing a todo-list using items with &quot;title&quot; and &quot;done&quot; fields, you can end up with an item &lt;code&gt;{&quot;done&quot;: true}&lt;&#x2F;code&gt; having no &quot;title&quot; field. Image credit: Figure 6 from the paper.
&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;!--figure: hypothetical user Q&amp;A asking for a change in the conflict-resolution, and you just reply &quot;sorry&quot;.--&gt;
&lt;p&gt;This blog post will instead teach you how to design CRDTs from the ground up. I’ll present a few simple CRDTs that are obviously correct, plus ways to compose them together into complicated whole-app CRDTs that are still obviously correct. I’ll also present principles of CRDT design to help guide you through the process. To cap it off, we’ll design a CRDT for a collaborative spreadsheet.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Ultimately, I hope that you will gain not just an understanding of some existing CRDT designs, but also the confidence to tweak them and create your own!&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;related-work&quot;&gt;Related Work&lt;&#x2F;h2&gt;
&lt;p&gt;The CRDTs I describe are based on &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;dx.doi.org&#x2F;10.1007&#x2F;978-3-642-24550-3_29&quot;&gt;Shapiro et al. 2011&lt;&#x2F;a&gt; unless noted otherwise. However, the way I describe them, and the design principles and composition techniques, are my own way of thinking about CRDT design. It’s inspired by the way &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.figma.com&#x2F;blog&#x2F;how-figmas-multiplayer-technology-works&#x2F;&quot;&gt;Figma&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;hex.tech&#x2F;blog&#x2F;a-pragmatic-approach-to-live-collaboration&quot;&gt;Hex&lt;&#x2F;a&gt; describe their collaboration platforms; they likewise support complex apps by composing simple, easy-to-reason-about pieces. Relative to those platforms, I incorporate more academic CRDT designs, enabling more flexible behavior and server-free operation.&lt;&#x2F;p&gt;
&lt;!--I&#x27;ll describe most CRDTs in terms of an implementation, because I find implementations easier to explain. However, my real goal is to describe their *semantics*: what users see after they perform various operations, possibly concurrently. If you can find alternate implementations that have the same behavior as the ones I describe but are more efficient, then by all means, use those instead. --&gt;
&lt;h1 id=&quot;basic-designs&quot;&gt;Basic Designs&lt;&#x2F;h1&gt;
&lt;p&gt;I’ll start by going over some basic CRDT designs.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;unique-set&quot;&gt;Unique Set&lt;&#x2F;h2&gt;
&lt;p&gt;Our foundational CRDT is the &lt;strong&gt;Unique Set&lt;&#x2F;strong&gt;.  It is a set in which each added element is considered unique.&lt;&#x2F;p&gt;
&lt;p&gt;Formally, the user-facing operations on the set, and their collaborative implementations, are as follows:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;add(x)&lt;&#x2F;code&gt;: Adds an element &lt;code&gt;e = (t, x)&lt;&#x2F;code&gt; to the set, where &lt;code&gt;t&lt;&#x2F;code&gt; is a &lt;em&gt;unique new tag&lt;&#x2F;em&gt;, used to ensure that &lt;code&gt;(t, x)&lt;&#x2F;code&gt; is unique. To implement this, the adding user generates &lt;code&gt;t&lt;&#x2F;code&gt;, e.g., as a pair (device id, device-specific counter), then serializes &lt;code&gt;(t, x)&lt;&#x2F;code&gt; and broadcasts it to the other users.  The receivers deserialize &lt;code&gt;(t, x)&lt;&#x2F;code&gt; and add it to their local copy of the set.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;delete(e)&lt;&#x2F;code&gt;: Deletes the element &lt;code&gt;e = (t, x)&lt;&#x2F;code&gt; from the set.  To implement this, the deleting user serializes &lt;code&gt;t&lt;&#x2F;code&gt; and broadcasts it to the other users.  The receivers deserialize &lt;code&gt;t&lt;&#x2F;code&gt; and remove the element with tag &lt;code&gt;t&lt;&#x2F;code&gt; from their local copy, if it has not been deleted already.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;collaborative-data-design&#x2F;message_flow.png&quot; alt=&quot;In response to user input, the operator calls “Output message”. The message is then delivered to every user’s “Receive &amp;amp; Update display” function.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;i&gt;The lifecycle of an &lt;code&gt;add&lt;&#x2F;code&gt; or &lt;code&gt;delete&lt;&#x2F;code&gt; operation.&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;p&gt;When displaying the set to the user, you ignore the tags and just list out the data values &lt;code&gt;x&lt;&#x2F;code&gt;, keeping in mind that (1) they are not ordered (at least not consistently across different users), and (2) there may be duplicates.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;&#x2F;strong&gt; In a collaborative flash card app, you could represent the deck of cards as a Unique Set, using &lt;code&gt;x&lt;&#x2F;code&gt; to hold the flash card’s value (e.g., its front and back strings). Users can edit the deck by adding a new card or deleting an existing one, and duplicate cards are allowed. &lt;!--Note that the collaborative state is just the *set* of cards; there is no ordering info. You could perhaps sort them alphabetically in editing mode (to make them consistent), and randomly in practice mode (deliberately inconsistent).--&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a name=&quot;causal-order&quot;&gt;&lt;&#x2F;a&gt;When broadcasting messages, we require that they are delivered &lt;em&gt;reliably&lt;&#x2F;em&gt; and &lt;em&gt;in causal order&lt;&#x2F;em&gt;, but it’s okay if they are arbitarily delayed.  (These rules apply to all CRDTs, not just the Unique Set.) Delivery &lt;strong&gt;in causal order&lt;&#x2F;strong&gt; means that if a user sends a message \(m\) after receiving or sending a message \(m^\prime\), then all users delay receiving \(m\) until after receiving \(m^\prime\). This is the strictest ordering we can implement without a central server and without extra round-trips between users, e.g., by using &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Vector_clock&quot;&gt;vector clocks&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Messages that aren’t ordered by the causal order are &lt;strong&gt;concurrent&lt;&#x2F;strong&gt;, and different users might receive them in different orders. But for &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;collaborative-data-design&#x2F;#correctness&quot;&gt;CRDT correctness&lt;&#x2F;a&gt;, we must ensure that all users end up in the same state regardless, once they have received the same messages.&lt;&#x2F;p&gt;
&lt;p&gt;For the Unique Set, it is obvious that the state of the set, as seen by a specific user, is always the set of elements for which they have received an &lt;code&gt;add&lt;&#x2F;code&gt; message but no &lt;code&gt;delete&lt;&#x2F;code&gt; messages. This holds regardless of the order in which they received concurrent messages. Thus the Unique Set is correct.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note that delivery in causal order is important—a &lt;code&gt;delete&lt;&#x2F;code&gt; operation only works if it is received after its corresponding &lt;code&gt;add&lt;&#x2F;code&gt; operation.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;&#x2F;p&gt;&lt;br &#x2F;&gt;
&lt;p&gt;We now have our first principle of CRDT design:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a name=&quot;principle-1&quot;&gt;&lt;&#x2F;a&gt;&lt;strong&gt;Principle 1. Use the Unique Set CRDT for operations that “add” or “create” a unique new thing.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Although it is simple, the Unique Set forms the basis for the rest of our CRDTs.&lt;&#x2F;p&gt;
&lt;!-- &gt; **Aside.** Traditionally, one proves CRDT correctness by proving that concurrent messages *commute*---they have the same effect regardless of delivery order ([Shapiro et al. 2011](http:&#x2F;&#x2F;dx.doi.org&#x2F;10.1007&#x2F;978-3-642-24550-3_29))---or that the final state is a function of the causally-ordered message history ([Baquero, Almeida, and Shoker 2014](https:&#x2F;&#x2F;doi.org&#x2F;10.1007&#x2F;978-3-662-43352-2_11)). However, as long as you stick to the techniques in this blog post, you won&#x27;t need explicit proofs: everything builds on the Unique Set in ways that trivially preserve CRDT correctness. For example, a deterministic view of a Unique Set is obviously still a CRDT.

&lt;p&gt;&lt;&#x2F;p&gt;&lt;br &#x2F;&gt; --&gt;
&lt;h2 id=&quot;lists&quot;&gt;Lists&lt;&#x2F;h2&gt;
&lt;p&gt;Our next CRDT is a &lt;strong&gt;list CRDT&lt;&#x2F;strong&gt;. It represents a list of elements, with &lt;code&gt;insert&lt;&#x2F;code&gt; and &lt;code&gt;delete&lt;&#x2F;code&gt; operations. For example, you can use a list CRDT of characters to store the text in a collaborative text editor, using &lt;code&gt;insert&lt;&#x2F;code&gt; to type a new character and &lt;code&gt;delete&lt;&#x2F;code&gt; for backspace.&lt;&#x2F;p&gt;
&lt;p&gt;Formally, the operations on a list CRDT are:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;insert(i, x)&lt;&#x2F;code&gt;: Inserts a new element with value &lt;code&gt;x&lt;&#x2F;code&gt; at index &lt;code&gt;i&lt;&#x2F;code&gt;, between the existing elements at indices &lt;code&gt;i&lt;&#x2F;code&gt; and &lt;code&gt;i+1&lt;&#x2F;code&gt;. All later elements (index &lt;code&gt;&amp;gt;= i+1&lt;&#x2F;code&gt;) are shifted one to the right.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;delete(i)&lt;&#x2F;code&gt;: Deletes the element at index &lt;code&gt;i&lt;&#x2F;code&gt;. All later elements (index &lt;code&gt;&amp;gt;= i+1&lt;&#x2F;code&gt;) are shifted one to the left.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;We now need to decide on the semantics, i.e., what is the result of various insert and delete operations, possibly concurrent. The fact that insertions are unique suggests using a Unique Set (&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;collaborative-data-design&#x2F;#principle-1&quot;&gt;Principle 1&lt;&#x2F;a&gt;). However, we also have to account for indices and the list order.&lt;&#x2F;p&gt;
&lt;p&gt;One approach would use indices directly: when a user calls &lt;code&gt;insert(i, x)&lt;&#x2F;code&gt;, they send &lt;code&gt;(i, x)&lt;&#x2F;code&gt; to the other users, who use &lt;code&gt;i&lt;&#x2F;code&gt; to insert &lt;code&gt;x&lt;&#x2F;code&gt; at the appropriate location. The challenge is that your intended insertion index might move around as a result of users’ inserting&#x2F;deleting in front of &lt;code&gt;i&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;collaborative-data-design&#x2F;ot.png&quot; alt=&quot;The gray cat jumped on the table.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;i&gt;Alice typed &quot; the&quot; at index 17, but concurrently, Bob typed &quot; gray&quot; in front of her. From Bob&#x27;s perspective, Alice&#x27;s insert should happen at index 22.&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;p&gt;It’s possible to work around this by “transforming” &lt;code&gt;i&lt;&#x2F;code&gt; to account for concurrent edits. That idea leads to &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Operational_transformation&quot;&gt;&lt;strong&gt;Operational Transformation (OT)&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;, the earliest-invented approach to collaborative text editing, and the one used in Google Docs and most existing apps. Unfortunately, OT algorithms are quite complicated, leading to numerous &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;core.ac.uk&#x2F;download&#x2F;pdf&#x2F;54049928.pdf&quot;&gt;flawed algorithms&lt;&#x2F;a&gt;. You can reduce complexity by using a central server to manage the document, like Google Docs does, but that precludes decentralized networks, end-to-end encryption, and server-free open-source apps.&lt;&#x2F;p&gt;
&lt;!--Several incorrect attempts at server-free OT were published before the [first correct one](https:&#x2F;&#x2F;core.ac.uk&#x2F;download&#x2F;pdf&#x2F;54049928.pdf) in 2005 (cite, check correctness via citations)---the same year the [first CRDT paper](https:&#x2F;&#x2F;hal.inria.fr&#x2F;inria-00071240&#x2F;document) was published. --&gt;
&lt;p&gt;List CRDTs use a different perspective from OT.  When you type a character in a text document, you probably don’t think of its position as “index 17” or whatever; instead, its position is at a certain place within the existing text.&lt;&#x2F;p&gt;
&lt;p&gt;“A certain place within the existing text” is vague, but at a minimum, it should be between the characters left and right of your insertion point (“on” and “ table“ in the example above)  Also, unlike an index, this intuitive position is &lt;em&gt;immutable&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;This leads to the following implementation. The list’s state is a Unique Set whose values are pairs &lt;code&gt;(p, x)&lt;&#x2F;code&gt;, where &lt;code&gt;x&lt;&#x2F;code&gt; is the actual value (e.g., a character), and &lt;code&gt;p&lt;&#x2F;code&gt; is a &lt;strong&gt;unique immutable position&lt;&#x2F;strong&gt; drawn from some abstract total order. The user-visible state of the list is the list of values &lt;code&gt;x&lt;&#x2F;code&gt; ordered by their positions &lt;code&gt;p&lt;&#x2F;code&gt;. Operations are implemented as:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;insert(i, x)&lt;&#x2F;code&gt;: The inserting user looks up the positions &lt;code&gt;pL&lt;&#x2F;code&gt;, &lt;code&gt;pR&lt;&#x2F;code&gt; of the values to the left and right (indices &lt;code&gt;i&lt;&#x2F;code&gt; and &lt;code&gt;i+1&lt;&#x2F;code&gt;), generates a unique new position &lt;code&gt;p&lt;&#x2F;code&gt; such that &lt;code&gt;pL &amp;lt; p &amp;lt; pR&lt;&#x2F;code&gt;, and calls &lt;code&gt;add((p, x))&lt;&#x2F;code&gt; on the Unique Set. &lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;delete(i)&lt;&#x2F;code&gt;: The deleting user finds the element &lt;code&gt;e&lt;&#x2F;code&gt; of the Unique Set at index &lt;code&gt;i&lt;&#x2F;code&gt;, then calls &lt;code&gt;delete(e)&lt;&#x2F;code&gt; on the Unique Set.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Of course, we need a way to create the positions &lt;code&gt;p&lt;&#x2F;code&gt;. That’s the hard part—in fact, the hardest part of any CRDT—and I don’t have space to go into it here; you should use an existing algorithm (e.g., &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;dx.doi.org&#x2F;10.1016&#x2F;j.jpdc.2010.12.006&quot;&gt;RGA&lt;&#x2F;a&gt;) or implementation (e.g., &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.yjs.dev&#x2F;api&#x2F;shared-types&#x2F;y.array&quot;&gt;Yjs’s &lt;code&gt;Y.Array&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;).  &lt;!--Generally, solutions involve a tree, sorted by the tree walk on nodes; you create a unique new position in between `pL` and `pR` by adding a new leaf somewhere between `pL` and `pR`, e.g., as a right child of `pL`.--&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The important lesson here is that we had to translate indices (the language of normal, non-CRDT lists) into unique immutable positions (what the user intuitively means when they say “insert here”).  That leads to our second principle of CRDT design:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a name=&quot;principle-2&quot;&gt;&lt;&#x2F;a&gt;&lt;strong&gt;Principle 2. Express operations in terms of user intention—what the operation means to the user, intuitively. This might differ from the closest ordinary data type operation.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;registers&quot;&gt;Registers&lt;&#x2F;h2&gt;
&lt;p&gt;Our last basic CRDT is the &lt;strong&gt;register&lt;&#x2F;strong&gt;. This is a variable that holds an arbitrary value that can be set and get. If multiple users set the value at the same time, you pick one of them arbitrarily, or perhaps average them together.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Example uses for registers:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The font size of a character in a collaborative rich-text editor.&lt;&#x2F;li&gt;
&lt;li&gt;The name of a document.&lt;&#x2F;li&gt;
&lt;li&gt;The color of a specific pixel in a collaborative whiteboard.&lt;&#x2F;li&gt;
&lt;li&gt;Basically, anything where you’re fine with users overwriting each others’ concurrent changes and you don’t want to use a more complicated CRDT.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Registers are very useful and suffice for many tasks (e.g., &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.figma.com&#x2F;blog&#x2F;how-figmas-multiplayer-technology-works&#x2F;&quot;&gt;Figma&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;hex.tech&#x2F;blog&#x2F;a-pragmatic-approach-to-live-collaboration&quot;&gt;Hex&lt;&#x2F;a&gt; use them almost exclusively).&lt;&#x2F;p&gt;
&lt;p&gt;The only operation on a register is &lt;code&gt;set(x)&lt;&#x2F;code&gt;, which sets the value to &lt;code&gt;x&lt;&#x2F;code&gt; (in the absence of concurrent operations). We can’t perform these operations literally, since if two users receive concurrent &lt;code&gt;set&lt;&#x2F;code&gt; operations in different orders, they’ll end up with different values.&lt;&#x2F;p&gt;
&lt;p&gt;However, we can &lt;em&gt;add&lt;&#x2F;em&gt; the value &lt;code&gt;x&lt;&#x2F;code&gt; to a Unique Set, following &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;collaborative-data-design&#x2F;#principle-1&quot;&gt;Principle 1&lt;&#x2F;a&gt;. The state is now a set of values instead of a single value, but we’ll address that soon. We can also delete old values each time &lt;code&gt;set(x)&lt;&#x2F;code&gt; is called, overwriting them.&lt;&#x2F;p&gt;
&lt;p&gt;Thus the implementation of &lt;code&gt;set(x)&lt;&#x2F;code&gt; becomes:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;For each element &lt;code&gt;e&lt;&#x2F;code&gt; in the Unique Set, call &lt;code&gt;delete(e)&lt;&#x2F;code&gt; on the Unique Set; then call &lt;code&gt;add(x)&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The result is that at any time, the register’s state is the set of all the most recent concurrently-set values.&lt;&#x2F;p&gt;
&lt;p&gt;Loops of the form “for each element of a collection, do something” are common in programming. We just saw a way to extend them to CRDTs: “for each element of a Unique Set, do some CRDT operation”. I call this a &lt;strong&gt;causal for-each operation&lt;&#x2F;strong&gt; because it only affects elements that are prior to the for-each operation in the &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;collaborative-data-design&#x2F;#causal-order&quot;&gt;causal order&lt;&#x2F;a&gt;. It’s useful enough that we make it our next principle of CRDT design:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a name=&quot;principle-3a&quot;&gt;&lt;&#x2F;a&gt;&lt;strong&gt;Principle 3a. For operations that do something “for each” element of a collection, one option is to use a &lt;em&gt;causal for-each operation&lt;&#x2F;em&gt; on a Unique Set (or list CRDT).&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;(Later we will expand on this with &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;collaborative-data-design&#x2F;#principle-3b&quot;&gt;Principle 3b&lt;&#x2F;a&gt;, which also concerns for-each operations.)&lt;&#x2F;p&gt;
&lt;p&gt;Returning to registers, we still need to handle the fact that our state is a set of values, instead of a specific value.&lt;&#x2F;p&gt;
&lt;p&gt;One option is to accept this as the state, and present all conflicting values to the user.  That gives the &lt;strong&gt;Multi-Value Register (MVR)&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a name=&quot;lww-register&quot;&gt;&lt;&#x2F;a&gt;Another option is to pick a value arbitrarily but deterministically.  E.g., the &lt;strong&gt;Last-Writer Wins (LWW) Register&lt;&#x2F;strong&gt; tags each value with the wall-clock time when it is set, then picks the value with the latest timestamp.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;collaborative-data-design&#x2F;pixelpusher.png&quot; alt=&quot;Grid of pixels, some conflicting (outlined in red). One conflicting pixel has been clicked on, revealing the conflicting choices.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;i&gt;In &lt;a href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;@pvh&#x2F;pixelpusher-real-time-peer-to-peer-collaboration-with-react-7c7bc8ecbf74&quot; target=&quot;_blank&quot;&gt;Pixelpusher&lt;&#x2F;a&gt;, a collaborative pixel art editor, each pixel shows one color by default (LWW Register), but you can click to pop out all conflicting colors (MVR). Image credit: Peter van Hardenberg (&lt;a href=&quot;https:&#x2F;&#x2F;miro.medium.com&#x2F;max&#x2F;270&#x2F;1*tXSBtdqf6yBCO6i77VVH1A.png&quot; target=&quot;_blank&quot;&gt;original&lt;&#x2F;a&gt;).&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In general, you can define the value getter to be an arbitrary deterministic function of the set of values.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Examples:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;If the values are colors, you can average their RGB coordinates.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;!--figure: illustration--&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a name=&quot;enable-wins-flag&quot;&gt;&lt;&#x2F;a&gt;If the values are booleans, you can choose to prefer &lt;code&gt;true&lt;&#x2F;code&gt; values, i.e., the register’s value is &lt;code&gt;true&lt;&#x2F;code&gt; if its set contains any &lt;code&gt;true&lt;&#x2F;code&gt; values. That gives the &lt;strong&gt;Enable-Wins Flag&lt;&#x2F;strong&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;composing-crdts&quot;&gt;Composing CRDTs&lt;&#x2F;h1&gt;
&lt;p&gt;We now have enough basic CRDTs to start making more complicated data structures through composition. I’ll describe three techniques: CRDT objects, CRDT-valued maps, and collections of CRDTs.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;crdt-objects&quot;&gt;CRDT Objects&lt;&#x2F;h2&gt;
&lt;p&gt;The simplest composition technique is to use multiple CRDTs side-by-side. By making them instance fields in a class, you obtain a &lt;strong&gt;CRDT Object&lt;&#x2F;strong&gt;, which is itself a CRDT (trivially correct). The power of CRDT objects comes from using standard OOP techniques, e.g., implementation hiding.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Examples:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;In a collaborative flash card app, to make individual cards editable, you could represent each card as a CRDT object with two text CRDT (list CRDT of characters) instance fields, one for the front and one for the back.&lt;&#x2F;li&gt;
&lt;li&gt;You can represent the position and size of an image in a collaborative slide editor by using separate registers for the left, top, width, and height. &lt;!--To get a complete image object, you might also add registers for border color&#x2F;size&#x2F;style, a text CRDT for the caption, a register for the image source (unless it&#x27;s immutable, in which case you can use an ordinary, non-CRDT instance field), etc.--&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;!--- Recall that we defined lists and registers in terms of the Unique Set. We can consider these as CRDT objects as well, even though they just have one instance field (the set). The object lets us delegate operations and reads to the inner set while exposing the API of a list&#x2F;register.--&gt;
&lt;p&gt;To implement a CRDT object, each time an instance field requests to broadcast a message, the CRDT object broadcasts that message tagged with the field’s name. Receivers then deliver the message to their own instance field with the same name. &lt;!--When nesting CRDT objects, this effectively creates a tree with a [basic CRDT](#basic-designs) at each leaf; each basic CRDT message is sent tagged with its path to the root.--&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;crdt-valued-map&quot;&gt;CRDT-Valued Map&lt;&#x2F;h2&gt;
&lt;p&gt;A CRDT-valued map is like a CRDT object but with potentially infinite instance fields, one for each allowed map key. Every key&#x2F;value pair is implicitly always present in the map, but values are only explicitly constructed in memory as needed, using a predefined factory method (like Apache Commons’ &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;commons.apache.org&#x2F;proper&#x2F;commons-collections&#x2F;apidocs&#x2F;org&#x2F;apache&#x2F;commons&#x2F;collections4&#x2F;map&#x2F;LazyMap.html&quot;&gt;LazyMap&lt;&#x2F;a&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Examples:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a id=&quot;add-wins-set&quot;&gt;&lt;&#x2F;a&gt;Consider a shared notes app in which users can archive notes, then restore them later. To indicate which notes are normal (not archived), we want to store them in a set. A Unique Set won’t work, since the same note can be added (restored) multiple times. Instead, you can use a CRDT-valued map whose keys are the documents and whose values are &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;collaborative-data-design&#x2F;#enable-wins-flag&quot;&gt;enable-wins flags&lt;&#x2F;a&gt;; the value of the flag for key &lt;code&gt;doc&lt;&#x2F;code&gt; indicates whether &lt;code&gt;doc&lt;&#x2F;code&gt; is in the set. This gives the &lt;strong&gt;Add-Wins Set&lt;&#x2F;strong&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;quilljs.com&#x2F;&quot;&gt;Quill&lt;&#x2F;a&gt; lets you easily display and edit rich text in a browser app. In a Quill document, each character has an &lt;code&gt;attributes&lt;&#x2F;code&gt; map, which contains arbitrary key-value pairs describing formatting (e.g., &lt;code&gt;&amp;quot;bold&amp;quot;: true&lt;&#x2F;code&gt;). You can model this using a CRDT-valued map with arbitrary keys and &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;collaborative-data-design&#x2F;#lww-register&quot;&gt;LWW register&lt;&#x2F;a&gt; values; the value of the register for key &lt;code&gt;attr&lt;&#x2F;code&gt; indicates the current value for &lt;code&gt;attr&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;A CRDT-valued map is implemented like a CRDT object: each message broadcast by a value CRDT is tagged with its serialized key. Internally, the map stores only the explicitly-constructed key-value pairs; each value is constructed using the factory method the first time it is accessed by the local user or receives a message. However, this is not visible externally—from the outside, the other values still appear present, just in their initial states. (If you want an explicit set of “present” keys, you can track them using an &lt;a href=&quot;#add-wins-set&quot;&gt;Add-Wins Set&lt;&#x2F;a&gt;.)&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;CRDT-valued maps are based on the &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.riak.com&#x2F;riak&#x2F;kv&#x2F;2.2.3&#x2F;learn&#x2F;concepts&#x2F;crdts&#x2F;index.html#maps&quot;&gt;Riak map&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;&#x2F;p&gt;&lt;br &#x2F;&gt;
&lt;h2 id=&quot;collections-of-crdts&quot;&gt;Collections of CRDTs&lt;&#x2F;h2&gt;
&lt;p&gt;Our above definition of a Unique Set implicitly assumed that the data values &lt;code&gt;x&lt;&#x2F;code&gt; were immutable and serializable (capable of being sent over the network). However, we can also make a &lt;strong&gt;Unique Set of CRDTs&lt;&#x2F;strong&gt;, whose values are dynamically-created CRDTs.&lt;&#x2F;p&gt;
&lt;p&gt;To add a new value CRDT, a user sends a unique new tag and any arguments needed to construct the value. Each recipient passes those arguments to a predefined factory method, then stores the returned CRDT in their copy of the set. When a value CRDT is deleted, it is forgotten and can no longer be used.&lt;&#x2F;p&gt;
&lt;p&gt;Note that unlike in a CRDT-valued map, values are explicitly created (with dynamic constructor arguments) and deleted—the set effectively provides collaborative &lt;code&gt;new&lt;&#x2F;code&gt; and &lt;code&gt;free&lt;&#x2F;code&gt; operations.&lt;&#x2F;p&gt;
&lt;p&gt;We can likewise make a &lt;strong&gt;list of CRDTs&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Examples:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;In a shared folder containing multiple collaborative documents, you can define your document CRDT, then use a Unique Set of document CRDTs to model the whole folder. (You can also use a CRDT-valued map from names to documents, but then documents can’t be renamed, and documents “created” concurrently with the same name will end up merged.)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;!--- In a todo-list app, you can define a &quot;todo-item CRDT&quot; with fields `text` and `done`, giving the item text and whether it is done. The whole app&#x27;s state is then a list of todo-item CRDTs.--&gt;
&lt;ul&gt;
&lt;li&gt;Continuing the Quill rich-text example from the previous section, you can model a rich-text document as a list of “rich character CRDTs”, where each “rich character CRDT” consists of an immutable (non-CRDT) character plus the &lt;code&gt;attributes&lt;&#x2F;code&gt; map CRDT. This is sufficient to build &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;compoventuals-tests.herokuapp.com&#x2F;host.html?network=ws&amp;amp;container=demos&#x2F;rich-text&#x2F;dist&#x2F;rich_text.html&quot;&gt;a simple Google Docs-style app with CRDTs&lt;&#x2F;a&gt; (&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;composablesys&#x2F;collabs&#x2F;blob&#x2F;master&#x2F;demos&#x2F;apps&#x2F;rich-text&#x2F;src&#x2F;rich_text.ts&quot;&gt;source&lt;&#x2F;a&gt;).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;using-composition&quot;&gt;Using Composition&lt;&#x2F;h2&gt;
&lt;p&gt;You can use the above composition techniques and basic CRDTs to design CRDTs for many collaborative apps. Choosing the exact structure, and how operations and user-visible state map onto that structure, is the main challenge.&lt;&#x2F;p&gt;
&lt;p&gt;A good starting point is to design an ordinary (non-CRDT) data model, using ordinary objects, collections, etc., then convert it to a CRDT version. So variables become registers, sets become Unique Sets or Add-Wins Sets, etc. You can then tweak the design as needed to accommodate extra operations or fix weird concurrent behaviors.&lt;&#x2F;p&gt;
&lt;p&gt;To accommodate as many operations as possible while preserving user intention, I recommend:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a name=&quot;principle-4&quot;&gt;&lt;&#x2F;a&gt;&lt;strong&gt;Principle 4. Independent operations (in the user’s mind) should act on independent state.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Examples:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;As mentioned earlier, you can represent the position and size of an image in a collaborative slide editor by using separate registers for the left, top, width, and height. If you wanted, you could instead use a single register whose value is a tuple (left, top, width, height), but this would violate Principle 4. Indeed, then if one user moved the image while another resized it, one of their changes would overwrite the other, instead of both moving and resizing. &lt;!--Likewise, it would be a mistake to replace (left, top, width, height) with (left, top, right, bottom) (this also violates [Principle 2](#principle-2)).--&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Again in a collaborative slide editor, you might initially model the slide list as a list of slide CRDTs. However, this provides no way for users to move slides around in the list, e.g., swap the order of two slides. You could implement a move operation using cut-and-paste, but then slide edits concurrent to a move will be lost, even though they are intuitively independent operations.&lt;br &#x2F;&gt;
&lt;a name=&quot;list-with-move&quot;&gt;&lt;&#x2F;a&gt;Following Principle 4, you should instead implement move operations by modifying some state independent of the slide itself. You can do this by replacing the &lt;em&gt;list&lt;&#x2F;em&gt; of slides with a &lt;em&gt;Unique Set&lt;&#x2F;em&gt; of objects &lt;code&gt;{ slide, positionReg }&lt;&#x2F;code&gt;, where &lt;code&gt;positionReg&lt;&#x2F;code&gt; is an LWW register indicating the position. To move a slide, you create a unique new position like in a list CRDT, then set the value of &lt;code&gt;positionReg&lt;&#x2F;code&gt; equal to that position. This construction gives the &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doi.org&#x2F;10.1145&#x2F;3380787.3393677&quot;&gt;&lt;strong&gt;list-with-move&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; CRDT.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;new-concurrent-causal-for-each-operations&quot;&gt;New: Concurrent+Causal For-Each Operations&lt;&#x2F;h1&gt;
&lt;p&gt;There’s one more trick I want to show you. Sometimes, when performing a for-each operation on a Unique Set or list CRDT (&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;collaborative-data-design&#x2F;#principle-3a&quot;&gt;Principle 3a&lt;&#x2F;a&gt;), you don’t just want to affect existing (causally prior) elements. You also want to affect &lt;em&gt;elements that are added&#x2F;inserted concurrently&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;For example:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;In a rich text editor, if one user bolds a range of text, while concurrently, another user types in the middle of the range, the latter text should also be bolded.
&lt;br &#x2F;&gt;
&lt;img src=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;collaborative-data-design&#x2F;weird_bolding.png&quot; alt=&quot;One user bolds a range of text, while concurrently, another user types “ the“ in the middle. In the final result, “ the“ is also bolded.&quot; &#x2F;&gt;
&lt;br &#x2F;&gt;
In other words, the first user’s intended operation is “for each character in the range &lt;em&gt;including ones inserted concurrently&lt;&#x2F;em&gt;, bold it”.&lt;&#x2F;li&gt;
&lt;li&gt;In a collaborative recipe editor, if one user clicks a “double the recipe” button, while concurrently, another user edits an amount, then their edit should also be doubled. Otherwise, the recipe will be out of proportion, and the meal will be ruined!&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;I call such an operation a &lt;strong&gt;concurrent+causal for-each operation&lt;&#x2F;strong&gt;. To accomodate the above examples, I propose the following addendum to &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;collaborative-data-design&#x2F;#principle-3a&quot;&gt;Principle 3a&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a name=&quot;principle-3b&quot;&gt;&lt;&#x2F;a&gt;&lt;strong&gt;Principle 3b. For operations that do something “for each” element of a collection, another option is to use a &lt;em&gt;concurrent+causal for-each operation&lt;&#x2F;em&gt; on a Unique Set (or list CRDT).&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;To implement this, the initiating user first does a causal for-each operation. They then send a message describing how to perform the operation on concurrently added elements. The receivers apply the operation to any concurrently added elements they’ve received already (and haven’t yet deleted), then store the message in a log. Later, each time they receive a new element, they check if it’s concurrent to the stored message; if so, they apply the operation.&lt;&#x2F;p&gt;
&lt;!-- &gt; **Aside.** It would be more general to split Principle 3 into &quot;causal for-each&quot; and &quot;concurrent for-each&quot; operations. However, I haven&#x27;t yet found a good use-case for a concurrent for-each operation that isn&#x27;t part of a concurrent+causal for-each.

&lt;p&gt;&lt;&#x2F;p&gt;&lt;br &#x2F;&gt; --&gt;
&lt;p&gt;Concurrent+causal for-each operations are novel as far as I’m aware. They are based on &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doi.org&#x2F;10.1145&#x2F;3408976&quot;&gt;a paper&lt;&#x2F;a&gt; I, &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;heather.miller.am&#x2F;&quot;&gt;Heather Miller&lt;&#x2F;a&gt;, and &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;christophermeiklejohn.com&#x2F;&quot;&gt;Christopher Meiklejohn&lt;&#x2F;a&gt; wrote last year, about a composition technique we call the &lt;em&gt;semidirect product&lt;&#x2F;em&gt;, which can implement them (albeit in a confusing way). &lt;!--Unfortunately, the paper doesn&#x27;t make clear what the semidirect product is doing intuitively (since we didn&#x27;t understand this ourselves!). My current opinion is that concurrent+causal for-each operations are what it&#x27;s really trying to do; the semidirect product is a special case of an optimized implementation, but written in the confusing traditional style (implementation + proof that concurrent operations commute). --&gt;&lt;&#x2F;p&gt;
&lt;!-- &gt; If you do want to use the semidirect product as an optimized implementation, be aware that it is not as general as it could be. E.g., the recipe example can be optimized, but not using the semidirect product. I&#x27;ll write up a tech report about a more general approach at some point.

&lt;p&gt;&lt;&#x2F;p&gt;&lt;br &#x2F;&gt; --&gt;
&lt;!-- Aside: dual view: controller for the for-each part plus oppositely-adjusted state. E.g. for scaling, or reversible list? Perhaps contrast with that approach---ours should be easier, in comparison to e.g. rich-text CRDT using invisible formatting characters (direct construction approach). --&gt;
&lt;!--# Summary: Principles of CRDT Design

also non-principle advice (basic designs, composition techniques)

For easy reference, here are our principles of CRDT design.

[**Principle 1.**](#principle-1) Use the Unique Set CRDT for operations that &quot;add&quot; or &quot;create&quot; a unique new thing.

[**Principle 2.**](#principle-2) Express operations in terms of user intention---what the operation means to the user, intuitively. This might differ from the closest ordinary data type operation.

**Principle 3([a](#principle-3a), [b](#principle-3b)).** For operations that do something &quot;for each&quot; element of a collection, use a *causal for-each operation* or a *concurrent+causal for-each operation* on a Unique Set (or list CRDT).

[**Principle 4.**](#principle-4) Independent operations (in the user&#x27;s mind) should act on independent state.--&gt;
&lt;h1 id=&quot;case-study-a-collaborative-spreadsheet&quot;&gt;Case Study: A Collaborative Spreadsheet&lt;&#x2F;h1&gt;
&lt;p&gt;Now let’s get practical: we’re going to design a CRDT for a collaborative spreadsheet editor (think Google Sheets).&lt;&#x2F;p&gt;
&lt;p&gt;As practice, try sketching a design yourself before reading any further. The rest of this section describes how I would do it, but don’t worry if you come up with something different—there’s no one right answer! The point of this blog post is to give you the confidence to design and tweak CRDTs like this yourself, not to dictate “the one true spreadsheet CRDT™”.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;design-walkthrough&quot;&gt;Design Walkthrough&lt;&#x2F;h2&gt;
&lt;p&gt;To start off, consider an individual cell. Fundamentally, it consists of a text string. We could make this a text (list) CRDT, but usually, you don’t edit individual cells collaboratively; instead, you type the new value of the cell, hit enter, and then its value shows up for everyone else. This suggests instead using a register, e.g., an LWW register.&lt;&#x2F;p&gt;
&lt;p&gt;Besides the text content, a cell can have properties like its font size, whether word wrap is enabled, etc. Since changing these properties are all independent operations, following &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;collaborative-data-design&#x2F;#principle-4&quot;&gt;Principle 4&lt;&#x2F;a&gt;, they should have independent state. This suggests using a CRDT object to represent the cell, with a different CRDT instance field for each property. In pseudocode (classes are implicitly &lt;a href=&quot;#crdt-objects&quot;&gt;CRDT objects&lt;&#x2F;a&gt;):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ts&quot; style=&quot;background-color:#393939;color:#dedede;&quot; class=&quot;language-ts &quot;&gt;&lt;code class=&quot;language-ts&quot; data-lang=&quot;ts&quot;&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f4a020;&quot;&gt;Cell &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  content&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d6d6d6;&quot;&gt;LWWRegister&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;  fontSize&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d6d6d6;&quot;&gt;LWWRegister&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;number&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;  wordWrap&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d6d6d6;&quot;&gt;EnableWinsFlag&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0cfa1;&quot;&gt;  &#x2F;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#87ae86;&quot;&gt; ...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The spreadsheet itself is a grid of cells. Each cell is indexed by its location (row, column), suggesting a map from locations to cells. (A 2D list could work too, but then we’d have to put rows and columns on an unequal footing, which might cause trouble later.) Thus let’s use a &lt;code&gt;Cell&lt;&#x2F;code&gt;-CRDT-valued map.&lt;&#x2F;p&gt;
&lt;p&gt;What about the map keys? It’s tempting to use conventional row-column indicators like “A1”, “B3”, etc. However, then we can’t easily insert or delete rows&#x2F;columns, since doing so renames other cells’ indicators. (We could try making a “rename” operation, but that violates &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;collaborative-data-design&#x2F;#principle-2&quot;&gt;Principle 2&lt;&#x2F;a&gt;, since it does not match the user’s original intention: inserting&#x2F;deleting a different row&#x2F;column.)&lt;&#x2F;p&gt;
&lt;p&gt;Instead, let’s identify cell locations using pairs (row, column), where “row” means “the line of cells horizontally adjacent to this cell”, independent of that row’s literal location (1, 2, etc.), and likewise for “column”. That is, we create an opaque &lt;code&gt;Row&lt;&#x2F;code&gt; object to represent each row, and likewise for columns, then use pairs &lt;code&gt;(Row, Column)&lt;&#x2F;code&gt; for our map keys.&lt;&#x2F;p&gt;
&lt;p&gt;The word “create” suggests using Unique Sets (&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;collaborative-data-design&#x2F;#principle-1&quot;&gt;Principle 1&lt;&#x2F;a&gt;), although since the rows and columns are ordered, we actually want list CRDTs. Hence our app state looks like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ts&quot; style=&quot;background-color:#393939;color:#dedede;&quot; class=&quot;language-ts &quot;&gt;&lt;code class=&quot;language-ts&quot; data-lang=&quot;ts&quot;&gt;&lt;span&gt;rows: ListCRDT&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;Row&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;columns: ListCRDT&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;Column&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;cells: CRDTValuedMap&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#78cecc80;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span&gt;row: Row, column: Column&lt;&#x2F;span&gt;&lt;span style=&quot;color:#78cecc80;&quot;&gt;]&lt;&#x2F;span&gt;&lt;span&gt;, Cell&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now you can insert or delete rows and columns by calling the appropriate operations on &lt;code&gt;columns&lt;&#x2F;code&gt; and &lt;code&gt;rows&lt;&#x2F;code&gt;, without affecting the &lt;code&gt;cells&lt;&#x2F;code&gt; map at all. (Due to the lazy nature of the map, we don’t have to explicitly create cells to fill a new row or column; they implicitly already exist.)&lt;&#x2F;p&gt;
&lt;p&gt;Speaking of rows and columns, there’s more we can do here. For example, rows have editable properties like their height, whether they are visible, etc. These properties are independent, so they should have independent states (&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;collaborative-data-design&#x2F;#principle-4&quot;&gt;Principle 4&lt;&#x2F;a&gt;). This suggests making &lt;code&gt;Row&lt;&#x2F;code&gt; into a CRDT object:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ts&quot; style=&quot;background-color:#393939;color:#dedede;&quot; class=&quot;language-ts &quot;&gt;&lt;code class=&quot;language-ts&quot; data-lang=&quot;ts&quot;&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f4a020;&quot;&gt;Row &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  height&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d6d6d6;&quot;&gt;LWWRegister&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;number&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;  isVisible&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d6d6d6;&quot;&gt;EnableWinsFlag&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0cfa1;&quot;&gt;  &#x2F;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#87ae86;&quot;&gt; ...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Also, we want to be able to move rows and columns around. We already described how to do this using a &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;collaborative-data-design&#x2F;#list-with-move&quot;&gt;list-with-move&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ts&quot; style=&quot;background-color:#393939;color:#dedede;&quot; class=&quot;language-ts &quot;&gt;&lt;code class=&quot;language-ts&quot; data-lang=&quot;ts&quot;&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f4a020;&quot;&gt;ListWithMove&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d6d6d6;&quot;&gt;C&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;  state&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d6d6d6;&quot;&gt;UniqueSet&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;{value&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d6d6d6;&quot;&gt;C&lt;&#x2F;span&gt;&lt;span&gt;, positionReg&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d6d6d6;&quot;&gt;LWWRegister&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d6d6d6;&quot;&gt;ListCRDTPosition&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;}&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;rows: ListWithMove&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;Row&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;columns: ListWithMove&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;Column&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Next, we can also perform operations on every cell in a row, like changing the font size of every cell. For each such operation, we have three options:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Use a causal for-each operation (&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;collaborative-data-design&#x2F;#principle-3a&quot;&gt;Principle 3a&lt;&#x2F;a&gt;). This will affect all current cells in the row, but not any cells that are created concurrently (when a new column is inserted). E.g., a “clear” operation that sets every cell’s value to &lt;code&gt;&amp;quot;&amp;quot;&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Use a concurrent+causal for-each operation (&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;collaborative-data-design&#x2F;#principle-3b&quot;&gt;Principle 3b&lt;&#x2F;a&gt;). This will affect all current cells in the row &lt;em&gt;and&lt;&#x2F;em&gt; any created concurrently. E.g., changing the font size of a whole row.&lt;&#x2F;li&gt;
&lt;li&gt;Use an independent state that affects the row itself, not the cells (&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;collaborative-data-design&#x2F;#principle-4&quot;&gt;Principle 4&lt;&#x2F;a&gt;). E.g., our usage of &lt;code&gt;Row.height&lt;&#x2F;code&gt; for the height of a row.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;!-- &gt; **Aside.** Note that the for-each loops loop over every cell in the row, even blank cells that have never been used. This has the downside of making all those cells explicitly exist in the CRDT-valued map, increasing memory usage. We tolerate this since our focus is to pin down the semantics, not give an efficient implementation. Once the semantics are pinned down, though, you are free to optimize the implementation.

&lt;p&gt;&lt;&#x2F;p&gt;&lt;br &#x2F;&gt; --&gt;
&lt;!--Lastly, let&#x27;s take another look at cell contents. Before I said it was just a string, but it&#x27;s more interesting than that: cells can reference other cells in formulas, e.g., &quot;= A2 + B3&quot;. If a column is inserted in front of column A, these references should update to &quot;= B2 + C3&quot;, since they intuitively describe a *cell*, not the indicators themselves. So, we should store them using a pair `[row: Row, column: Column]`, like the map keys. The content then becomes an array of tokens, which can be literal strings or cell references:
```ts
class Cell {
  content: LWWRegister&lt;(string | [row: Row, column: Column])[]&gt;;
  fontSize: LWWRegister&lt;number&gt;;
  wordWrap: EnableWinsFlag;
  &#x2F;&#x2F; ...
}
```--&gt;
&lt;h2 id=&quot;finished-design&quot;&gt;Finished Design&lt;&#x2F;h2&gt;
&lt;p&gt;In summary, the state of our spreadsheet is as follows.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ts&quot; style=&quot;background-color:#393939;color:#dedede;&quot; class=&quot;language-ts &quot;&gt;&lt;code class=&quot;language-ts&quot; data-lang=&quot;ts&quot;&gt;&lt;span style=&quot;color:#a0cfa1;&quot;&gt;&#x2F;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#87ae86;&quot;&gt; ---- CRDT Objects ----
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f4a020;&quot;&gt;Row &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  height&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d6d6d6;&quot;&gt;LWWRegister&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;number&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;  isVisible&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d6d6d6;&quot;&gt;EnableWinsFlag&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0cfa1;&quot;&gt;  &#x2F;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#87ae86;&quot;&gt; ...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f4a020;&quot;&gt;Column &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  width&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d6d6d6;&quot;&gt;LWWRegister&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;number&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;  isVisible&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d6d6d6;&quot;&gt;EnableWinsFlag&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0cfa1;&quot;&gt;  &#x2F;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#87ae86;&quot;&gt; ...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f4a020;&quot;&gt;Cell &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  content&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d6d6d6;&quot;&gt;LWWRegister&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;  fontSize&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d6d6d6;&quot;&gt;LWWRegister&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;number&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;  wordWrap&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d6d6d6;&quot;&gt;EnableWinsFlag&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0cfa1;&quot;&gt;  &#x2F;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#87ae86;&quot;&gt; ...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f4a020;&quot;&gt;ListWithMove&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d6d6d6;&quot;&gt;C&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;  state&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d6d6d6;&quot;&gt;UniqueSet&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;{value&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d6d6d6;&quot;&gt;C&lt;&#x2F;span&gt;&lt;span&gt;, positionReg&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d6d6d6;&quot;&gt;LWWRegister&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d6d6d6;&quot;&gt;ListCRDTPosition&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;}&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0cfa1;&quot;&gt;&#x2F;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#87ae86;&quot;&gt; ---- App state ----
&lt;&#x2F;span&gt;&lt;span&gt;rows: ListWithMove&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;Row&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;columns: ListWithMove&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;Column&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;cells: CRDTValuedMap&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#78cecc80;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span&gt;row: Row, column: Column&lt;&#x2F;span&gt;&lt;span style=&quot;color:#78cecc80;&quot;&gt;]&lt;&#x2F;span&gt;&lt;span&gt;, Cell&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ececec;&quot;&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that I never explicitly mentioned &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2023&#x2F;collaborative-data-design&#x2F;#correctness&quot;&gt;CRDT correctness&lt;&#x2F;a&gt;—the claim that all users see the same document state after receiving the same messages. Because we assembled the design from existing CRDTs using composition techniques that preserve CRDT correctness, it is trivially correct. Plus, it should be straightforward to reason out what would happen in various concurrency scenarios.&lt;&#x2F;p&gt;
&lt;p&gt;As exercises, here are some further tweaks you can make to this design, phrased as user requests:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;“I’d like to have multiple sheets in the same document, accessible by tabs at the bottom of the screen, like in Excel.” &lt;em&gt;Hint (highlight to reveal): &lt;font color=&quot;white&quot;&gt;Use a list of CRDTs.&lt;&#x2F;font&gt;&lt;&#x2F;em&gt;&lt;&#x2F;li&gt;
&lt;li&gt;“I’ve noticed that if I change the font size of a cell, while at the same time someone else changes the font size for the whole row, sometimes their change overwrites mine. I’d rather keep my change, since it’s more specific.” &lt;em&gt;Hint: &lt;font color=&quot;white&quot;&gt;Use a register with a custom getter.&lt;&#x2F;font&gt;&lt;&#x2F;em&gt;&lt;&#x2F;li&gt;
&lt;li&gt;“I want to reference other cells in formulas, e.g., &lt;code&gt;= A2 + B3&lt;&#x2F;code&gt;. Later, if &lt;code&gt;B3&lt;&#x2F;code&gt; moves to &lt;code&gt;C3&lt;&#x2F;code&gt;, its references should update too.” &lt;em&gt;Hint: &lt;font color=&quot;white&quot;&gt;Store the reference as something immutable.&lt;&#x2F;font&gt;&lt;&#x2F;em&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h1&gt;
&lt;p&gt;I hope you’ve gained an understanding of how CRDTs work, plus perhaps a desire to apply them in your own apps. We covered a lot:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Traditional CRDTs:&lt;&#x2F;strong&gt; Unique Set, List&#x2F;Text, LWW Register, Enable-Wins Flag, Add-Wins Set, CRDT-Valued Map, and List-with-Move.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Novel Operations&lt;&#x2F;strong&gt;: Concurrent+causal for-each operations on a Unique Set or list.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Whole Apps&lt;&#x2F;strong&gt;: Spreadsheet, rich text, and pieces of various other apps.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;For more info, &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;crdt.tech&#x2F;&quot;&gt;crdt.tech&lt;&#x2F;a&gt; collects most CRDT resources in one place.&lt;&#x2F;p&gt;
&lt;p&gt;I’ve also started putting these ideas into practice in a library, &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;@collabs&#x2F;collabs&quot;&gt;Collabs&lt;&#x2F;a&gt;. You can learn more about Collabs, and see how open-source collaborative apps might work in practice, in &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=Exr0iY_D-vw&quot;&gt;my Strange Loop talk&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;acknowledgments&quot;&gt;Acknowledgments&lt;&#x2F;h2&gt;
&lt;p&gt;I thank Justine Sherry, Jonathan Aldrich, and Pratik Fegade for reviewing this post and giving helpful feedback. I also thank Heather Miller, Ria Pradeep, and Benito Geordie for numerous CRDT design discussions that led to these ideas.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Time-Traveling Simulation for Security</title>
		<published>2022-12-06T00:00:00+00:00</published>
		<updated>2022-12-06T00:00:00+00:00</updated>
		<link href="https://www.cs.cmu.edu/~csd-phd-blog/2022/timetraveling-simulation/" type="text/html"/>
		<id>https://www.cs.cmu.edu/~csd-phd-blog/2022/timetraveling-simulation/</id>
		<content type="html">&lt;p&gt;Blockchains are a powerful technology which allow decentralized agreement with an immutable history. Since transactions can be added, but not removed, blockchains allow distributed banking as a trustworthy alternative to central banking.
A vast amount of cryptographic research on constructing secure blockchains has led to them being trusted to secure currency worth &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;coinmarketcap.com&#x2F;currencies&#x2F;bitcoin&#x2F;&quot;&gt;hundreds of billions&lt;&#x2F;a&gt; of US dollars.&lt;&#x2F;p&gt;
&lt;p&gt;Recently, blockchains have received attention as an enabler of cryptography rather than just a goal of it. Several works have used blockchains to build a variety of cryptographic tools, including &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;link.springer.com&#x2F;chapter&#x2F;10.1007&#x2F;978-3-319-70500-2_18&quot;&gt;one-time programs&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;link.springer.com&#x2F;article&#x2F;10.1007&#x2F;s10623-018-0461-x&quot;&gt;time-lock encryption&lt;&#x2F;a&gt;. These tools are impossible to construct without special assumptions. These works model cryptographic protocols as occurring in a world where a blockchain protocol is being executed. The cryptographic protocol is therefore able to perform actions such as reading the state of the blockchain or posting transactions to it. The exact security definitions vary significantly between these approaches.&lt;&#x2F;p&gt;
&lt;p&gt;Time-traveling simulation is a new security model for protocols executed in the presence of a blockchain. Intuitively, time-traveling simulation captures the philosophy that “any extra information an adversary learns in a real execution could have been learned on their own by waiting for the natural passage of time”. Since a blockchain will naturally progress no matter what the adversary does, it provides the notion of time needed to formalize this philosophy. &lt;&#x2F;p&gt;
&lt;p&gt;Time-traveling simulation bypasses many impossibility results, while the same time yielding an arguably stronger notion of security than prior blockchain based works. For example, time-traveling simulation enables zero knowledge arguments and secure two-party computation in three messages. It is currently not known how to construct these protocols in three messages with the standard notion of security, without relying on new hardness assumptions. &lt;&#x2F;p&gt;
&lt;p&gt;In this article, we will dive into the &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2022&#x2F;timetraveling-simulation&#x2F;#the-philosophy-of-security&quot;&gt;definition of time-traveling simulation&lt;&#x2F;a&gt; and how it &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2022&#x2F;timetraveling-simulation&#x2F;#comparison-to-other-relaxed-security-notions&quot;&gt;compares to other security notions&lt;&#x2F;a&gt;. Additionally, we will explore how it can be used to bypass impossibility results for &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2022&#x2F;timetraveling-simulation&#x2F;#application-time-traveling-simulators-for-zero-knowledge&quot;&gt;three message zero knowledge arguments&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;the-philosophy-of-security&quot;&gt;The Philosophy of Security&lt;&#x2F;h1&gt;
&lt;p&gt;In modern cryptography, the central philosophy for security is “any extra information an adversary learns in a real execution could have been learned on their own”. In other words, the adversary learns nothing from participating in the real execution, beyond what they were supposed to learn. For example, in a zero knowledge argument, the adversary only learns that a given NP statement is true, without learning a witness for &lt;em&gt;why&lt;&#x2F;em&gt; it is true. This particular notion is actually too strong for many applications, so cryptographers usually consider weakenings of this philosophy with the same spirit. The most common weakening is “any extra information an adversary learns in a real execution could have been learned on their own using a little extra computation”.&lt;&#x2F;p&gt;
&lt;p&gt;These philosophies are captured formally by a mathematical object called a simulator. A simulator’s job is to reproduce whatever knowledge the adversarial verifier would have learned in a real execution of the protocol. However, it must do this without access to the real prover; it only has the adversary’s code. If such a simulator exists, then the adversary could run the simulator on its own. By doing so, it learns everything it would have learned in a real interaction, without interacting with the real prover.&lt;&#x2F;p&gt;
&lt;p&gt;More formally, a simulator (for zero knowledge) takes as input the adversary’s code and the statement being proven, then outputs a transcript of a protocol execution, along with the adversary’s internal state. In the real world, without loss of generality, the adversary outputs the transcript of the protocol execution along with its own internal state. This is before any post-processing. A protocol is zero knowledge if there exists a simulator whose output distribution is indistinguishable from the output distribution of the adversary in the real world. This guarantees that whatever information can be derived from the output of the adversary in the real world is indistinguishable from what can be derived from the simulator. Thus, by running the simulator, the adversary can learn whatever it would have learned in a real execution.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;.&#x2F;simulator-paradigm.png&quot; alt=&quot;In the real world, the adversary interacts with someone who knows a secret. In the ideal world, the simulator does not know the secret, and may internally interact with the adversary to produce a realistic looking view.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;div style=&quot;margin-left: 50px; margin-right:  40px;&quot;&gt;&lt;b&gt;Figure:&lt;&#x2F;b&gt; The simulator imagines an interaction between the adversarial verifier and an imaginary prover. This interaction is indistinguishable from a real interaction, from the adversary&#x27;s point of view.&lt;&#x2F;div&gt;
&lt;p&gt;In some sense, a simulator can be viewed as a method for the adversary to fool itself into accepting the truth of a statement without knowing a witness. It is important that the adversary can only fool itself - an adversarial prover should not be able to fool an honest verifier. This requires some asymmetry between the simulator and a real-world adversary. One of the most basic forms of asymmetry is knowledge of the adversary’s code, which allows the simulator to internally run and interact with the adversary. Any adversary knows its own code, but it certainly shouldn’t know anyone else’s!&lt;&#x2F;p&gt;
&lt;p&gt;To relax the security philosophy, the simulator is provided with some form of additional power which represents additional asymmetry between the simulator and a real-world adversary. The more asymmetry, the easier it is to create a simulator without allowing an adversarial prover to convince an honest verifier of a false statement. In general, providing more extra power to the simulator corresponds to a weaker security notion. The adversary can learn whatever the simulator can learn, so a more powerful simulator corresponds to an adversary which can learn more information. The table below compares common relaxations to time-traveling simulation in terms of their philosophies and what extra power is given to the simulator.&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;Security Notion&lt;&#x2F;th&gt;&lt;th align=&quot;left&quot;&gt;Philosophy: &lt;br&#x2F;&gt;“Any extra information an adversary learns in a real execution could have been learned on their own…”&lt;&#x2F;th&gt;&lt;th align=&quot;left&quot;&gt;Simulator&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;Expected PPT (Standard)&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;in expected PPT.&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;Runs in expected poly time.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;Superpolynomial Simulation&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;in superpolynomial time.&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;Runs in superpolynomial time.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;Common Reference String (CRS)&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;using the CRS trapdoor.&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;Can choose the CRS used by both parties. This allows adding a trapdoor to it.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;Majority Simulation&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;if they controlled the blockchain.&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;Controls the majority of blockchain participants.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;Time-Traveling Simulation&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;shortly into the future.&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;Can look into the future.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h2 id=&quot;security-implications-of-time-traveling-simulation&quot;&gt;Security Implications of Time-Traveling Simulation&lt;&#x2F;h2&gt;
&lt;p&gt;As mentioned previously, time-traveling simulation captures the philosophy that “any extra information an adversary learns in a real execution could have been learned on their own by waiting for the natural passage of time”. This is realized by allowing the simulator to see a potential future state of the blockchain, which consists of a valid extension by \( F \) blocks. Since such a state will become public information after a short time regardless of what the adversary does, this only reveals information that would have anyway been revealed with the natural passage of time.&lt;&#x2F;p&gt;
&lt;p&gt;Simulator access to a future state allows time-traveling simulation to bypass impossibility results for expected probabilistic polynomial time simulation, which is considered the standard notion of simulation. 
A common blockchain property is that a computationally-bounded adversary cannot compute a valid extension by \( F \) blocks faster than the honest parties can extend the chain by, say, \( \sqrt{F} \) blocks. Therefore access to a future state represents additional asymmetry between the simulator and a real adversary.
This additional asymmetry makes it possible for the simulator to “imagine” the adversary’s real-world view in protocols where it otherwise would not have been able to, bypassing the impossibility results for expected PPT simulation (aka standard simulation).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;.&#x2F;future-state.png&quot; alt=&quot;A blockchain comes equipped with a validity predicate which allows checking whether a state is a valid extension of a previous state. A future state is a valid extension of the current state.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;div style=&quot;margin-left: 50px; margin-right:  40px;&quot;&gt;&lt;b&gt;Figure:&lt;&#x2F;b&gt; A blockchain comes equipped with a validity predicate which allows checking whether a state is a valid extension of a previous state. A future state is a valid extension of the current state.&lt;&#x2F;div&gt;
&lt;p&gt;Time-traveling simulation is almost as meaningful as standard simulation when it comes to long-term knowledge. 
For example, imagine the task of constructing multi-party computation protocols which are secure against malicious adversaries. A malicious adversary may deviate from the protocol arbitrarily. Another kind of adversary is a semi-honest adversary, which follows the protocol, but may attempt to analyze the transcript later. It is much easier to construct multi-party computation protocols which are secure against semi-honest adversaries. A multi-party computation protocol with semi-honest security can be transformed to have malicious security by using the &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;28395.28420&quot;&gt;GMW compiler&lt;&#x2F;a&gt;. To do the transformation, each party proves the statement “I executed the protocol honestly using some input” in zero knowledge. This convinces the other parties that they did indeed behave honestly, but does not reveal an explanation for the honest behavior. Crucially, this means that the zero knowledge argument preserves the privacy of each party’s inputs. Now consider using a zero knowledge argument with time-traveling simulation to instantiate the GMW compiler. Since honest behavior in a non-time-sensitive protocol does not depend on the passage of time, this does not reveal an explanation for the honest behavior. In particular, the inputs of each party are still private.&lt;&#x2F;p&gt;
&lt;p&gt;In contrast, time-traveling simulation may not be suitable for applications which are inherently time sensitive. For example, consider using a zero knowledge argument with time-traveling simulation to prove knowledge of a solution to a time-lock puzzle. A time-lock puzzle can be solved in some set amount of time (for example, a day), but cannot be solved faster than that. Since the simulator has access to a future state from after the time-lock puzzle can be solved, in this situation time-traveling simulation may allow the solution to be leaked today instead of tomorrow.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;comparison-to-other-relaxed-security-notions&quot;&gt;Comparison to Other Relaxed Security Notions&lt;&#x2F;h3&gt;
&lt;p&gt;Several of these security notions also bypass impossibility results for expected PPT simulation. One way to further compare security notions is comparing how powerful their simulators are. As mentioned previously, a security notion which allows the simulator more power may allow the adversary to learn more information. In many cases, time-traveling simulation gives the simulator less power than other simulation notions, so it corresponds to better security guarantees.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Super-Polynomial Time Simulation.&lt;&#x2F;strong&gt; Time-traveling simulation can be seen as a very restricted form of super-polynomial time or angel-based simulation. Angel-based simulation is similar to super-polynomial time simulation, but restricts the extra computational power to performing one specific task. For example, an angel may break the security of a particular commitment scheme. Both super-polynomial time and angel-based simulators are very powerful and can bypass many impossibility results. However, it can be challenging to argue that the simulator cannot break the security of other primitives. These primitives may only have security against polynomial-time adversaries, so they can be broken using any super-polynomial time computation. Continuing the example of commitments, if the simulator could also break a second commitment scheme, then it cannot guarantee that the second scheme is secure against the real adversary.&lt;&#x2F;p&gt;
&lt;p&gt;In the case of time-traveling simulation, the angel’s task is to quickly compute a potential future state of the blockchain exactly once. It is worth emphasizing the special nature of this task: it is computing something which will be publicly available information in just a short while. As such, whatever security a time-traveling simulator breaks would have been broken soon anyway. For example, regardless of which commitment scheme the parties use, the commitment to their input can never be broken by a time-traveling simulator.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Common Reference String.&lt;&#x2F;strong&gt; Another good point of comparison is the common reference string model, since the blockchain state represents a pre-agreed-upon string. One important difference between a CRS and the way time-traveling simulation uses a blockchain is that the format of a common reference string often depends on the exact protocol being run (for example, a zero knowledge proof or a secure computation protocol). However, a blockchain does not adapt to auxiliary protocols. A second, and perhaps more important difference, is the notion of control. In the CRS model, the simulator has full control over the CRS. A time-traveling simulator, on the other hand, has no actual control over the blockchain, only some extra information about it. This means that a time-traveling simulator can learn less information than a simulator with full control over the blockchain. Since an adversary might be able to learn whatever a simulator can, the security notion is stronger if the simulator only has extra information, instead of full control.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Majority Simulation.&lt;&#x2F;strong&gt; This difference in control over versus knowledge about the blockchain is especially illustrated when comparing time-traveling simulation to majority simulation. Majority simulation is another relaxed security model for protocols executed alongside a blockchain. In majority simulation, the simulator is allowed control over all honest parties which are participating in the progression of the blockchain. Since blockchain security requires the honest parties to be in control of the blockchain, this allows a majority simulator to perform tasks such as pausing or even rewinding the blockchain. Such capabilities should even allow computation of future states of the blockchain, which is the only power given to a time-traveling simulator. &lt;&#x2F;p&gt;
&lt;p&gt;In particular, majority simulation can introduce security vulnerabilities when running two different protocols using the same blockchain. Since the two protocols rely on the security of the blockchain, a simulator with full control over the blockchain can easily break the security of either protocol. Therefore majority simulation does not guarantee that a party which participates in one protocol cannot violate the security of the other protocol. Although it is nontrivial to see, time-traveling simulation can allow multiple protocols to use the same blockchain at the same time if they are careful. &lt;&#x2F;p&gt;
&lt;h1 id=&quot;application-time-traveling-simulators-for-zero-knowledge&quot;&gt;Application: Time-Traveling Simulators for Zero Knowledge&lt;&#x2F;h1&gt;
&lt;p&gt;Time-traveling simulators allow a particularly simple construction for zero knowledge arguments with three messages. As mentioned previously, constructing zero knowledge arguments with three messages is very difficult under the standard notion of security (expected PPT simulation). &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;iacr.org&#x2F;archive&#x2F;tcc2008&#x2F;49480068&#x2F;49480068.pdf&quot;&gt;Prior work&lt;&#x2F;a&gt; shows that any security proof for a three message zero knowledge argument must make non-blackbox use of the adversary’s code. However, non-blackbox techniques are notoriously difficult. The only &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;3188745.3188870&quot;&gt;current construction&lt;&#x2F;a&gt; for three message zero knowledge relies on new cryptographic hardness assumptions.&lt;&#x2F;p&gt;
&lt;p&gt;A zero knowledge argument is, first and foremost, an argument. A prover attempts to convince a verifier that an NP statement \( x\) is in an NP language \( L\). The prover should not be able to convince the verifier of a false statement; this property is called soundness. The zero knowledge property requires that the argument does allow the verifier to learn anything about the witness for \( x \in L\). This is formalized using the simulator definition discussed &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2022&#x2F;timetraveling-simulation&#x2F;#the-philosophy-of-security&quot;&gt;above&lt;&#x2F;a&gt;. As a reminder, the simulator must approximate a real view of the argument, except it does not have access to the real prover. In the standard notion of simulation, the simulator is an expected PPT algorithm.&lt;&#x2F;p&gt;
&lt;p&gt;In time-traveling simulation for zero knowledge arguments, the simulator additionally receives a valid extension of the blockchain by \(F\) blocks. Then it must produce the adversary’s view. If left alone, the blockchain will generate extensions of itself which are independent of the statement \(x\) or its witnesses. Therefore the future state which the simulator receives is effectively harmless and contains no information about the witness beyond what is naturally leaked with the passage of time.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;.&#x2F;timetraveling-simulator-zk.png&quot; alt=&quot;In a real zero knowledge argument execution, the prover knows the witness. A time-traveling simulator for zero knowledge receives a future state of the blockchain instead of the witness.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;div style=&quot;margin-left: 50px; margin-right:  40px;&quot;&gt;&lt;b&gt;Figure:&lt;&#x2F;b&gt; In a real zero knowledge argument execution, the prover knows the witness. A time-traveling simulator for zero knowledge receives a future state of the blockchain instead of the witness.&lt;&#x2F;div&gt;
&lt;h2 id=&quot;zero-knowledge-in-three-rounds&quot;&gt;Zero Knowledge in Three Rounds&lt;&#x2F;h2&gt;
&lt;p&gt;The construction of a three round zero knowledge argument uses a three round witness indistinguishable proof of knowledge (WIPoK). In a WIPoK, a prover convinces a verifier that they “know” a witness for some NP statement. The witness indistinguishability property guarantees that if there are two possible witnesses for the statement, then the verifier cannot tell which one the prover knows. This is a weaker security guarantee than zero knowledge, so it is possible to construct a WIPoK in just three rounds (even without assuming special setup like a CRS or a blockchain).&lt;&#x2F;p&gt;
&lt;p&gt;The construction is as follows. To prove the truth of an NP statement \( x\), the prover and verifier engage in a WIPoK for the statement “I know a witness for \( x\) or I know a blockchain state \(F\) blocks ahead of the current state”. Showing zero knowledge requires constructing a time-traveling simulator, which is initialized with a future state. The simulator acts as a prover in the WIPoK with the adversary, using the future state as its witness. Witness indistinguishability guarantees that an execution using the future state as a witness is indistinguishable from an execution using a witness for \(x \). The latter case is exactly what occurs in a real execution, so the simulator’s output is indistinguishable from a real execution.&lt;&#x2F;p&gt;
&lt;p&gt;To show soundness, observe that any adversarial prover must know a witness for the statement. This is either a witness for \( x \) or it is a future state of the blockchain. Since a real adversary cannot possibly know a future state of the blockchain without violating the blockchain’s security, it must know a witness for \( x\). The full argument for soundness requires some additional care in order to use the proof of knowledge property, since the WIPoK is composed in parallel with a blockchain protocol and many security properties break down during parallel composition. See the &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;eprint.iacr.org&#x2F;2022&#x2F;035.pdf&quot;&gt;full paper&lt;&#x2F;a&gt; for details.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Kangaroo: Caching billions of tiny objects on flash</title>
		<published>2022-05-02T00:00:00+00:00</published>
		<updated>2022-05-02T00:00:00+00:00</updated>
		<link href="https://www.cs.cmu.edu/~csd-phd-blog/2022/kangaroo/" type="text/html"/>
		<id>https://www.cs.cmu.edu/~csd-phd-blog/2022/kangaroo/</id>
		<content type="html">&lt;p&gt;Many social-media and Internet-of-Things services have large numbers of tiny objects, each a few hundred bytes or less.
For example, edges in Facebook’s social graph, which are needed to connect friends, posts, and images among other content, &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;conference&#x2F;osdi20&#x2F;presentation&#x2F;berg&quot;&gt;average under 100 bytes&lt;&#x2F;a&gt;.
Twitter tweets &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;techcrunch.com&#x2F;2018&#x2F;10&#x2F;30&#x2F;twitters-doubling-of-character-count-from-140-to-280-had-little-impact-on-length-of-tweets&#x2F;&quot;&gt;average 33 bytes&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;These objects are permanently stored in large-scale databases, object stores, or filesystems.
On top of this permanent storage layer,
popular objects are cached.
Caches allow quicker access to the popular objects and lower load on the storage layer.
A cache’s effectiveness in these systems is primarily measured by the ratio of
the number of requests it can fulfill to the total number of requests, or its miss ratio.
As the quantity of data scales, caching layers need to also scale to maintain
their miss ratio, otherwise end-user experiences such as website load times suffer.
However, scaling traditional DRAM caches is prohibitively expensive.
Instead, companies are increasingly using flash
to build larger caches since flash is 100x cheaper per bit than DRAM.&lt;&#x2F;p&gt;
&lt;p&gt;Unfortunately, prior flash caches fall short of efficiently caching tiny objects,
a challenging workload for flash caching.
Prior approaches either increase the cache’s cost by having a high indexing overhead
that requires excessive DRAM capacity to support
or writing too much and rapidly wearing out flash devices.
Thus, with prior designs, flash caching fails to live up to its potential as a cheap, large cache for tiny objects.&lt;&#x2F;p&gt;
&lt;p&gt;Kangaroo is a new flash cache optimized for tiny objects.
It enables efficient caching of tiny objects by requiring only a small
DRAM overhead and a small write overhead for cached objects.
In addition, Kangaroo introduces a new cache eviction policy that uses
minimal DRAM overhead while significantly reducing cache
misses, further reducing load on the storage layer.
Kangaroo is &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;saramcallister&#x2F;Kangaroo&quot;&gt;open source&lt;&#x2F;a&gt;
and implemented in &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;cachelib.org&#x2F;&quot;&gt;CacheLib&lt;&#x2F;a&gt;,
Facebook’s open-source caching engine.&lt;&#x2F;p&gt;
&lt;p&gt;Kangaroo lowers the number of cache misses by 29% over state-of-the-art
flash caching systems under production DRAM and flash constraints on traces
from production social-graph caching workloads at Facebook and Twitter.
These results are also corroborated with a
test deployment of Kangaroo in a shadow production setup at Facebook.
This research was published at &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;3477132.3483568&quot;&gt;SOSP 2021&lt;&#x2F;a&gt; where it won the &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;sosp2021.mpi-sws.org&#x2F;awards.html&quot;&gt;Best Paper Award&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;prior-approaches-too-much-dram-or-too-many-writes&quot;&gt;Prior approaches: Too much DRAM or too many writes&lt;&#x2F;h2&gt;
&lt;p&gt;Prior flash caches fall into two main categories: &lt;em&gt;log-structured caches&lt;&#x2F;em&gt; and &lt;em&gt;set-associative caches&lt;&#x2F;em&gt;. Neither of these flash caches can efficiently support tiny objects
because, as explained further below, log-structured caches require prohibitively large
DRAM overheads whereas set-associative caches require prohibitively large write overheads.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;log-structured-caches-too-much-dram&quot;&gt;Log-structured caches: Too much DRAM&lt;&#x2F;h3&gt;
&lt;p&gt;Log-structured caches use flash as a circular log.
During an insert, objects are first buffered in DRAM and then written to flash
sequentially in large groups.
Since objects can end up anywhere on flash, the cache maintains an in-memory index to find objects.&lt;&#x2F;p&gt;
&lt;p&gt;The advantage of a log-structured design is that it has a low &lt;em&gt;write amplification&lt;&#x2F;em&gt;.
Write amplification is the number of bytes written to flash divided by
the cumulative object size, and it represents the write overhead of a cache.
A write amplification of one is optimal, though often it is higher.
For example, writing a 100-byte object to flash by itself has a write amplification
of ~40x since flash has a minimum write granularity of 4KB.
Flash has a limited number of times it can be rewritten before becoming unusable.
Therefore, this significant write amplification wears out the flash device quickly,
requiring the device to be replaced quickly.
Since a log-structured cache buffers objects in DRAM,
it can wait until it has enough objects to write them to flash efficiently.
Thus, log-structured caches have close-to-optimal write amplification.&lt;&#x2F;p&gt;
&lt;p&gt;However, log-structured caches have a large DRAM overhead when caching tiny objects.
They have to keep an index entry for every on-flash object to enable
finding those objects again on a lookup request.
Since objects are around 100 bytes, there would be roughly 20 billion of them
in a 2 TB flash cache.
Even with the &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;conference&#x2F;nsdi19&#x2F;presentation&#x2F;eisenman&quot;&gt;lowest overhead in the literature at 30 bits&#x2F;object&lt;&#x2F;a&gt;,
the cache would require 75 GB just to the index objects on flash.
Since caching on flash is meant to lower costs through removing DRAM,
log-structured caches are inefficient for tiny objects because they require too much DRAM.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;set-associative-caches-too-many-writes&quot;&gt;Set-associative caches: Too many writes&lt;&#x2F;h3&gt;
&lt;p&gt;Meanwhile, set-associative caches use flash as a large hash table where each flash page is a single &lt;em&gt;set&lt;&#x2F;em&gt;, or hash bucket.
During a lookup request, the cache hashes an object’s key to find it’s potential set on
flash and reads that flash page to find the object.&lt;&#x2F;p&gt;
&lt;p&gt;Since the finding objects is based on a hash function, set-associative caches
do not need large amounts of memory to track objects.
Thus, unlike log-structured caches, set-associative caches have a low
enough memory overhead to support large flash caches.&lt;&#x2F;p&gt;
&lt;p&gt;However, these caches write many more bytes than necessary.
When inserting a new object, the cache has to write, at a minimum,
a 4 KB flash page for every object.
If objects are roughly 100 bytes, the cache has a &lt;em&gt;40x&lt;&#x2F;em&gt; write amplification.
Thus, set-associative caches are also inefficient for tiny objects because they
require too many writes.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;kangaroo-an-efficient-tiny-object-flash-cache&quot;&gt;Kangaroo: An efficient tiny-object flash cache&lt;&#x2F;h2&gt;
&lt;p&gt;Kangaroo caches tiny objects on flash effectively by combining log-structured and set-associative caches to reduce both DRAM and flash-write overheads.
Kangaroo has two main parts: &lt;em&gt;KLog&lt;&#x2F;em&gt;, a small log-structured flash cache, and &lt;em&gt;KSet&lt;&#x2F;em&gt;, a large set-associative flash cache.
At a high level, Kangaroo uses KLog as a staging area for objects so that
writing them to KSet is more efficient.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;finding-objects-in-kangaroo&quot;&gt;Finding objects in Kangaroo&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;img src=&quot;..&#x2F;kangaroo-lookup.png&quot; alt=&quot;Lookup in Kangaroo&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;figure-caption&gt;
&lt;p&gt;On a lookup, Kangaroo looks for the object in (1) the DRAM cache, then (2a) KLog’s index and (2b) KLog if the key is in the index, then finally (3a) KSet’s
Bloom filters and (3b) KSet if the Bloom filters indicate the object could be there.
If the object is not found in any of these locations, Kangaroo returns a miss.&lt;&#x2F;p&gt;
&lt;&#x2F;figure-caption&gt;
&lt;h3 id=&quot;inserting-objects-in-kangaroo&quot;&gt;Inserting objects in Kangaroo&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;img src=&quot;..&#x2F;kangaroo-insert.png&quot; alt=&quot;Insert into Kangaroo&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;figure-caption&gt;
&lt;p&gt;On an insert, Kangaroo first places the object in (1) the DRAM cache.
This insertion may evict an object from the DRAM cache.
If the object is not admitted to flash, (2a) it is evicted from Kangaroo.
For instance, objects can be evicted at this stage based on a random admission policy,
where each object has a fixed probability of admission to the flash cache.
Otherwise, it is inserted into (2b) KLog’s index and (2c) written to flash in KLog via a buffered write.
When objects are evicted from KLog, they are again subject to an admission policy,
described more in the next section,
and (3a) can be evicted from Kangaroo entirely.
Admitted objects are written to (3b) KSet along with any other objects in KLog
that map to the same set in KSet.&lt;&#x2F;p&gt;
&lt;&#x2F;figure-caption&gt;
&lt;p&gt;One important aspect of the insertion path in Kangaroo that reduces write amplification
is how Kangaroo moves objects from KLog to KSet.
KLog often contains multiple objects mapping to the same set in KSet,
such as the pink and yellow objects in the figure above.
Whenever an object is evicted from KLog, Kangaroo proactively uses KLog’s index to
find any other objects that map to the same set in KSet,
and moves them to KLog as well.
Since writing a set always requires writing 4 KB, regardless of the number of objects inserted, writing multiple new objects instead of just 1 greatly reduces the the write amplification.&lt;&#x2F;p&gt;
&lt;p&gt;Thus, Kangaroo amortizes writes to KSet over multiple objects, decreasing the overall number of bytes written to flash.
Kangaroo accomplishes this amortization with a small KLog (~5% of flash), resulting in only a small DRAM overhead to index KLog’s entire capacity.
Kangaroo thus addresses both the DRAM and flash-write overheads of caching tiny objects on flash.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;kangaroo-optimizations&quot;&gt;Kangaroo optimizations&lt;&#x2F;h3&gt;
&lt;p&gt;On top of this basic design, Kangaroo introduces additional techniques to increase its effectiveness.
In particular, since Kangaroo is a cache and not a key-value store, it can evict objects to minimize writes.
Kangaroo exploits this opportunity by adding a threshold admission policy that evicts objects from KLog instead of admitting them to KSet if there are fewer than n objects to insert to a set in KSet.
This admission policy allows Kangaroo to guarantee that the write amplification for moving objects to KSet will be much lower than a set-associative cache.&lt;&#x2F;p&gt;
&lt;p&gt;Kangaroo also introduces RRIParoo, a low DRAM-overhead eviction policy for KSet
based on the processor eviction policy &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;people.csail.mit.edu&#x2F;emer&#x2F;papers&#x2F;2010.06.isca.rrip.pdf&quot;&gt;RRIP&lt;&#x2F;a&gt;.
At a high level, RRIParoo keeps one bit in DRAM per object in KSet
to represent whether an object has been requested since the object was last
written to flash.
When a set is rewritten, this bit is used to update a 3-bit recency values kept on flash per object.
Objects in a set are then ordered by their 3-bit recency value
and Kangaroo evicts the least valuable
objects to make room for objects coming from KLog.
Thus, RRIParoo allows an advanced eviction policy in KSet
while keeping a low DRAM overhead.&lt;&#x2F;p&gt;
&lt;p&gt;Kangaroo provides further optimizations to reduce DRAM overhead and reduce misses, as explained in our &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;3477132.3483568&quot;&gt;SOSP’21 paper&lt;&#x2F;a&gt;.
Together, these optimizations allow Kangaroo to overcome the limitations of log-structured caches and set-associative caches,
creating a flash cache that delivers on the goal of efficient caching for tiny objects.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;kangaroo-outperforms-other-flash-caches&quot;&gt;Kangaroo outperforms other flash caches&lt;&#x2F;h2&gt;
&lt;p&gt;We evaluated Kangaroo on a 2 TB flash drive using a production trace from Facebook
under production DRAM and write rate constraints.
We also evaluated CacheLib’s default small object cache (SA), a set-assocative
cache that Facebook uses to serve its social graph,
and an optimistic version of a log-structured cache (LS) with a full in-DRAM
index.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;..&#x2F;kangaroo-results.png&quot; alt=&quot;Kangaroo vs LS vs SA on production FB trace&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;figure-caption&gt;
&lt;p&gt;Kangaroo reduces misses compared to LS by 56% and to SA by 29% over the last
2 days of the production FB trace.
LS’s high DRAM overhead means that it cannot index the entire flash drive.
Thus, it has a lower effective capacity, which increases its miss ratio.
SA’s high write amplification means that it has to rate limit its insertions
and greatly over-provision flash to prevent the flash device from
wearing out too quickly.
Kangaroo does not run into these issues and has a better eviction policy,
allowing it to outperform other flash caches.&lt;&#x2F;p&gt;
&lt;&#x2F;figure-caption&gt;
&lt;p&gt;We corroborated these results in a production shadow deployment at Facebook.
In addition, Kangaroo maintains its advantage if operated under different constraints,
such as different write rate limits, more or less available DRAM, different tiny object workload, and larger device capacities. More details on these results can be found in our &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;3477132.3483568&quot;&gt;paper&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;Kangaroo is a flash cache for billions of tiny objects that handles a wide range of DRAM and flash-write budgets.
Kangaroo leverages prior log-structured and set-associative designs, together with new techniques, to achieve the best of both designs.
Experiments using a trace from Facebook show DRAM usage close to the best prior DRAM- optimized design,
flash writes close to the best prior write-optimized design,
and miss ratios better than either.
Kangaroo shows that flash caches can support tiny objects,
an adversarial workload for DRAM usage and write amplification,
while maintaining flash’s cost advantage.&lt;&#x2F;p&gt;
&lt;p&gt;For more details about Kangaroo, check out our SOSP &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=bJ4rqSrcVqs&quot;&gt;presentation&lt;&#x2F;a&gt; and &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;3477132.3483568&quot;&gt;paper&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;acknowledgments&quot;&gt;Acknowledgments&lt;&#x2F;h2&gt;
&lt;p&gt;I want to thank my other collaborators on this work:
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;bsb20.github.io&#x2F;&quot;&gt;Benjamin Berg&lt;&#x2F;a&gt; (CMU), &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;cmu.io&#x2F;%7Ejtutuncu&#x2F;&quot;&gt;Julian Tutuncu-Macias&lt;&#x2F;a&gt; (CMU, now at Goldman Sachs), &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;jasony.me&#x2F;&quot;&gt;Juncheng Yang&lt;&#x2F;a&gt; (CMU), Sathya Gunasekar (Facebook), Jimmy Lu (Facebook),
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;people&#x2F;daberg&#x2F;&quot;&gt;Daniel Berger&lt;&#x2F;a&gt; (Microsoft Research and University of Washington), &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ebeckmann&#x2F;&quot;&gt;Nathan Beckmann&lt;&#x2F;a&gt; (CMU), and &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;users.ece.cmu.edu&#x2F;%7Eganger&#x2F;&quot;&gt;Greg Ganger&lt;&#x2F;a&gt; (CMU).
I would also like to give a special thanks to the &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;cachelib.org&#x2F;&quot;&gt;CacheLib&lt;&#x2F;a&gt; team at Facebook
as well as both Facebook and Twitter for sharing traces with us.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Cases2Beds: A Case Study in Actionable Intelligence Highlights</title>
		<published>2022-01-06T00:00:00+00:00</published>
		<updated>2022-01-06T00:00:00+00:00</updated>
		<link href="https://www.cs.cmu.edu/~csd-phd-blog/2022/casestobeds/" type="text/html"/>
		<id>https://www.cs.cmu.edu/~csd-phd-blog/2022/casestobeds/</id>
		<content type="html">&lt;p&gt;&lt;em&gt;This blog post is adapted from the &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;delphi.cmu.edu&#x2F;blog&#x2F;2021&#x2F;03&#x2F;10&#x2F;cases2beds-a-case-study-in-actionable-intelligence&#x2F;&quot;&gt;Delphi blog&lt;&#x2F;a&gt;, originally published on March 10th, 2021. Again, thank you to the Allegheny County Health Department, the DELPHI Group, Chris Scott, and Roni Rosenfeld.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;One of the &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;delphi.cmu.edu&#x2F;&quot;&gt;Delphi Group&lt;&#x2F;a&gt;’s goals is to create informative tools for healthcare organizations. Tools are only useful if the insights they provide can inform concrete actions. That is to say these tools must provide actionable intelligence. In early November 2020, as COVID case rates in Allegheny County continued to rise, the Delphi Group partnered with the Allegheny County Health Department (ACHD) to create such tools for investigating if hospitals located in the county would run out of hospital beds for COVID patients &lt;a href=&quot;#f1&quot;&gt;(Fig. 1)&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;div id=&quot;f1&quot;&gt;&lt;&#x2F;div&gt;
&lt;p&gt;&lt;img src=&quot;.&#x2F;WPRDC-1.svg&quot; alt=&quot;Image of the hospitalizations due to COVID-19 and new cases from positive PCR tests in Allegheny County. There are rapid upward trends in hospitalizations and positive cases from October 2020 to mid-December 2020.  The maximum number of hospitalizations is about 600 and the minimum is less than 50 [in Oct 2020]. The maximum number of positive cases is over 7000 and the minimum is less than 1000 [in Oct 2020].&quot; &#x2F;&gt;
&lt;strong&gt;Fig. 1:&lt;&#x2F;strong&gt; Hospitalizations Due to COVID-19 and New Cases from Positive PCR Tests in Allegheny County (WPRDC Data &lt;sup&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2022&#x2F;casestobeds&#x2F;#WPRDCLink&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;)&lt;&#x2F;p&gt;
&lt;p&gt;Based on its planning, the ACHD needed at least a week to open emergency COVID facilities. If the emergency space wasn’t open and hospital beds ran out, mortality rates could soar. But, if we didn’t need the facility, that decision would have stretched already thin resources. Many of the hospitals in Allegheny County were in contact, but each hospital system only had visibility into its own facilities. We wanted to offer a more holistic picture of hospital resources for ACHD to assist in its planning.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;a-probabilistic-approach&quot;&gt;A Probabilistic Approach&lt;&#x2F;h2&gt;
&lt;p&gt;To provide county-level intelligence on hospital bed usage, we developed Cases2Beds&lt;sup&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2022&#x2F;casestobeds&#x2F;#Cases2BedsLink&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;To extrapolate beds utilization 1-2 weeks in the future, we needed to estimate:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;The probability that a person who tested positive for COVID-19 would require hospitalization&lt;&#x2F;li&gt;
&lt;li&gt;How many days after testing a person would be hospitalized&lt;&#x2F;li&gt;
&lt;li&gt;How long a person with COVID would stay in the hospital&lt;&#x2F;li&gt;
&lt;li&gt;The current number of positive COVID tests&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;These values vary by demographic factors, most notably age (&lt;a href=&quot;#f2&quot;&gt;Fig. 2&lt;&#x2F;a&gt;), and to a lesser extent, sex and race.&lt;&#x2F;p&gt;
&lt;div id=&quot;f2&quot;&gt;&lt;&#x2F;div&gt;
&lt;p&gt;&lt;img src=&quot;.&#x2F;rates-1.svg&quot; alt=&quot;Age Group Comparisons based on the Allegheny County COVID-19 Tableau. The age groups are 0-9, 10-19, 20-29, 30-39, 40-49, 50-59, 60-69, 70+, and unspecified. As the age group increases, the percent of those who were tested in that age group and were later hospitalized in that age group increases (the 70+ age group being &amp;gt; 5%).&quot; &#x2F;&gt;
&lt;strong&gt;Fig. 2:&lt;&#x2F;strong&gt; Age Group Comparisons based on the Allegheny County COVID-19 Tableau &lt;sup&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2022&#x2F;casestobeds&#x2F;#ACHDDashboardLink&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We used public data from Allegheny County about the number of people tested, test positivity rate, and hospitalization rate, broken down by the aforementioned demographic factors.&lt;&#x2F;p&gt;
&lt;p&gt;We also acquired information for two critical parameters: &lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Offset&lt;&#x2F;strong&gt;: Offset is the number of days between the day of testing (called specimen collection date) and the first day of hospitalization. For example, if the test date were 5 days before hospitalization, the offset would be 5 days. Also, if the test date is the hospital admit date, the offset would be 0 days (or sometimes, if, for example, they are admitted at midnight, -1 or +1 days). Notably, the offset can be negative, meaning a person may have been tested some days or weeks after admission.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Length of Stay&lt;&#x2F;strong&gt;: The length of stay is approximately how many days a person uses a bed in the hospital (± 1 day).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Given the hospitalization rate, the offset distribution, and the length of stay distribution, we can simulate multiple futures for any given set of positive cases and their testing dates. Estimating the future given a set of probabilities is a common problem and a possible approach is called a Monte Carlo simulation. This process ultimately shows the expected distribution of the number of beds needed each day.&lt;&#x2F;p&gt;
&lt;p&gt;Monte Carlo simulations involve running a large number of scenarios based on a set of probabilities. The more scenarios run, the more accurate the model tends to be. For example, if you gave 1000 people one dart to throw at a dartboard, even though each throw may not be very good, you’d still be able to get a pretty good idea of where the bull’s eye is after 1000 throws. This is the same principle we applied for Cases2Beds – after many simulations, we had a good idea of how many beds might be needed in the next two weeks.&lt;&#x2F;p&gt;
&lt;p&gt;Our prototype Monte Carlo simulation was written in Python and had a runtime of a few minutes. However, because the simulation works best with probabilities derived from Protected Health Information (PHI), ACHD needed to run it privately and offline so there would be no data transmission. Thus, any type of web application (which would transmit data to our servers) was ruled out. Even asking ACHD to run our Python software on their machines fell into a grey area. However, Microsoft Excel was easy to use and supported by ACHD. So we converted Cases2Beds into a spreadsheet. &lt;&#x2F;p&gt;
&lt;p&gt;It is relatively straightforward to port the Python application to VBScript macros for Microsoft Excel. However, those macros aren’t designed to run large simulations, and we saw that the time required to generate a model was far worse, bordering on unusable.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;an-alternative-to-monte-carlo-the-analytical-model&quot;&gt;An Alternative to Monte Carlo: the Analytical Model&lt;&#x2F;h2&gt;
&lt;p&gt;As an alternative, we developed an analytical model for Microsoft Excel that offered a much faster run time than the full Monte Carlo simulation. The sheet has two tabs of inputs: constant parameters (first tab, static), and case counts (second tab, dynamic). &lt;&#x2F;p&gt;
&lt;p&gt;The analytical model had the same idea as the Monte Carlo simulation. Some fraction of individuals who test positive today will be hospitalized after a varying offset (from test date to admit date) and variable duration (from admit date to discharge date) based on their characteristics (see &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2022&#x2F;casestobeds&#x2F;#app&quot;&gt;appendix&lt;&#x2F;a&gt;). Because these parameters can vary by region, anyone can change these values in spreadsheet tab 1.&lt;&#x2F;p&gt;
&lt;p&gt;The characteristics are:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Age Group: (Most important) [unspecified, 0-9, 10-19, 20-29 … 70-79, 80+]&lt;&#x2F;li&gt;
&lt;li&gt;Sex: [unspecified, M, F]&lt;&#x2F;li&gt;
&lt;li&gt;Race: [unspecified, Black, White, Hispanic, Asian]&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;And the parameters are:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Hospitalization Rate&lt;&#x2F;li&gt;
&lt;li&gt;Offset Distribution Parameter Set: Parameters describing the number of days before someone who tests positive is hospitalized&lt;&#x2F;li&gt;
&lt;li&gt;Duration Distribution Parameter Set: Parameters describing the number of days someone will be in the hospital&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;The second types of inputs are the daily positive cases split by their traits. This is the input that the user actively changes on their end.&lt;&#x2F;p&gt;
&lt;p&gt;Behind the scenes, we take these parameters (first input tab) and generate Offset Fractions, which is the probability that a patient with given traits will occupy a bed for a duration k days after the specimen testing date. These Offset Fractions and the daily positive case breakdown (second input) give us the expected mean and variance up to 1 month in the future of the number of patients in the hospital per day based on the cases already seen (for details, see &lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2022&#x2F;casestobeds&#x2F;#app&quot;&gt;appendix&lt;&#x2F;a&gt;). This information can be used to generate plots like &lt;a href=&quot;#f3&quot;&gt;(Fig. 3)&lt;&#x2F;a&gt;. This graph isn’t to suggest that there won’t be any need for beds after February! It is just that based on the cases we know, very few people will be hospitalized for more than a month.&lt;&#x2F;p&gt;
&lt;div id=&quot;f3&quot;&gt;&lt;&#x2F;div&gt;
&lt;p&gt;&lt;img src=&quot;.&#x2F;C2B-1.svg&quot; alt=&quot;Output of Cases2Beds using historical data until January 21st for Allegheny County Using Public Parameters. In the output of Cases2Beds, we see a peak in mid-December 2020 in the mean number of beds, followed by a stagnation period in mid-January 2021 and a rapid decline until the end of March 2021.  The 25-75 Quantile and 5-95 Quantile are highlighted on the graph with the band having the largest width between mid-December 2020 and mid-January 2021. &quot; &#x2F;&gt;
&lt;strong&gt;Fig. 3:&lt;&#x2F;strong&gt;  Output of Cases2Beds using historical data until January 21st for Allegheny County Using Public Parameters&lt;&#x2F;p&gt;
&lt;p&gt;If we assume independence between patients, the mean and variance calculations are exact. However, our quantile estimates are based on approximating the sum of independent binary variables, which is inaccurate near the tails. So the accuracy of the more extreme quantiles (95%+) depends on the number of cases present, which in practice makes them less trustworthy.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cases2beds-in-action&quot;&gt;Cases2Beds in Action&lt;&#x2F;h2&gt;
&lt;p&gt;By the end of November 2020, we had a viable prototype Cases2Beds spreadsheet used by ACHD. Over the following months, we made various modifications with their feedback. For example, the ACHD staff did not have time to manually input case numbers. So, we were able to use the granular public data to give them estimates of future hospital utilization without any additional work on their end. &lt;&#x2F;p&gt;
&lt;p&gt;At the peak of bed utilization, hospital systems themselves increased their COVID beds utilization to 6x more than in October 2020. Fortunately, in Allegheny County, we never reached a point where demand for beds exceeded a somewhat elastic supply. In early January 2021, multiple organizations told us that the pandemic’s most acute problem had changed to vaccine distribution and the number of COVID-19 beds needed dropped. Cases2Beds continues to act as an early warning system if the number of cases rise quickly.&lt;&#x2F;p&gt;
&lt;div id=&quot;f4&quot;&gt;&lt;&#x2F;div&gt;
&lt;p&gt;&lt;img src=&quot;.&#x2F;HHS-1.svg&quot; alt=&quot;Numbers of staffed COVID beds over time vs. capacity from the HHS Protect Data. There was peak hospital utilization (7-day Average of COVID Adult Beds Used) in mid-December 2020 (over 800 beds avg.) before a steady decline until February 2021 (around 200 beds avg). &quot; &#x2F;&gt;
&lt;strong&gt;Fig. 4:&lt;&#x2F;strong&gt; Numbers of staffed COVID beds over time vs. capacity from the HHS Protect Data &lt;sup&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2022&#x2F;casestobeds&#x2F;#HHSLink&quot;&gt;5&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We were also able to show the efficacy of the spreadsheet to other health departments and hospitals by generating tailored, public parameters for offset and length of stay from different national public resources, like the Florida line-level COVID dataset &lt;sup&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2022&#x2F;casestobeds&#x2F;#FloridaLineLevelLink&quot;&gt;4&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;. &lt;&#x2F;p&gt;
&lt;p&gt;Based on these organizations’ feedback that they needed projections more than 2 weeks out, we started to use Cases2Beds as an input to hospital utilization forecasting models. Other inputs to the hospital forecasting model included current hospital bed utilization  (from HHS Protect&lt;sup&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;%7Ecsd-phd-blog&#x2F;2022&#x2F;casestobeds&#x2F;#HHSLink&quot;&gt;5&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;), how long current patients are likely to continue to be hospitalized, and how many new cases there will be in the near future. A preliminary evaluation of such a method shows decent predictive power when parameters are tailored to a location.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;Cases2Beds was a case study about the realities of research institutions offering actionable intelligence in healthcare. While the Cases2Beds tool demonstrated reasonable predictive power, it was difficult to deploy it in a timely and actionable way. Our most significant challenges were data access and bureaucratic limitations to develop solutions at the granularity needed. &lt;&#x2F;p&gt;
&lt;p&gt;Research institutions can be effective partners to health organizations, but the next set of challenges of this pandemic–or the next–will require quick action. The tools we build now can set the stage for the future. &lt;&#x2F;p&gt;
&lt;p&gt;Thank you to the Allegheny County Health Department (especially Antony Gnalian, Dr. LuAnn Brink, and Dr. Debra Bogen) for their invaluable feedback, efforts, and shared interest in actionable intelligence.&lt;&#x2F;p&gt;
&lt;p&gt;Many members of the Delphi Group, including Sumit Agrawal, Katie Mazaitis, and Phil McGuinness, met regularly with the Allegheny County Health Department, provided data, edited this blog post, and investigated various solutions other than Cases2Beds.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;resources&quot;&gt;Resources&lt;&#x2F;h2&gt;
&lt;p&gt;Please check out the &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;cmu-delphi&#x2F;cases-to-beds-public&quot;&gt;Cases2Beds Github Repo&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a id=&quot;WPRDCLink&quot;&gt;1.&lt;&#x2F;a&gt;  &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;data.wprdc.org&#x2F;dataset&#x2F;allegheny-county-covid-19-tests-cases-and-deaths&quot;&gt;WPRDC Allegheny County COVID dataset&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a id=&quot;Cases2BedsLink&quot;&gt;2.&lt;&#x2F;a&gt; &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.cmu.edu&#x2F;delphi-web&#x2F;cases2beds-v0.2.3.xlsm&quot;&gt;Cases2Beds Worksheet&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a id=&quot;ACHDDashboardLink&quot;&gt;3.&lt;&#x2F;a&gt;  &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;tableau.alleghenycounty.us&#x2F;t&#x2F;PublicSite&#x2F;views&#x2F;AlleghenyCountyCOVID-19Information_15912788131180&#x2F;Landingpage?iframeSizedToWindow=true&amp;amp;%3Aembed=y&amp;amp;%3AshowAppBanner=false&amp;amp;%3Adisplay_count=no&amp;amp;%3AshowVizHome=no&amp;amp;%3Aorigin=viz_share_link&quot;&gt;ACHD COVID-19 Dashboard&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a id=&quot;FloridaLineLevelLink&quot;&gt;4.&lt;&#x2F;a&gt;  &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;experience.arcgis.com&#x2F;experience&#x2F;96dd742462124fa0b38ddedb9b25e429&quot;&gt;Florida line-level COVID dataset&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a id=&quot;HHSLink&quot;&gt;5.&lt;&#x2F;a&gt;  &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;healthdata.gov&#x2F;Hospital&#x2F;COVID-19-Reported-Patient-Impact-and-Hospital-Capa&#x2F;anag-cw7u&quot;&gt;HHS Protect Hospital Utilization Data&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;div id=&quot;app&quot;&gt;&lt;&#x2F;div&gt;
&lt;h2 id=&quot;appendix&quot;&gt;Appendix&lt;&#x2F;h2&gt;
&lt;p&gt;To generate the Offset Fractions (OF(k|traits)), which is the probability a patient with given traits will occupy a bed on k days after the specimen testing date, we follow &lt;strong&gt;Alg 1&lt;&#x2F;strong&gt;. For a given set of traits, the Offset Fractions for day k, where k is between -10 and 31, is the sum of the offset * distribution probabilities * hospitalization rate that sum up to day k. From these Offset Fractions, the mean&#x2F;var of bed occupancy on a given day is given in &lt;strong&gt;Alg 2&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#393939;color:#dedede;&quot;&gt;&lt;code&gt;&lt;span&gt;for o in (-10, 30): #This is the offset
&lt;&#x2F;span&gt;&lt;span&gt;    for d in (0, 40): #This is the duration of the stay
&lt;&#x2F;span&gt;&lt;span&gt;              for k in (o, o+d): 
&lt;&#x2F;span&gt;&lt;span&gt;                    if (k&amp;lt;31): 
&lt;&#x2F;span&gt;&lt;span&gt;                          OF(k|traits) += Offset(o|traits) * Duration(d|traits) * Hospitalization(traits)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Alg 1&lt;&#x2F;strong&gt;: Generate Occupancy Fractions for a given set of traits&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#393939;color:#dedede;&quot;&gt;&lt;code&gt;&lt;span&gt;for specimen_date and num_cases in case_inputs: 
&lt;&#x2F;span&gt;&lt;span&gt;     for t in (-10, 30):
&lt;&#x2F;span&gt;&lt;span&gt;          p = OF(t|traits)
&lt;&#x2F;span&gt;&lt;span&gt;          beds_mean(spec_date + t) += num_cases * p
&lt;&#x2F;span&gt;&lt;span&gt;          beds_var(spec_date + t) += num_cases*p*(1-p)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Alg 2&lt;&#x2F;strong&gt;: Generate Mean and Variances&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;High-level Mathematical Formulation of the Model:&lt;&#x2F;strong&gt; &lt;&#x2F;p&gt;
&lt;p&gt;O&lt;sub&gt;r,l&lt;&#x2F;sub&gt;: The offset value for a given subset of the population r &lt;span&gt;∈&lt;&#x2F;span&gt; R where R := {race}x{gender}x{age group} for a given day l where -10 &lt;span&gt;≤&lt;&#x2F;span&gt; l &lt;span&gt;≤&lt;&#x2F;span&gt;  30. This &lt;strong&gt;pdf&lt;&#x2F;strong&gt; is derived from a piecewise function using segments of exponential distributions characterized by the offset parameters. &lt;&#x2F;p&gt;
&lt;p&gt;D&lt;sub&gt;r,k&lt;&#x2F;sub&gt;: The duration value for a given subset of the population r &lt;span&gt;∈&lt;&#x2F;span&gt; R for a given day k where 0 &lt;span&gt;≤&lt;&#x2F;span&gt; k &lt;span&gt;≤&lt;&#x2F;span&gt;  40. This &lt;strong&gt;pdf&lt;&#x2F;strong&gt; is derived from a piecewise function using segments of exponential distributions characterized by the duration parameters. &lt;&#x2F;p&gt;
&lt;p&gt;h&lt;sub&gt;r&lt;&#x2F;sub&gt;: The hospitalization rate for a given subset of the population r &lt;span&gt;∈&lt;&#x2F;span&gt; R where 0 &lt;span&gt;≤&lt;&#x2F;span&gt; h&lt;sub&gt;r&lt;&#x2F;sub&gt; &lt;span&gt;≤&lt;&#x2F;span&gt; 1 &lt;&#x2F;p&gt;
&lt;p&gt;c&lt;sub&gt;r,d&lt;&#x2F;sub&gt;: The number of cases for a given subset of the population r &lt;span&gt;∈&lt;&#x2F;span&gt; R on a particular specimen collection date d (ex: 5 cases with specimen collected on January 1st 2021).&lt;&#x2F;p&gt;
&lt;p&gt;$$OF_{r, j} = \sum_{l=-10}^{30} \sum_{k=0}^{40} \mathbb{I} (  l \leq j \leq l+k ) O_{r, l} * D_{r, k}*h_r $$ 
The offset fraction for a given subset of the population r &lt;span&gt;∈&lt;&#x2F;span&gt; R for a given delta j where -10 &lt;span&gt;≤&lt;&#x2F;span&gt; j &lt;span&gt;≤&lt;&#x2F;span&gt;  30.&lt;&#x2F;p&gt;
&lt;p&gt;$$ \mathbb{E}[\beta_i] = \sum_{d \in D}\sum_{r \in R}\sum_{j = -10}^{30}  \mathbb{I} ( d+j = i)  OF_{r, j}*c_{r, d} $$ 
The expected number of beds on date i, where i can start 10 days before the first case date and can end 30 days after the the last case date (c&lt;sub&gt;r,d&lt;&#x2F;sub&gt;)&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Hello World</title>
		<published>2021-08-16T00:00:00+00:00</published>
		<updated>2021-08-16T00:00:00+00:00</updated>
		<link href="https://www.cs.cmu.edu/~csd-phd-blog/2021/helloworld/" type="text/html"/>
		<id>https://www.cs.cmu.edu/~csd-phd-blog/2021/helloworld/</id>
		<content type="html">&lt;h1 id=&quot;hello-world&quot;&gt;Hello World!&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;hello&quot;&gt;Hello&lt;&#x2F;h2&gt;
&lt;p&gt;This is the first post being made to the CSD PhD blog, testing out the
system. And so, indeed, hello world!&lt;&#x2F;p&gt;
&lt;p&gt;That’s really all there is to this
post. You don’t need to keep reading. I just have to fill this space so
that the preview of this post is filled up. That way when it renders
we can see what it looks like full of text. So this is just filler text,
explaining what is going on in a meta way. Feel free to ignore it and
just go about your business.&lt;&#x2F;p&gt;
&lt;p&gt;But it seems that you are in fact continuing to read. I wonder why. 
Perhaps if I had filled this
section in with &lt;em&gt;Lorem ipsum&lt;&#x2F;em&gt; it would be a better signal that there are
no secrets to be gotten from reading this section. You are still reading though.
Just reading along. This is just a test post,
and here you are, taking all this time to read it. It’s just gonna be
filled with meaningless filler text. Well, that and some markdown
rendering tests. Most of them are coming up in
the next section. And since you keep on reading, you’ll certainly run
into them. That’s probably going to be even more bland to read. It’s
just going to repeat “Hello World” over and over again. But maybe
you just enjoy reading any words at all. You are, after all, still
reading this.&lt;&#x2F;p&gt;
&lt;p&gt;What, did you still think there was going to be some
secret in this section? Well, there’s not. Honestly its just filler text.
I know, there were these whole additional paragraphs, but they’re not special - just testing
the paragraph break rendering. And, yeah, it works. You saw the paragraph break, right?
Or are you just reading on without paying attention? Or, actually, did the site break?
Well, whatever, this test post can’t do anything about it. No, this post just going to
go on, unread, moldering in a virtual corner. Well, almost unread. You are reading this.
I still don’t know why, but you’ve made it a long way through. Honestly, you could
probably go longer than I care to write for a post as meaningless as this.
Next time, I’m just going to use &lt;em&gt;Lorem ipsum&lt;&#x2F;em&gt; to fill space.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;world&quot;&gt;World&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;em&gt;Hello World&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Hello World&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;del&gt;Hello World&lt;&#x2F;del&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;Hello World&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;$$Hello World$$&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hello World&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Hello&lt;&#x2F;li&gt;
&lt;li&gt;World&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#393939;color:#dedede;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span style=&quot;color:#fed6af;&quot;&gt;#include &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d6d6d680;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d68686;&quot;&gt;stdio.h&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d6d6d680;&quot;&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffb9d;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffd87;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fffd87;&quot;&gt;printf&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d6d6d680;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d68686;&quot;&gt;Hello World!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d6d6d680;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fed6af;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#87d6d5;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;right&quot;&gt;Hello&lt;&#x2F;th&gt;&lt;th align=&quot;left&quot;&gt;World&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td align=&quot;right&quot;&gt;Hi&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;Universe&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;right&quot;&gt;Greetings&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;Earth&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;right&quot;&gt;Hey&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;Everything&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;right&quot;&gt;Sup&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;Realm&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;%22Hello,_World!%22_program&quot;&gt;Further Reading&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;lorem-ipsum&quot;&gt;Lorem Ipsum&lt;&#x2F;h1&gt;
&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut rutrum nulla luctus tristique porttitor. Curabitur ut nibh non nulla dapibus facilisis. In maximus, nisi bibendum volutpat sagittis, enim ligula vehicula dolor, a dignissim est justo quis lorem. Nulla cursus sagittis magna facilisis imperdiet. Etiam non luctus arcu. Sed vulputate urna urna, sed convallis metus imperdiet et. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Praesent ut ornare nisl, sit amet congue ligula. Ut iaculis euismod dictum. Donec est arcu, porta nec sem vel, euismod mollis eros. Nulla consequat vel magna nec ornare. Pellentesque eu massa vel orci ornare ultrices nec in nunc.&lt;&#x2F;p&gt;
&lt;p&gt;Quisque tellus est, accumsan vitae ullamcorper a, maximus et ante. Mauris odio sem, bibendum fringilla ullamcorper tempor, molestie id dolor. Nulla sed tincidunt sapien. Duis vitae arcu sollicitudin, ullamcorper est vel, varius dolor. Nunc augue erat, congue ut tincidunt id, ornare a libero. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque purus diam, ornare sed suscipit a, euismod in justo.&lt;&#x2F;p&gt;
&lt;p&gt;Aliquam aliquam congue eros vel volutpat. Nunc ullamcorper vitae mi vehicula commodo. Phasellus ultricies a nunc a blandit. Integer tincidunt velit ut metus vehicula, vitae dictum eros sodales. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Cras consectetur suscipit maximus. Integer ut sem fringilla, interdum nulla sed, pretium nisi. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Nam lobortis mollis leo, ut condimentum erat hendrerit sit amet. Donec vitae semper risus. Aenean sollicitudin tincidunt laoreet. Quisque velit tellus, vestibulum sed nisi et, pharetra feugiat nunc.&lt;&#x2F;p&gt;
&lt;p&gt;Morbi luctus lobortis orci id aliquam. Pellentesque viverra arcu nunc, sed ultricies lectus molestie quis. Praesent cursus dui elementum purus tempor vehicula. Nulla sed ligula blandit, tristique purus nec, consequat ex. Nunc et consequat ligula, nec vehicula nisi. Integer imperdiet nisl felis, nec porttitor quam maximus quis. Sed commodo lacus eget urna consequat gravida. Proin pellentesque mollis magna, eu consectetur nulla efficitur vitae. Nullam rhoncus faucibus sapien id gravida. Nam maximus pellentesque lorem, auctor vulputate quam porttitor sed. Praesent fringilla id eros sit amet lobortis. Donec ultrices pretium nisl sit amet euismod. Vestibulum consectetur euismod orci non fermentum. Nam congue sapien id interdum malesuada. Sed sit amet rhoncus magna, vel gravida sem. Praesent tincidunt consectetur gravida.&lt;&#x2F;p&gt;
&lt;p&gt;Ut consectetur, ex at sagittis blandit, libero magna dictum velit, nec ullamcorper erat diam nec urna. Curabitur tincidunt nisi risus, non pulvinar ipsum eleifend et. Pellentesque nec dolor non tellus efficitur mattis vitae sed neque. Suspendisse lectus nulla, mollis in fermentum ac, tempus a sapien. Suspendisse tempor consectetur porttitor. Aenean sed purus tempor, mollis lectus ac, tristique odio. Sed purus risus, tempus non risus aliquet, tincidunt aliquam eros. Vestibulum eget sollicitudin diam, porta rhoncus felis. Cras pellentesque vestibulum euismod. Phasellus placerat iaculis quam, quis suscipit elit semper ut.
Foundus theus secretus. Donec tempus sed justo nec semper. Vestibulum blandit velit quis risus lobortis, sit amet efficitur nulla scelerisque. Phasellus condimentum lectus non augue molestie, egestas auctor turpis porta. Mauris eget est a eros venenatis tempus. Duis lorem nisl, vulputate et neque et, ullamcorper ornare ipsum.&lt;&#x2F;p&gt;
</content>
	</entry>
</feed>
